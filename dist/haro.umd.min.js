/*!
 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
 @version 16.0.0
*/
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("crypto")):"function"==typeof define&&define.amd?define(["exports","crypto"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).lru={},e.crypto)}(this,function(e,t){"use strict";const s="",i="function",r="records",n="Invalid function";class h{constructor({delimiter:e="|",id:t=this.uuid(),immutable:s=!1,index:i=[],key:r="id",versioning:n=!1}={}){return this.data=new Map,this.delimiter=e,this.id=t,this.immutable=s,this.index=Array.isArray(i)?[...i]:[],this.indexes=new Map,this.key=r,this.versions=new Map,this.versioning=n,Object.defineProperty(this,"registry",{enumerable:!0,get:()=>Array.from(this.data.keys())}),Object.defineProperty(this,"size",{enumerable:!0,get:()=>this.data.size}),this.reindex()}batch(e,t="set"){const s="del"===t?e=>this.delete(e,!0):e=>this.set(null,e,!0,!0);return this.onbatch(this.beforeBatch(e,t).map(s),t)}beforeBatch(e,t=""){}beforeClear(){}beforeDelete(e="",t=!1){}beforeSet(e="",t={},s=!1,i=!1){}clear(){return this.beforeClear(),this.data.clear(),this.indexes.clear(),this.versions.clear(),this.reindex().onclear(),this}clone(e){return structuredClone(e)}delete(e="",t=!1){if(!this.data.has(e))throw new Error("Record not found");const s=this.get(e,!0);this.beforeDelete(e,t),this.deleteIndex(e,s),this.data.delete(e),this.ondelete(e,t),this.versioning&&this.versions.delete(e)}deleteIndex(e,t){return this.index.forEach(s=>{const i=this.indexes.get(s);if(!i)return;const r=s.includes(this.delimiter)?this.indexKeys(s,this.delimiter,t):Array.isArray(t[s])?t[s]:[t[s]];this.each(r,t=>{if(i.has(t)){const s=i.get(t);s.delete(e),0===s.size&&i.delete(t)}})}),this}dump(e=r){let t;return t=e===r?Array.from(this.entries()):Array.from(this.indexes).map(e=>(e[1]=Array.from(e[1]).map(e=>(e[1]=Array.from(e[1]),e)),e)),t}each(e=[],t){const s=e.length;for(let i=0;i<s;i++)t(e[i],i);return e}entries(){return this.data.entries()}find(e={},t=!1){const s=Object.keys(e).sort((e,t)=>e.localeCompare(t)).join(this.delimiter),i=this.indexes.get(s)??new Map;let r=[];if(i.size>0){const n=this.indexKeys(s,this.delimiter,e);r=Array.from(n.reduce((e,t)=>(i.has(t)&&i.get(t).forEach(t=>e.add(t)),e),new Set)).map(e=>this.get(e,t))}return!t&&this.immutable&&(r=Object.freeze(r)),r}filter(e,t=!1){if(typeof e!==i)throw new Error(n);let s=this.reduce((t,s)=>(e(s)&&t.push(s),t),[]);return t||(s=s.map(e=>this.list(e)),this.immutable&&(s=Object.freeze(s))),s}forEach(e,t=this){return this.data.forEach((s,i)=>{this.immutable&&(s=this.clone(s)),e.call(t,s,i)},this),this}freeze(...e){return Object.freeze(e.map(e=>Object.freeze(e)))}get(e,t=!1){let s=this.data.get(e)??null;return null===s||t||(s=this.list(s),this.immutable&&(s=Object.freeze(s))),s}has(e){return this.data.has(e)}indexKeys(e="",t="|",s={}){const i=e.split(t).sort((e,t)=>e.localeCompare(t)),r=i.length;let n=[""];for(let e=0;e<r;e++){const r=i[e],h=Array.isArray(s[r])?s[r]:[s[r]],a=[],o=n.length,l=h.length;for(let s=0;s<o;s++)for(let i=0;i<l;i++){const r=0===e?h[i]:`${n[s]}${t}${h[i]}`;a.push(r)}n=a}return n}keys(){return this.data.keys()}limit(e=0,t=0,s=!1){let i=this.registry.slice(e,e+t).map(e=>this.get(e,s));return!s&&this.immutable&&(i=Object.freeze(i)),i}list(e){const t=[e[this.key],e];return this.immutable?this.freeze(...t):t}map(e,t=!1){if(typeof e!==i)throw new Error(n);let s=[];return this.forEach((t,i)=>s.push(e(t,i))),t||(s=s.map(e=>this.list(e)),this.immutable&&(s=Object.freeze(s))),s}merge(e,t,s=!1){return Array.isArray(e)&&Array.isArray(t)?e=s?t:e.concat(t):"object"==typeof e&&null!==e&&"object"==typeof t&&null!==t?this.each(Object.keys(t),i=>{e[i]=this.merge(e[i],t[i],s)}):e=t,e}onbatch(e,t=""){}onclear(){}ondelete(e="",t=!1){}onoverride(e=""){}onset(e={},t=!1){}override(e,t=r){if("indexes"===t)this.indexes=new Map(e.map(e=>[e[0],new Map(e[1].map(e=>[e[0],new Set(e[1])]))]));else{if(t!==r)throw new Error("Invalid type");this.indexes.clear(),this.data=new Map(e)}return this.onoverride(t),!0}reduce(e,t=[]){let s=t;return this.forEach((t,i)=>{s=e(s,t,i,this)},this),s}reindex(e){const t=e?[e]:this.index;return e&&!1===this.index.includes(e)&&this.index.push(e),this.each(t,e=>this.indexes.set(e,new Map)),this.forEach((e,s)=>this.each(t,t=>this.setIndex(s,e,t))),this}search(e,t,s=!1){const r=new Set,n=typeof e===i,h=e&&typeof e.test===i;if(!e)return this.immutable?this.freeze():[];const a=t?Array.isArray(t)?t:[t]:this.index;for(const t of a){const s=this.indexes.get(t);if(s)for(const[i,a]of s){let s=!1;if(s=n?e(i,t):h?e.test(Array.isArray(i)?i.join(","):i):i===e,s)for(const e of a)this.data.has(e)&&r.add(e)}}let o=Array.from(r).map(e=>this.get(e,s));return!s&&this.immutable&&(o=Object.freeze(o)),o}set(e=null,t={},s=!1,i=!1){null===e&&(e=t[this.key]??this.uuid());let r={...t,[this.key]:e};if(this.beforeSet(e,r,s,i),this.data.has(e)){const t=this.get(e,!0);this.deleteIndex(e,t),this.versioning&&this.versions.get(e).add(Object.freeze(this.clone(t))),i||(r=this.merge(this.clone(t),r))}else this.versioning&&this.versions.set(e,new Set);this.data.set(e,r),this.setIndex(e,r,null);const n=this.get(e);return this.onset(n,s),n}setIndex(e,t,s){return this.each(null===s?this.index:[s],s=>{let i=this.indexes.get(s);i||(i=new Map,this.indexes.set(s,i));const r=t=>{i.has(t)||i.set(t,new Set),i.get(t).add(e)};s.includes(this.delimiter)?this.each(this.indexKeys(s,this.delimiter,t),r):this.each(Array.isArray(t[s])?t[s]:[t[s]],r)}),this}sort(e,t=!1){const s=this.data.size;let i=this.limit(0,s,!0).sort(e);return t&&(i=this.freeze(...i)),i}sortBy(e="",t=!1){if(e===s)throw new Error("Invalid field");let i=[];const r=[];!1===this.indexes.has(e)&&this.reindex(e);const n=this.indexes.get(e);return n.forEach((e,t)=>r.push(t)),this.each(r.sort((e,t)=>e.localeCompare(t)),e=>n.get(e).forEach(e=>i.push(this.get(e,t)))),this.immutable&&(i=Object.freeze(i)),i}toArray(){const e=Array.from(this.data.values());return this.immutable&&(this.each(e,e=>Object.freeze(e)),Object.freeze(e)),e}uuid(){return t.randomUUID()}values(){return this.data.values()}matchesPredicate(e,t,s){return Object.keys(t).every(i=>{const r=t[i],n=e[i];return Array.isArray(r)?Array.isArray(n)?"&&"===s?r.every(e=>n.includes(e)):r.some(e=>n.includes(e)):"&&"===s?r.every(e=>n===e):r.some(e=>n===e):r instanceof RegExp?Array.isArray(n)?"&&"===s?n.every(e=>r.test(e)):n.some(e=>r.test(e)):r.test(n):Array.isArray(n)?n.includes(r):n===r})}where(e={},t="||"){const s=this.index.filter(t=>t in e);if(0===s.length)return[];const i=s.filter(e=>this.indexes.has(e));if(i.length>0){let s=new Set,r=!0;for(const t of i){const i=e[t],n=this.indexes.get(t),h=new Set;if(Array.isArray(i)){for(const e of i)if(n.has(e))for(const t of n.get(e))h.add(t)}else if(n.has(i))for(const e of n.get(i))h.add(e);r?(s=h,r=!1):s=new Set([...s].filter(e=>h.has(e)))}const n=[];for(const i of s){const s=this.get(i,!0);this.matchesPredicate(s,e,t)&&n.push(this.immutable?this.get(i):s)}return this.immutable?this.freeze(...n):n}return this.filter(s=>this.matchesPredicate(s,e,t))}}e.Haro=h,e.haro=function(e=null,t={}){const s=new h(t);return Array.isArray(e)&&s.batch(e,"set"),s}});//# sourceMappingURL=haro.umd.min.js.map
