/*!
 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
 @version 15.2.6
*/
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).lru={})}(this,(function(e){"use strict";const t="",s="function",r="Invalid function",i="records",n=[8,9,"a","b"];function h(){return(65536*(Math.random()+1)|0).toString(16).substring(1)}const a="object"==typeof crypto?crypto.randomUUID.bind(crypto):function(){return`${h()}${h()}-${h()}-4${h().slice(0,3)}-${n[Math.floor(4*Math.random())]}${h().slice(0,3)}-${h()}${h()}${h()}`};class o{constructor({delimiter:e="|",id:t=this.uuid(),index:s=[],key:r="id",versioning:i=!1}={}){return this.data=new Map,this.delimiter=e,this.id=t,this.index=Array.isArray(s)?[...s]:[],this.indexes=new Map,this.key=r,this.versions=new Map,this.versioning=i,Object.defineProperty(this,"registry",{enumerable:!0,get:()=>Array.from(this.data.keys())}),Object.defineProperty(this,"size",{enumerable:!0,get:()=>this.data.size}),this.reindex()}batch(e,t="set"){const s="del"===t?e=>this.del(e,!0):e=>this.set(null,e,!0,!0);return this.onbatch(this.beforeBatch(e,t).map(s),t)}beforeBatch(e,t=""){return e}beforeClear(){}beforeDelete(e="",t=!1){return[e,t]}beforeSet(e="",t=!1){return[e,t]}clear(){return this.beforeClear(),this.data.clear(),this.indexes.clear(),this.versions.clear(),this.reindex().onclear(),this}clone(e){return JSON.parse(JSON.stringify(e))}del(e="",t=!1){if(!this.data.has(e))throw new Error("Record not found");const s=this.get(e,!0);this.beforeDelete(e,t),this.delIndex(this.index,this.indexes,this.delimiter,e,s),this.data.delete(e),this.ondelete(e,t),this.versioning&&this.versions.delete(e)}delIndex(e,t,s,r,i){e.forEach((e=>{const n=t.get(e);if(!n)return;const h=e.includes(s)?this.indexKeys(e,s,i):Array.isArray(i[e])?i[e]:[i[e]];this.each(h,(e=>{if(n.has(e)){const t=n.get(e);t.delete(r),0===t.size&&n.delete(e)}}))}))}dump(e=i){let t;return t=e===i?Array.from(this.entries()):Array.from(this.indexes).map((e=>(e[1]=Array.from(e[1]).map((e=>(e[1]=Array.from(e[1]),e))),e))),t}each(e=[],t){for(const[s,r]of e.entries())t(r,s);return e}entries(){return this.data.entries()}find(e={},t=!1){const s=Object.keys(e).sort().join(this.delimiter),r=this.indexes.get(s)??new Map;let i=[];if(r.size>0){const n=this.indexKeys(s,this.delimiter,e);i=Array.from(n.reduce(((e,t)=>(r.has(t)&&r.get(t).forEach((t=>e.add(t))),e)),new Set)).map((e=>this.get(e,t)))}return t?i:this.list(...i)}filter(e,t=!1){if(typeof e!==s)throw new Error(r);const i=t?(e,t)=>t:(e,t)=>Object.freeze([e,Object.freeze(t)]),n=this.reduce(((t,s,r,n)=>(e.call(n,s)&&t.push(i(r,s)),t)),[]);return t?n:Object.freeze(n)}forEach(e,t){return this.data.forEach(((t,s)=>e(this.clone(t),this.clone(s))),t??this.data),this}get(e,t=!1){const s=this.clone(this.data.get(e)??null);return t?s:this.list(e,s)}has(e){return this.data.has(e)}indexKeys(e="",t="|",s={}){return e.split(t).reduce(((e,r,i)=>{const n=[];return(Array.isArray(s[r])?s[r]:[s[r]]).forEach((s=>0===i?n.push(s):e.forEach((e=>n.push(`${e}${t}${s}`))))),n}),[])}keys(){return this.data.keys()}limit(e=0,t=0,s=!1){const r=this.registry.slice(e,e+t).map((e=>this.get(e,s)));return s?r:this.list(...r)}list(...e){return Object.freeze(e.map((e=>Object.freeze(e))))}map(e,t=!1){if(typeof e!==s)throw new Error(r);const i=[];return this.forEach(((t,s)=>i.push(e(t,s)))),t?i:this.list(...i)}merge(e,t,s=!1){return Array.isArray(e)&&Array.isArray(t)?e=s?t:e.concat(t):"object"==typeof e&&null!==e&&"object"==typeof t&&null!==t?this.each(Object.keys(t),(r=>{e[r]=this.merge(e[r],t[r],s)})):e=t,e}onbatch(e,t=""){return e}onclear(){}ondelete(e="",t=!1){return[e,t]}onoverride(e=""){return e}onset(e={},t=!1){return[e,t]}override(e,t=i){if("indexes"===t)this.indexes=new Map(e.map((e=>[e[0],new Map(e[1].map((e=>[e[0],new Set(e[1])])))])));else{if(t!==i)throw new Error("Invalid type");this.indexes.clear(),this.data=new Map(e)}return this.onoverride(t),!0}reduce(e,t,s=!1){let r=t??this.data.keys().next().value;return this.forEach(((t,i)=>{r=e(r,t,i,this,s)}),this),r}reindex(e){const t=e?[e]:this.index;return e&&!1===this.index.includes(e)&&this.index.push(e),this.each(t,(e=>this.indexes.set(e,new Map))),this.forEach(((e,s)=>this.each(t,(t=>this.setIndex(this.index,this.indexes,this.delimiter,s,e,t))))),this}search(e,t,r=!1){const i=new Map,n=typeof e===s,h=e&&typeof e.test===s;return e&&this.each(t?Array.isArray(t)?t:[t]:this.index,(t=>{let s=this.indexes.get(t);s&&s.forEach(((s,a)=>{switch(!0){case n&&e(a,t):case h&&e.test(Array.isArray(a)?a.join(","):a):case a===e:s.forEach((e=>{!1===i.has(e)&&this.data.has(e)&&i.set(e,this.get(e,r))}))}}))})),r?Array.from(i.values()):this.list(...Array.from(i.values()))}set(e=null,t={},s=!1,r=!1){null===e&&(e=t[this.key]??this.uuid());let i={...t,[this.key]:e};if(this.beforeSet(e,i,s,r),this.data.has(e)){const t=this.get(e,!0);this.delIndex(this.index,this.indexes,this.delimiter,e,t),this.versioning&&this.versions.get(e).add(Object.freeze(this.clone(t))),r||(i=this.merge(this.clone(t),i))}else this.versioning&&this.versions.set(e,new Set);this.data.set(e,i),this.setIndex(this.index,this.indexes,this.delimiter,e,i,null);const n=this.get(e);return this.onset(n,s),n}setIndex(e,t,s,r,i,n){this.each(null===n?e:[n],(e=>{let n=t.get(e);n||(n=new Map,t.set(e,n)),e.includes(s)?this.each(this.indexKeys(e,s,i),(e=>{n.has(e)||n.set(e,new Set),n.get(e).add(r)})):this.each(Array.isArray(i[e])?i[e]:[i[e]],(e=>{n.has(e)||n.set(e,new Set),n.get(e).add(r)}))}))}sort(e,t=!0){return t?Object.freeze(this.limit(0,this.data.size,!0).sort(e).map((e=>Object.freeze(e)))):this.limit(0,this.data.size,!0).sort(e)}sortBy(e="",s=!1){if(e===t)throw new Error("Invalid field");const r=[],i=[];!1===this.indexes.has(e)&&this.reindex(e);const n=this.indexes.get(e);return n.forEach(((e,t)=>i.push(t))),this.each(i.sort(),(e=>n.get(e).forEach((e=>r.push(this.get(e,s)))))),s?r:this.list(...r)}toArray(e=!0){const t=Array.from(this.data.values());return e&&(this.each(t,(e=>Object.freeze(e))),Object.freeze(t)),t}uuid(){return a()}values(){return this.data.values()}where(e={},t=!1,s="||"){const r=this.index.filter((t=>t in e));return 0===r.length?[]:this.filter((t=>{const i=r.map((r=>{const i=e[r],n=t[r];return Array.isArray(i)?Array.isArray(n)?"&&"===s?i.every((e=>n.includes(e))):i.some((e=>n.includes(e))):"&&"===s?i.every((e=>n===e)):i.some((e=>n===e)):i instanceof RegExp?Array.isArray(n)?"&&"===s?n.every((e=>i.test(e))):n.some((e=>i.test(e))):i.test(n):Array.isArray(n)?n.includes(i):n===i})),n=i.every(Boolean);return"Insectus"===e.company&&"occaecat"===e.tags&&console.log("DEBUG WHERE:",{a:t,matches:i,isMatch:n}),n}),t)}}e.Haro=o,e.haro=function(e=null,t={}){const s=new o(t);return Array.isArray(e)&&s.batch(e,"set"),s}}));//# sourceMappingURL=haro.umd.min.js.map
