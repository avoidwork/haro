/*!
 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
 @version 16.0.0
*/
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("crypto")):"function"==typeof define&&define.amd?define(["exports","crypto"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).lru={},e.crypto)}(this,function(e,t){"use strict";const s="",r="function",i="records",n="Invalid function";class h{constructor({delimiter:e="|",id:t=this.uuid(),immutable:s=!1,index:r=[],key:i="id",versioning:n=!1}={}){return this.data=new Map,this.delimiter=e,this.id=t,this.immutable=s,this.index=Array.isArray(r)?[...r]:[],this.indexes=new Map,this.key=i,this.versions=new Map,this.versioning=n,Object.defineProperty(this,"registry",{enumerable:!0,get:()=>Array.from(this.data.keys())}),Object.defineProperty(this,"size",{enumerable:!0,get:()=>this.data.size}),this.reindex()}batch(e,t="set"){const s="del"===t?e=>this.delete(e,!0):e=>this.set(null,e,!0,!0);return this.onbatch(this.beforeBatch(e,t).map(s),t)}beforeBatch(e,t=""){return e}beforeClear(){}beforeDelete(e="",t=!1){}beforeSet(e="",t={},s=!1,r=!1){}clear(){return this.beforeClear(),this.data.clear(),this.indexes.clear(),this.versions.clear(),this.reindex().onclear(),this}clone(e){return structuredClone(e)}delete(e="",t=!1){if(!this.data.has(e))throw new Error("Record not found");const s=this.get(e,!0);this.beforeDelete(e,t),this.deleteIndex(e,s),this.data.delete(e),this.ondelete(e,t),this.versioning&&this.versions.delete(e)}deleteIndex(e,t){return this.index.forEach(s=>{const r=this.indexes.get(s);if(!r)return;const i=s.includes(this.delimiter)?this.indexKeys(s,this.delimiter,t):Array.isArray(t[s])?t[s]:[t[s]];this.each(i,t=>{if(r.has(t)){const s=r.get(t);s.delete(e),0===s.size&&r.delete(t)}})}),this}dump(e=i){let t;return t=e===i?Array.from(this.entries()):Array.from(this.indexes).map(e=>(e[1]=Array.from(e[1]).map(e=>(e[1]=Array.from(e[1]),e)),e)),t}each(e=[],t){const s=e.length;for(let r=0;r<s;r++)t(e[r],r);return e}entries(){return this.data.entries()}find(e={},t=!1){const s=Object.keys(e).sort(this.sortKeys).join(this.delimiter),r=this.indexes.get(s)??new Map;let i=[];if(r.size>0){const n=this.indexKeys(s,this.delimiter,e);i=Array.from(n.reduce((e,t)=>(r.has(t)&&r.get(t).forEach(t=>e.add(t)),e),new Set)).map(e=>this.get(e,t))}return!t&&this.immutable&&(i=Object.freeze(i)),i}filter(e,t=!1){if(typeof e!==r)throw new Error(n);let s=this.reduce((t,s)=>(e(s)&&t.push(s),t),[]);return t||(s=s.map(e=>this.list(e)),this.immutable&&(s=Object.freeze(s))),s}forEach(e,t=this){return this.data.forEach((s,r)=>{this.immutable&&(s=this.clone(s)),e.call(t,s,r)},this),this}freeze(...e){return Object.freeze(e.map(e=>Object.freeze(e)))}get(e,t=!1){let s=this.data.get(e)??null;return null===s||t||(s=this.list(s),this.immutable&&(s=Object.freeze(s))),s}has(e){return this.data.has(e)}indexKeys(e="",t="|",s={}){const r=e.split(t).sort(this.sortKeys),i=r.length;let n=[""];for(let e=0;e<i;e++){const i=r[e],h=Array.isArray(s[i])?s[i]:[s[i]],a=[],o=n.length,l=h.length;for(let s=0;s<o;s++)for(let r=0;r<l;r++){const i=0===e?h[r]:`${n[s]}${t}${h[r]}`;a.push(i)}n=a}return n}keys(){return this.data.keys()}limit(e=0,t=0,s=!1){let r=this.registry.slice(e,e+t).map(e=>this.get(e,s));return!s&&this.immutable&&(r=Object.freeze(r)),r}list(e){const t=[e[this.key],e];return this.immutable?this.freeze(...t):t}map(e,t=!1){if(typeof e!==r)throw new Error(n);let s=[];return this.forEach((t,r)=>s.push(e(t,r))),t||(s=s.map(e=>this.list(e)),this.immutable&&(s=Object.freeze(s))),s}merge(e,t,s=!1){return Array.isArray(e)&&Array.isArray(t)?e=s?t:e.concat(t):"object"==typeof e&&null!==e&&"object"==typeof t&&null!==t?this.each(Object.keys(t),r=>{e[r]=this.merge(e[r],t[r],s)}):e=t,e}onbatch(e,t=""){return e}onclear(){}ondelete(e="",t=!1){}onoverride(e=""){}onset(e={},t=!1){}override(e,t=i){if("indexes"===t)this.indexes=new Map(e.map(e=>[e[0],new Map(e[1].map(e=>[e[0],new Set(e[1])]))]));else{if(t!==i)throw new Error("Invalid type");this.indexes.clear(),this.data=new Map(e)}return this.onoverride(t),!0}reduce(e,t=[]){let s=t;return this.forEach((t,r)=>{s=e(s,t,r,this)},this),s}reindex(e){const t=e?[e]:this.index;return e&&!1===this.index.includes(e)&&this.index.push(e),this.each(t,e=>this.indexes.set(e,new Map)),this.forEach((e,s)=>this.each(t,t=>this.setIndex(s,e,t))),this}search(e,t,s=!1){const i=new Set,n=typeof e===r,h=e&&typeof e.test===r;if(!e)return this.immutable?this.freeze():[];const a=t?Array.isArray(t)?t:[t]:this.index;for(const t of a){const s=this.indexes.get(t);if(s)for(const[r,a]of s){let s=!1;if(s=n?e(r,t):h?e.test(Array.isArray(r)?r.join(","):r):r===e,s)for(const e of a)this.data.has(e)&&i.add(e)}}let o=Array.from(i).map(e=>this.get(e,s));return!s&&this.immutable&&(o=Object.freeze(o)),o}set(e=null,t={},s=!1,r=!1){null===e&&(e=t[this.key]??this.uuid());let i={...t,[this.key]:e};if(this.beforeSet(e,i,s,r),this.data.has(e)){const t=this.get(e,!0);this.deleteIndex(e,t),this.versioning&&this.versions.get(e).add(Object.freeze(this.clone(t))),r||(i=this.merge(this.clone(t),i))}else this.versioning&&this.versions.set(e,new Set);this.data.set(e,i),this.setIndex(e,i,null);const n=this.get(e);return this.onset(n,s),n}setIndex(e,t,s){return this.each(null===s?this.index:[s],s=>{let r=this.indexes.get(s);r||(r=new Map,this.indexes.set(s,r));const i=t=>{r.has(t)||r.set(t,new Set),r.get(t).add(e)};s.includes(this.delimiter)?this.each(this.indexKeys(s,this.delimiter,t),i):this.each(Array.isArray(t[s])?t[s]:[t[s]],i)}),this}sort(e,t=!1){const s=this.data.size;let r=this.limit(0,s,!0).sort(e);return t&&(r=this.freeze(...r)),r}sortKeys(e,t){return"string"==typeof e&&"string"==typeof t?e.localeCompare(t):"number"==typeof e&&"number"==typeof t?e-t:String(e).localeCompare(String(t))}sortBy(e="",t=!1){if(e===s)throw new Error("Invalid field");let r=[];const i=[];!1===this.indexes.has(e)&&this.reindex(e);const n=this.indexes.get(e);return n.forEach((e,t)=>i.push(t)),this.each(i.sort(this.sortKeys),e=>n.get(e).forEach(e=>r.push(this.get(e,t)))),this.immutable&&(r=Object.freeze(r)),r}toArray(){const e=Array.from(this.data.values());return this.immutable&&(this.each(e,e=>Object.freeze(e)),Object.freeze(e)),e}uuid(){return t.randomUUID()}values(){return this.data.values()}matchesPredicate(e,t,s){return Object.keys(t).every(r=>{const i=t[r],n=e[r];return Array.isArray(i)?Array.isArray(n)?"&&"===s?i.every(e=>n.includes(e)):i.some(e=>n.includes(e)):"&&"===s?i.every(e=>n===e):i.some(e=>n===e):i instanceof RegExp?Array.isArray(n)?"&&"===s?n.every(e=>i.test(e)):n.some(e=>i.test(e)):i.test(n):Array.isArray(n)?n.includes(i):n===i})}where(e={},t="||"){const s=this.index.filter(t=>t in e);if(0===s.length)return[];const r=s.filter(e=>this.indexes.has(e));if(r.length>0){let s=new Set,i=!0;for(const t of r){const r=e[t],n=this.indexes.get(t),h=new Set;if(Array.isArray(r)){for(const e of r)if(n.has(e))for(const t of n.get(e))h.add(t)}else if(n.has(r))for(const e of n.get(r))h.add(e);i?(s=h,i=!1):s=new Set([...s].filter(e=>h.has(e)))}const n=[];for(const r of s){const s=this.get(r,!0);this.matchesPredicate(s,e,t)&&n.push(this.immutable?this.get(r):s)}return this.immutable?this.freeze(...n):n}return this.filter(s=>this.matchesPredicate(s,e,t))}}e.Haro=h,e.haro=function(e=null,t={}){const s=new h(t);return Array.isArray(e)&&s.batch(e,"set"),s}});//# sourceMappingURL=haro.umd.min.js.map
