/*!
 2024 Jason Mulligan <jason.mulligan@avoidwork.com>
 @version 15.0.0
*/
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).lru={})}(this,(function(e){"use strict";const t="",r="|",s="function",i="records",n=0,a=1,h=16,o=[8,9,"a","b"];const c=structuredClone??function(e){return JSON.parse(JSON.stringify(e,null,n))};function d(e=[],t){for(const[r,s]of e.entries())t(s,r);return e}function l(e=t,s=r,i={}){return e.split(s).reduce(((e,t,r)=>{const a=[];return(Array.isArray(i[t])?i[t]:[i[t]]).forEach((t=>r===n?a.push(t):e.forEach((e=>a.push(`${e}${s}${t}`))))),a}),[])}function f(e,t,r,s,i){e.forEach((e=>{const a=t.get(e);d(e.includes(r)?l(e,r,i):Array.isArray(i[e])?i[e]:[i[e]],(e=>{if(a.has(e)){const t=a.get(e);t.delete(s),t.size===n&&a.delete(e)}}))}))}function u(e,t){return e instanceof Object&&t instanceof Object?d(Object.keys(t),(r=>{e[r]instanceof Object&&t[r]instanceof Object?e[r]=u(e[r],t[r]):Array.isArray(e[r])&&Array.isArray(t[r])?e[r]=e[r].concat(t[r]):e[r]=t[r]})):e=Array.isArray(e)&&Array.isArray(t)?e.concat(t):t,e}function y(){return(65536*(Math.random()+a)|n).toString(h).substring(a)}function p(e,t,r,s,i,n){d(null===n?e:[n],(e=>{const n=t.get(e);e.includes(r)?d(l(e,r,i),(e=>{!1===n.has(e)&&n.set(e,new Set),n.get(e).add(s)})):d(Array.isArray(i[e])?i[e]:[i[e]],(e=>{!1===n.has(e)&&n.set(e,new Set),n.get(e).add(s)}))}))}const m="object"==typeof crypto?crypto.randomUUID.bind(crypto):function(){return`${y()}${y()}-${y()}-4${y().slice(n,3)}-${o[Math.floor(4*Math.random())]}${y().slice(n,3)}-${y()}${y()}${y()}`};class g{constructor({delimiter:e=r,id:s=m(),index:i=[],key:n=t,versioning:a=!1}={}){return this.data=new Map,this.delimiter=e,this.id=s,this.index=i,this.indexes=new Map,this.key=n,this.versions=new Map,this.versioning=a,Object.defineProperty(this,"registry",{enumerable:!0,get:()=>Array.from(this.data.keys())}),Object.defineProperty(this,"size",{enumerable:!0,get:()=>this.data.size}),this.reindex()}batch(e,t="set"){const r="del"===t?e=>this.del(e,!0):e=>this.set(null,e,!0,!0);return this.onbatch(this.beforeBatch(e,t).map(r),t)}beforeBatch(e){return e}beforeClear(){}beforeDelete(){}beforeSet(){}clear(){return this.beforeClear(),this.data.clear(),this.indexes.clear(),this.versions.clear(),this.reindex().onclear(),this}del(e,t=!1){if(!1===this.has(e))throw new Error("Record not found");const r=this.get(e,!0);this.beforeDelete(e,t),f(this.index,this.indexes,this.delimiter,e,r),this.data.delete(e),this.ondelete(e,t),this.versioning&&this.versions.delete(e)}dump(e=i){let t;return t=e===i?Array.from(this.entries()):Array.from(this.indexes).map((e=>(e[1]=Array.from(e[1]).map((e=>(e[1]=Array.from(e[1]),e))),e))),t}entries(){return this.data.entries()}find(e={},t=!1){const r=Object.keys(e).sort(((e,t)=>e.localeCompare(t))).join(this.delimiter),s=this.indexes.get(r)||new Map;let i=[];if(s.size>0){const n=l(r,this.delimiter,e);i=Array.from(n.reduce(((e,t)=>(s.has(t)&&s.get(t).forEach((t=>e.add(t))),e)),new Set)).map((e=>this.get(e,t)))}return t?i:this.list(...i)}filter(e=(()=>{}),t=!1){const r=t?(e,t)=>t:(e,t)=>Object.freeze([e,Object.freeze(t)]),s=this.reduce(((t,s,i,n)=>(e.call(n,s)&&t.push(r(i,s)),t)),[]);return t?s:Object.freeze(s)}forEach(e,t){return this.data.forEach(((t,r)=>e(c(t),c(r))),t||this.data),this}get(e,t=!1){const r=c(this.data.get(e)||null);return t?r:this.list(e,r)}has(e){return this.data.has(e)}keys(){return this.data.keys()}limit(e=n,t=n,r=!1){const s=this.registry.slice(e,e+t).map((e=>this.get(e,r)));return r?s:this.list(...s)}list(...e){return Object.freeze(e.map((e=>Object.freeze(e))))}map(e,t=!1){const r=[];return this.forEach(((t,s)=>r.push(e(t,s)))),t?r:this.list(...r)}onbatch(e){return e}onclear(){}ondelete(){}onoverride(){}onset(){}override(e,t=i){if("indexes"===t)this.indexes=new Map(e.map((e=>[e[0],new Map(e[1].map((e=>[e[0],new Set(e[1])])))])));else{if(t!==i)throw new Error("Invalid type");this.indexes.clear(),this.data=new Map(e)}return this.onoverride(t),!0}reduce(e,t,r=!1){let s=t||this.data.keys().next().value;return this.forEach(((t,i)=>{s=e(s,t,i,this,r)}),this),s}reindex(e){const t=e?[e]:this.index;return e&&!1===this.index.includes(e)&&this.index.push(e),d(t,(e=>this.indexes.set(e,new Map))),this.forEach(((e,r)=>d(t,(t=>p(this.index,this.indexes,this.delimiter,r,e,t))))),this}search(e,t,r=!1){const i=new Map,n=typeof e===s,a=e&&typeof e.test===s;return e&&d(t?Array.isArray(t)?t:[t]:this.index,(t=>{let s=this.indexes.get(t);s&&s.forEach(((s,h)=>{switch(!0){case n&&e(h,t):case a&&e.test(Array.isArray(h)?h.join(","):h):case h===e:s.forEach((e=>{!1===i.has(e)&&this.has(e)&&i.set(e,this.get(e,r))}))}}))})),r?Array.from(i.values()):this.list(...Array.from(i.values()))}set(e=null,t={},r=!1,s=!1){let i,n,a=c(t);return null===e&&(this.key in a?e=a[this.key]:a[this.key]=e=m()),this.beforeSet(e,t,r,s),!1===this.has(e)?this.versioning&&this.versions.set(e,new Set):(i=this.get(e,!0),f(this.index,this.indexes,this.delimiter,e,i),this.versioning&&this.versions.get(e).add(Object.freeze(c(i))),!1===s&&(a=u(c(i),a))),this.data.set(e,a),p(this.index,this.indexes,this.delimiter,e,a,null),n=this.get(e),this.onset(n,r),n}sort(e,t=!0){return t?Object.freeze(this.limit(n,this.data.size,!0).sort(e).map((e=>Object.freeze(e)))):this.limit(n,this.data.size,!0).sort(e)}sortBy(e=t,r=!1){if(e===t)throw new Error("Invalid field");const s=[],i=[];!1===this.indexes.has(e)&&this.reindex(e);const n=this.indexes.get(e);return n.forEach(((e,t)=>i.push(t))),d(i.sort(),(e=>n.get(e).forEach((e=>s.push(this.get(e,r)))))),r?s:this.list(...s)}toArray(e=!0){const t=Array.from(this.data.values());return e&&(d(t,(e=>Object.freeze(e))),Object.freeze(t)),t}values(){return this.data.values()}where(e={},t=!1,r="||"){const s=this.index.filter((t=>t in e));return s.length>n?this.filter(new Function("a",`return (${s.map((t=>{let s;if(Array.isArray(e[t]))s=`Array.isArray(a['${t}']) ? ${e[t].map((e=>`a['${t}'].includes(${"string"==typeof e?`'${e}'`:e})`)).join(` ${r} `)} : (${e[t].map((e=>`a['${t}'] === ${"string"==typeof e?`'${e}'`:e}`)).join(` ${r} `)})`;else if(e[t]instanceof RegExp)s=`Array.isArray(a['${t}']) ? a['${t}'].filter(i => ${e[t]}.test(a['${t}'])).length > 0 : ${e[t]}.test(a['${t}'])`;else{const r="string"==typeof e[t]?`'${e[t]}'`:e[t];s=`Array.isArray(a['${t}']) ? a['${t}'].includes(${r}) : a['${t}'] === ${r}`}return s})).join(") && (")});`),t):[]}}e.Haro=g,e.haro=function(e=null,t={}){const r=new g(t);return Array.isArray(e)&&r.batch(e,"set"),r}}));//# sourceMappingURL=haro.umd.min.js.map
