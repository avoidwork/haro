/*!
 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
 @version 16.0.0
*/
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("crypto")):"function"==typeof define&&define.amd?define(["exports","crypto"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).lru={},e.crypto)}(this,function(e,t){"use strict";const s="",i="function",r="records",n="Invalid function";class h{constructor({delimiter:e="|",id:t=this.uuid(),index:s=[],key:i="id",versioning:r=!1,immutable:n=!1}={}){return this.data=new Map,this.delimiter=e,this.id=t,this.index=Array.isArray(s)?[...s]:[],this.indexes=new Map,this.immutable=n,this.key=i,this.versions=new Map,this.versioning=r,Object.defineProperty(this,"registry",{enumerable:!0,get:()=>Array.from(this.data.keys())}),Object.defineProperty(this,"size",{enumerable:!0,get:()=>this.data.size}),this.reindex()}batch(e,t="set"){const s="del"===t?e=>this.del(e,!0):e=>this.set(null,e,!0,!0);return this.onbatch(this.beforeBatch(e,t).map(s),t)}beforeBatch(e,t=""){return e}beforeClear(){}beforeDelete(e="",t=!1){return[e,t]}beforeSet(e="",t,s=!1,i=!1){return[e,s]}clear(){return this.beforeClear(),this.data.clear(),this.indexes.clear(),this.versions.clear(),this.reindex().onclear(),this}clone(e){return structuredClone(e)}del(e="",t=!1){if(!this.data.has(e))throw new Error("Record not found");const s=this.get(e,!0);this.beforeDelete(e,t),this.delIndex(this.index,this.indexes,this.delimiter,e,s),this.data.delete(e),this.ondelete(e,t),this.versioning&&this.versions.delete(e)}delIndex(e,t,s,i,r){e.forEach(e=>{const n=t.get(e);if(!n)return;const h=e.includes(s)?this.indexKeys(e,s,r):Array.isArray(r[e])?r[e]:[r[e]];this.each(h,e=>{if(n.has(e)){const t=n.get(e);t.delete(i),0===t.size&&n.delete(e)}})})}dump(e=r){let t;return t=e===r?Array.from(this.entries()):Array.from(this.indexes).map(e=>(e[1]=Array.from(e[1]).map(e=>(e[1]=Array.from(e[1]),e)),e)),t}each(e=[],t){const s=e.length;for(let i=0;i<s;i++)t(e[i],i);return e}entries(){return this.data.entries()}find(e={}){const t=Object.keys(e).sort((e,t)=>e.localeCompare(t)).join(this.delimiter),s=this.indexes.get(t)??new Map;let i=[];if(s.size>0){const r=this.indexKeys(t,this.delimiter,e);i=Array.from(r.reduce((e,t)=>(s.has(t)&&s.get(t).forEach(t=>e.add(t)),e),new Set)).map(e=>this.get(e))}return this.immutable?this.freeze(...i):i}filter(e){if(typeof e!==i)throw new Error(n);const t=this.immutable?(e,t)=>Object.freeze([e,Object.freeze(t)]):(e,t)=>t,s=this.reduce((s,i,r,n)=>(e.call(n,i)&&s.push(t(r,i)),s),[]);return this.immutable?Object.freeze(s):s}forEach(e,t){return this.data.forEach((t,s)=>{e(this.clone(t),s)},t??this.data),this}freeze(...e){return Object.freeze(e.map(e=>Object.freeze(e)))}get(e,t=!1){let s=this.data.get(e)??null;return null===s||t?s:(this.immutable&&(s=this.clone(s)),this.immutable?this.freeze(e,s):s)}has(e){return this.data.has(e)}indexKeys(e="",t="|",s={}){const i=e.split(t),r=i.length;let n=[""];for(let e=0;e<r;e++){const r=i[e],h=Array.isArray(s[r])?s[r]:[s[r]],a=[],o=n.length,d=h.length;for(let s=0;s<o;s++)for(let i=0;i<d;i++){const r=0===e?h[i]:`${n[s]}${t}${h[i]}`;a.push(r)}n=a}return n}keys(){return this.data.keys()}limit(e=0,t=0){const s=this.registry.slice(e,e+t).map(e=>this.get(e));return this.immutable?this.freeze(...s):s}map(e){if(typeof e!==i)throw new Error(n);const t=[];return this.forEach((s,i)=>t.push(e(s,i))),this.immutable?this.freeze(...t):t}merge(e,t,s=!1){return Array.isArray(e)&&Array.isArray(t)?e=s?t:e.concat(t):"object"==typeof e&&null!==e&&"object"==typeof t&&null!==t?this.each(Object.keys(t),i=>{e[i]=this.merge(e[i],t[i],s)}):e=t,e}onbatch(e,t=""){return e}onclear(){}ondelete(e="",t=!1){return[e,t]}onoverride(e=""){return e}onset(e={},t=!1){return[e,t]}override(e,t=r){if("indexes"===t)this.indexes=new Map(e.map(e=>[e[0],new Map(e[1].map(e=>[e[0],new Set(e[1])]))]));else{if(t!==r)throw new Error("Invalid type");this.indexes.clear(),this.data=new Map(e)}return this.onoverride(t),!0}reduce(e,t){let s=t??this.data.keys().next().value;return this.forEach((t,i)=>{s=e(s,t,i,this)},this),s}reindex(e){const t=e?[e]:this.index;return e&&!1===this.index.includes(e)&&this.index.push(e),this.each(t,e=>this.indexes.set(e,new Map)),this.forEach((e,s)=>this.each(t,t=>this.setIndex(this.index,this.indexes,this.delimiter,s,e,t))),this}search(e,t){const s=new Set,r=typeof e===i,n=e&&typeof e.test===i;if(!e)return this.immutable?this.freeze():[];const h=t?Array.isArray(t)?t:[t]:this.index;for(const t of h){const i=this.indexes.get(t);if(i)for(const[h,a]of i){let i=!1;if(i=r?e(h,t):n?e.test(Array.isArray(h)?h.join(","):h):h===e,i)for(const e of a)this.data.has(e)&&s.add(e)}}const a=Array.from(s).map(e=>this.get(e));return this.immutable?this.freeze(...a):a}set(e=null,t={},s=!1,i=!1){null===e&&(e=t[this.key]??this.uuid());let r={...t,[this.key]:e};if(this.beforeSet(e,r,s,i),this.data.has(e)){const t=this.get(e,!0);this.delIndex(this.index,this.indexes,this.delimiter,e,t),this.versioning&&this.versions.get(e).add(Object.freeze(this.clone(t))),i||(r=this.merge(this.clone(t),r))}else this.versioning&&this.versions.set(e,new Set);this.data.set(e,r),this.setIndex(this.index,this.indexes,this.delimiter,e,r,null);const n=this.get(e);return this.onset(n,s),n}setIndex(e,t,s,i,r,n){this.each(null===n?e:[n],e=>{let n=t.get(e);n||(n=new Map,t.set(e,n)),e.includes(s)?this.each(this.indexKeys(e,s,r),e=>{n.has(e)||n.set(e,new Set),n.get(e).add(i)}):this.each(Array.isArray(r[e])?r[e]:[r[e]],e=>{n.has(e)||n.set(e,new Set),n.get(e).add(i)})})}sort(e,t=!1){const s=this.data.size;return t?Object.freeze(this.limit(0,s,!0).sort(e).map(e=>Object.freeze(e))):this.limit(0,s,!0).sort(e)}sortBy(e=""){if(e===s)throw new Error("Invalid field");const t=[],i=[];!1===this.indexes.has(e)&&this.reindex(e);const r=this.indexes.get(e);return r.forEach((e,t)=>i.push(t)),this.each(i.sort(),e=>r.get(e).forEach(e=>t.push(this.get(e)))),this.immutable?this.freeze(...t):t}toArray(){const e=Array.from(this.data.values());return this.immutable&&(this.each(e,e=>Object.freeze(e)),Object.freeze(e)),e}uuid(){return t.randomUUID()}values(){return this.data.values()}matchesPredicate(e,t,s){return Object.keys(t).every(i=>{const r=t[i],n=e[i];return Array.isArray(r)?Array.isArray(n)?"&&"===s?r.every(e=>n.includes(e)):r.some(e=>n.includes(e)):"&&"===s?r.every(e=>n===e):r.some(e=>n===e):r instanceof RegExp?Array.isArray(n)?"&&"===s?n.every(e=>r.test(e)):n.some(e=>r.test(e)):r.test(n):Array.isArray(n)?n.includes(r):n===r})}where(e={},t="||"){const s=this.index.filter(t=>t in e);if(0===s.length)return[];const i=s.filter(e=>this.indexes.has(e));if(i.length>0){let s=new Set,r=!0;for(const t of i){const i=e[t],n=this.indexes.get(t),h=new Set;if(Array.isArray(i)){for(const e of i)if(n.has(e))for(const t of n.get(e))h.add(t)}else if(n.has(i))for(const e of n.get(i))h.add(e);r?(s=h,r=!1):s=new Set([...s].filter(e=>h.has(e)))}const n=[];for(const i of s){const s=this.get(i,!0);this.matchesPredicate(s,e,t)&&n.push(this.immutable?this.get(i):s)}return this.immutable?this.freeze(...n):n}return this.filter(s=>this.matchesPredicate(s,e,t))}}e.Haro=h,e.haro=function(e=null,t={}){const s=new h(t);return Array.isArray(e)&&s.batch(e,"set"),s}});//# sourceMappingURL=haro.umd.min.js.map
