/*!
 2024 Jason Mulligan <jason.mulligan@avoidwork.com>
 @version 15.0.2
*/
const e="function",t="records",s=0,i=1,r=16,n=[8,9,"a","b"];function a(){return(65536*(Math.random()+i)|s).toString(r).substring(i)}const h="object"==typeof crypto?crypto.randomUUID.bind(crypto):function(){return`${a()}${a()}-${a()}-4${a().slice(s,3)}-${n[Math.floor(4*Math.random())]}${a().slice(s,3)}-${a()}${a()}${a()}`};class o{constructor({delimiter:e="|",id:t=h(),index:s=[],key:i="",versioning:r=!1}={}){return this.data=new Map,this.delimiter=e,this.id=t,this.index=s,this.indexes=new Map,this.key=i,this.versions=new Map,this.versioning=r,Object.defineProperty(this,"registry",{enumerable:!0,get:()=>Array.from(this.data.keys())}),Object.defineProperty(this,"size",{enumerable:!0,get:()=>this.data.size}),this.reindex()}batch(e,t="set"){const s="del"===t?e=>this.del(e,!0):e=>this.set(null,e,!0,!0);return this.onbatch(this.beforeBatch(e,t).map(s),t)}beforeBatch(e){return e}beforeClear(){}beforeDelete(){}beforeSet(){}clear(){return this.beforeClear(),this.data.clear(),this.indexes.clear(),this.versions.clear(),this.reindex().onclear(),this}clone(e){return JSON.parse(JSON.stringify(e,null,s))}del(e,t=!1){if(!1===this.has(e))throw new Error("Record not found");const s=this.get(e,!0);this.beforeDelete(e,t),this.delIndex(this.index,this.indexes,this.delimiter,e,s),this.data.delete(e),this.ondelete(e,t),this.versioning&&this.versions.delete(e)}delIndex(e,t,i,r,n){e.forEach((e=>{const a=t.get(e);this.each(e.includes(i)?this.indexKeys(e,i,n):Array.isArray(n[e])?n[e]:[n[e]],(e=>{if(a.has(e)){const t=a.get(e);t.delete(r),t.size===s&&a.delete(e)}}))}))}dump(e=t){let s;return s=e===t?Array.from(this.entries()):Array.from(this.indexes).map((e=>(e[1]=Array.from(e[1]).map((e=>(e[1]=Array.from(e[1]),e))),e))),s}each(e=[],t){for(const[s,i]of e.entries())t(i,s);return e}entries(){return this.data.entries()}find(e={},t=!1){const s=Object.keys(e).sort(((e,t)=>e.localeCompare(t))).join(this.delimiter),i=this.indexes.get(s)??new Map;let r=[];if(i.size>0){const n=this.indexKeys(s,this.delimiter,e);r=Array.from(n.reduce(((e,t)=>(i.has(t)&&i.get(t).forEach((t=>e.add(t))),e)),new Set)).map((e=>this.get(e,t)))}return t?r:this.list(...r)}filter(e=(()=>{}),t=!1){const s=t?(e,t)=>t:(e,t)=>Object.freeze([e,Object.freeze(t)]),i=this.reduce(((t,i,r,n)=>(e.call(n,i)&&t.push(s(r,i)),t)),[]);return t?i:Object.freeze(i)}forEach(e,t){return this.data.forEach(((t,s)=>e(this.clone(t),this.clone(s))),t??this.data),this}get(e,t=!1){const s=this.clone(this.data.get(e)??null);return t?s:this.list(e,s)}has(e){return this.data.has(e)}indexKeys(e="",t="|",i={}){return e.split(t).reduce(((e,r,n)=>{const a=[];return(Array.isArray(i[r])?i[r]:[i[r]]).forEach((i=>n===s?a.push(i):e.forEach((e=>a.push(`${e}${t}${i}`))))),a}),[])}keys(){return this.data.keys()}limit(e=s,t=s,i=!1){const r=this.registry.slice(e,e+t).map((e=>this.get(e,i)));return i?r:this.list(...r)}list(...e){return Object.freeze(e.map((e=>Object.freeze(e))))}map(e,t=!1){const s=[];return this.forEach(((t,i)=>s.push(e(t,i)))),t?s:this.list(...s)}merge(e={},t={},s=!1){return e instanceof Object&&t instanceof Object?this.each(Object.keys(t),(i=>{e[i]instanceof Object&&t[i]instanceof Object?e[i]=this.merge(e[i],t[i]):Array.isArray(e[i])&&Array.isArray(t[i])?e[i]=s?t[i]:e[i].concat(t[i]):e[i]=t[i]})):e=Array.isArray(e)&&Array.isArray(t)?s?t:e.concat(t):t,e}onbatch(e){return e}onclear(){}ondelete(){}onoverride(){}onset(){}override(e,s=t){if("indexes"===s)this.indexes=new Map(e.map((e=>[e[0],new Map(e[1].map((e=>[e[0],new Set(e[1])])))])));else{if(s!==t)throw new Error("Invalid type");this.indexes.clear(),this.data=new Map(e)}return this.onoverride(s),!0}reduce(e,t,s=!1){let i=t??this.data.keys().next().value;return this.forEach(((t,r)=>{i=e(i,t,r,this,s)}),this),i}reindex(e){const t=e?[e]:this.index;return e&&!1===this.index.includes(e)&&this.index.push(e),this.each(t,(e=>this.indexes.set(e,new Map))),this.forEach(((e,s)=>this.each(t,(t=>this.setIndex(this.index,this.indexes,this.delimiter,s,e,t))))),this}search(t,s,i=!1){const r=new Map,n=typeof t===e,a=t&&typeof t.test===e;return t&&this.each(s?Array.isArray(s)?s:[s]:this.index,(e=>{let s=this.indexes.get(e);s&&s.forEach(((s,h)=>{switch(!0){case n&&t(h,e):case a&&t.test(Array.isArray(h)?h.join(","):h):case h===t:s.forEach((e=>{!1===r.has(e)&&this.has(e)&&r.set(e,this.get(e,i))}))}}))})),i?Array.from(r.values()):this.list(...Array.from(r.values()))}set(e=null,t={},s=!1,i=!1){null===e&&(e=t[this.key]??h());let r={...t,[this.key]:e};if(this.beforeSet(e,r,s,i),!1===this.has(e))this.versioning&&this.versions.set(e,new Set);else{let t=this.get(e,!0);this.delIndex(this.index,this.indexes,this.delimiter,e,t),this.versioning&&this.versions.get(e).add(Object.freeze(this.clone(t))),!1===i&&(r=this.merge(this.clone(t),r))}this.data.set(e,r),this.setIndex(this.index,this.indexes,this.delimiter,e,r,null);let n=this.get(e);return this.onset(n,s),n}setIndex(e,t,s,i,r,n){this.each(null===n?e:[n],(e=>{const n=t.get(e);e.includes(s)?this.each(this.indexKeys(e,s,r),(e=>{!1===n.has(e)&&n.set(e,new Set),n.get(e).add(i)})):this.each(Array.isArray(r[e])?r[e]:[r[e]],(e=>{!1===n.has(e)&&n.set(e,new Set),n.get(e).add(i)}))}))}sort(e,t=!0){return t?Object.freeze(this.limit(s,this.data.size,!0).sort(e).map((e=>Object.freeze(e)))):this.limit(s,this.data.size,!0).sort(e)}sortBy(e="",t=!1){if(""===e)throw new Error("Invalid field");const s=[],i=[];!1===this.indexes.has(e)&&this.reindex(e);const r=this.indexes.get(e);return r.forEach(((e,t)=>i.push(t))),this.each(i.sort(),(e=>r.get(e).forEach((e=>s.push(this.get(e,t)))))),t?s:this.list(...s)}toArray(e=!0){const t=Array.from(this.data.values());return e&&(this.each(t,(e=>Object.freeze(e))),Object.freeze(t)),t}values(){return this.data.values()}where(e={},t=!1,i="||"){const r=this.index.filter((t=>t in e));return r.length>s?this.filter(new Function("a",`return (${r.map((t=>{let s;if(Array.isArray(e[t]))s=`Array.isArray(a['${t}']) ? ${e[t].map((e=>`a['${t}'].includes(${"string"==typeof e?`'${e}'`:e})`)).join(` ${i} `)} : (${e[t].map((e=>`a['${t}'] === ${"string"==typeof e?`'${e}'`:e}`)).join(` ${i} `)})`;else if(e[t]instanceof RegExp)s=`Array.isArray(a['${t}']) ? a['${t}'].filter(i => ${e[t]}.test(a['${t}'])).length > 0 : ${e[t]}.test(a['${t}'])`;else{const i="string"==typeof e[t]?`'${e[t]}'`:e[t];s=`Array.isArray(a['${t}']) ? a['${t}'].includes(${i}) : a['${t}'] === ${i}`}return s})).join(") && (")});`),t):[]}}function c(e=null,t={}){const s=new o(t);return Array.isArray(e)&&s.batch(e,"set"),s}export{o as Haro,c as haro};//# sourceMappingURL=haro.min.js.map
