/*!
 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
 @version 16.0.0
*/
import{randomUUID as e}from"crypto";const t="",s="function",r="records",i="Invalid function";class n{constructor({delimiter:e="|",id:t=this.uuid(),index:s=[],key:r="id",versioning:i=!1,immutable:n=!1}={}){return this.data=new Map,this.delimiter=e,this.id=t,this.index=Array.isArray(s)?[...s]:[],this.indexes=new Map,this.immutable=n,this.key=r,this.versions=new Map,this.versioning=i,Object.defineProperty(this,"registry",{enumerable:!0,get:()=>Array.from(this.data.keys())}),Object.defineProperty(this,"size",{enumerable:!0,get:()=>this.data.size}),this.reindex()}batch(e,t="set"){const s="del"===t?e=>this.del(e,!0):e=>this.set(null,e,!0,!0);return this.onbatch(this.beforeBatch(e,t).map(s),t)}beforeBatch(e,t=""){return e}beforeClear(){}beforeDelete(e="",t=!1){return[e,t]}beforeSet(e="",t,s=!1,r=!1){return[e,s]}clear(){return this.beforeClear(),this.data.clear(),this.indexes.clear(),this.versions.clear(),this.reindex().onclear(),this}clone(e){return structuredClone(e)}del(e="",t=!1){if(!this.data.has(e))throw new Error("Record not found");const s=this.get(e,!0);this.beforeDelete(e,t),this.delIndex(this.index,this.indexes,this.delimiter,e,s),this.data.delete(e),this.ondelete(e,t),this.versioning&&this.versions.delete(e)}delIndex(e,t,s,r,i){e.forEach(e=>{const n=t.get(e);if(!n)return;const h=e.includes(s)?this.indexKeys(e,s,i):Array.isArray(i[e])?i[e]:[i[e]];this.each(h,e=>{if(n.has(e)){const t=n.get(e);t.delete(r),0===t.size&&n.delete(e)}})})}dump(e=r){let t;return t=e===r?Array.from(this.entries()):Array.from(this.indexes).map(e=>(e[1]=Array.from(e[1]).map(e=>(e[1]=Array.from(e[1]),e)),e)),t}each(e=[],t){const s=e.length;for(let r=0;r<s;r++)t(e[r],r);return e}entries(){return this.data.entries()}find(e={}){const t=Object.keys(e).sort((e,t)=>e.localeCompare(t)).join(this.delimiter),s=this.indexes.get(t)??new Map;let r=[];if(s.size>0){const i=this.indexKeys(t,this.delimiter,e);r=Array.from(i.reduce((e,t)=>(s.has(t)&&s.get(t).forEach(t=>e.add(t)),e),new Set)).map(e=>this.get(e))}return this.immutable?this.freeze(...r):r}filter(e){if(typeof e!==s)throw new Error(i);const t=this.immutable?(e,t)=>Object.freeze([e,Object.freeze(t)]):(e,t)=>t,r=this.reduce((s,r,i,n)=>(e.call(n,r)&&s.push(t(i,r)),s),[]);return this.immutable?Object.freeze(r):r}forEach(e,t){return this.data.forEach((t,s)=>{e(this.clone(t),s)},t??this.data),this}freeze(...e){return Object.freeze(e.map(e=>Object.freeze(e)))}get(e,t=!1){let s=this.data.get(e)??null;return null===s||t?s:(this.immutable&&(s=this.clone(s)),this.immutable?this.freeze(e,s):s)}has(e){return this.data.has(e)}indexKeys(e="",t="|",s={}){const r=e.split(t),i=r.length;let n=[""];for(let e=0;e<i;e++){const i=r[e],h=Array.isArray(s[i])?s[i]:[s[i]],a=[],o=n.length,d=h.length;for(let s=0;s<o;s++)for(let r=0;r<d;r++){const i=0===e?h[r]:`${n[s]}${t}${h[r]}`;a.push(i)}n=a}return n}keys(){return this.data.keys()}limit(e=0,t=0){const s=this.registry.slice(e,e+t).map(e=>this.get(e));return this.immutable?this.freeze(...s):s}map(e){if(typeof e!==s)throw new Error(i);const t=[];return this.forEach((s,r)=>t.push(e(s,r))),this.immutable?this.freeze(...t):t}merge(e,t,s=!1){return Array.isArray(e)&&Array.isArray(t)?e=s?t:e.concat(t):"object"==typeof e&&null!==e&&"object"==typeof t&&null!==t?this.each(Object.keys(t),r=>{e[r]=this.merge(e[r],t[r],s)}):e=t,e}onbatch(e,t=""){return e}onclear(){}ondelete(e="",t=!1){return[e,t]}onoverride(e=""){return e}onset(e={},t=!1){return[e,t]}override(e,t=r){if("indexes"===t)this.indexes=new Map(e.map(e=>[e[0],new Map(e[1].map(e=>[e[0],new Set(e[1])]))]));else{if(t!==r)throw new Error("Invalid type");this.indexes.clear(),this.data=new Map(e)}return this.onoverride(t),!0}reduce(e,t){let s=t??this.data.keys().next().value;return this.forEach((t,r)=>{s=e(s,t,r,this)},this),s}reindex(e){const t=e?[e]:this.index;return e&&!1===this.index.includes(e)&&this.index.push(e),this.each(t,e=>this.indexes.set(e,new Map)),this.forEach((e,s)=>this.each(t,t=>this.setIndex(this.index,this.indexes,this.delimiter,s,e,t))),this}search(e,t){const r=new Set,i=typeof e===s,n=e&&typeof e.test===s;if(!e)return this.immutable?this.freeze():[];const h=t?Array.isArray(t)?t:[t]:this.index;for(const t of h){const s=this.indexes.get(t);if(s)for(const[h,a]of s){let s=!1;if(s=i?e(h,t):n?e.test(Array.isArray(h)?h.join(","):h):h===e,s)for(const e of a)this.data.has(e)&&r.add(e)}}const a=Array.from(r).map(e=>this.get(e));return this.immutable?this.freeze(...a):a}set(e=null,t={},s=!1,r=!1){null===e&&(e=t[this.key]??this.uuid());let i={...t,[this.key]:e};if(this.beforeSet(e,i,s,r),this.data.has(e)){const t=this.get(e,!0);this.delIndex(this.index,this.indexes,this.delimiter,e,t),this.versioning&&this.versions.get(e).add(Object.freeze(this.clone(t))),r||(i=this.merge(this.clone(t),i))}else this.versioning&&this.versions.set(e,new Set);this.data.set(e,i),this.setIndex(this.index,this.indexes,this.delimiter,e,i,null);const n=this.get(e);return this.onset(n,s),n}setIndex(e,t,s,r,i,n){this.each(null===n?e:[n],e=>{let n=t.get(e);n||(n=new Map,t.set(e,n)),e.includes(s)?this.each(this.indexKeys(e,s,i),e=>{n.has(e)||n.set(e,new Set),n.get(e).add(r)}):this.each(Array.isArray(i[e])?i[e]:[i[e]],e=>{n.has(e)||n.set(e,new Set),n.get(e).add(r)})})}sort(e,t=!1){const s=this.data.size;return t?Object.freeze(this.limit(0,s,!0).sort(e).map(e=>Object.freeze(e))):this.limit(0,s,!0).sort(e)}sortBy(e=""){if(e===t)throw new Error("Invalid field");const s=[],r=[];!1===this.indexes.has(e)&&this.reindex(e);const i=this.indexes.get(e);return i.forEach((e,t)=>r.push(t)),this.each(r.sort(),e=>i.get(e).forEach(e=>s.push(this.get(e)))),this.immutable?this.freeze(...s):s}toArray(){const e=Array.from(this.data.values());return this.immutable&&(this.each(e,e=>Object.freeze(e)),Object.freeze(e)),e}uuid(){return e()}values(){return this.data.values()}matchesPredicate(e,t,s){return Object.keys(t).every(r=>{const i=t[r],n=e[r];return Array.isArray(i)?Array.isArray(n)?"&&"===s?i.every(e=>n.includes(e)):i.some(e=>n.includes(e)):"&&"===s?i.every(e=>n===e):i.some(e=>n===e):i instanceof RegExp?Array.isArray(n)?"&&"===s?n.every(e=>i.test(e)):n.some(e=>i.test(e)):i.test(n):Array.isArray(n)?n.includes(i):n===i})}where(e={},t="||"){const s=this.index.filter(t=>t in e);if(0===s.length)return[];const r=s.filter(e=>this.indexes.has(e));if(r.length>0){let s=new Set,i=!0;for(const t of r){const r=e[t],n=this.indexes.get(t),h=new Set;if(Array.isArray(r)){for(const e of r)if(n.has(e))for(const t of n.get(e))h.add(t)}else if(n.has(r))for(const e of n.get(r))h.add(e);i?(s=h,i=!1):s=new Set([...s].filter(e=>h.has(e)))}const n=[];for(const r of s){const s=this.get(r,!0);this.matchesPredicate(s,e,t)&&n.push(this.immutable?this.get(r):s)}return this.immutable?this.freeze(...n):n}return this.filter(s=>this.matchesPredicate(s,e,t))}}function h(e=null,t={}){const s=new n(t);return Array.isArray(e)&&s.batch(e,"set"),s}export{n as Haro,h as haro};//# sourceMappingURL=haro.min.js.map
