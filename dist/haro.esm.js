const e=[8,9,"a","b"];function t(e){return JSON.parse(JSON.stringify(e,null,0))}function s(e,t){for(const s of e.entries())t(s[1],s[0]);return e}function r(e,t,s,r){let i;return i=e.includes(s)?e.split(s).sort(((e,t)=>e.localeCompare(t))).map((e=>(void 0!==t[e]?t[e]:"").toString().replace(new RegExp(r,"g"),"").toLowerCase())).join(s):t[e],i}function i(e,t,s,i,n,a){e.forEach((e=>{const h=t.get(e),o=r(e,n,s,a);if(h.has(o)){const e=h.get(o);e.delete(i),0===e.size&&h.delete(o)}}))}function n(e,t){return e instanceof Object&&t instanceof Object?s(Object.keys(t),(s=>{e[s]instanceof Object&&t[s]instanceof Object?e[s]=n(e[s],t[s]):Array.isArray(e[s])&&Array.isArray(t[s])?e[s]=e[s].concat(t[s]):e[s]=t[s]})):e=Array.isArray(e)&&Array.isArray(t)?e.concat(t):t,e}function a(){return(65536*(Math.random()+1)|0).toString(16).substring(1)}function h(e,t,i,n,a,h,o){s(h?[h]:e,(e=>{const h=t.get(e);if(Array.isArray(a[e])&&!e.includes(i))s(a[e],(e=>{h.has(e)||h.set(e,new Set),h.get(e).add(n)}));else{const t=r(e,a,i,o);null!=t&&(h.has(t)||h.set(t,new Set),h.get(t).add(n))}}))}function o(){return a()+a()+"-"+a()+"-4"+a().substr(0,3)+"-"+e[Math.floor(4*Math.random())]+a().substr(0,3)+"-"+a()+a()+a()}class c{constructor({delimiter:e="|",id:t=o(),index:s=[],key:r="",pattern:i="\\s*|\\t*",versioning:n=!1}={}){return this.data=new Map,this.delimiter=e,this.id=t,this.index=s,this.indexes=new Map,this.key=r,this.pattern=i,this.size=0,this.versions=new Map,this.versioning=n,Object.defineProperty(this,"registry",{enumerable:!0,get:()=>Array.from(this.data.keys())}),this.reindex()}async batch(e,t="set",s=!1){let r;try{const i="del"===t?e=>this.del(e,!0,s):e=>this.set(null,e,!0,!0,s);r=await Promise.all(this.beforeBatch(e,t).map(i)),r=this.onbatch(r,t)}catch(e){throw this.onerror("batch",e),e}return r}beforeBatch(e){return e}beforeClear(){}beforeDelete(){}beforeSet(){}clear(){return this.beforeClear(),this.size=0,this.data.clear(),this.indexes.clear(),this.versions.clear(),this.reindex().onclear(),this}del(e,t=!1,s=!1,r=!1){if(!1===this.has(e))throw new Error("Record not found");const n=this.get(e,!0);return this.exec((async()=>{this.beforeDelete(e,t,s,r),i(this.index,this.indexes,this.delimiter,e,n,this.pattern),this.data.delete(e),--this.size}),(async()=>{this.ondelete(e,t,r,s),this.versioning&&this.versions.delete(e)}),(e=>{throw this.onerror("delete",e),e}))}dump(e="records"){let t;return t="records"===e?Array.from(this.entries()):Array.from(this.indexes).map((e=>(e[1]=Array.from(e[1]).map((e=>(e[1]=Array.from(e[1]),e))),e))),t}entries(){return this.data.entries()}async exec(e,t,s){let r;try{r=await t(await e())}catch(e){s(e)}return r}find(e,t=!1){const s=Object.keys(e).sort(((e,t)=>e.localeCompare(t))).join(this.delimiter),i=r(s,e,this.delimiter,this.pattern),n=Array.from((this.indexes.get(s)||new Map).get(i)||new Set).map((e=>this.get(e,t)));return t?n:this.list(...n)}filter(e,t=!1){const s=t?(e,t)=>t:(e,t)=>Object.freeze([e,Object.freeze(t)]),r=this.reduce(((t,r,i,n)=>(e.call(n,r)&&t.push(s(i,r)),t)),[]);return t?r:Object.freeze(r)}forEach(e,s){return this.data.forEach(((s,r)=>e(t(s),t(r))),s||this.data),this}get(e,s=!1){const r=t(this.data.get(e)||null);return s?r:this.list(e,r)}has(e,t=this.data){return t.has(e)}keys(){return this.data.keys()}limit(e=0,t=0,s=!1){const r=this.registry.slice(e,e+t).map((e=>this.get(e,s)));return s?r:this.list(...r)}list(...e){return Object.freeze(e.map((e=>Object.freeze(e))))}map(e,t=!1){const s=[];return this.forEach(((t,r)=>s.push(e(t,r)))),t?s:this.list(...s)}onbatch(e){return e}onclear(){}ondelete(){}onerror(){}onset(){}async override(e,t="records"){if("indexes"===t)this.indexes=new Map(e.map((e=>[e[0],new Map(e[1].map((e=>[e[0],new Set(e[1])])))])));else{if("records"!==t)throw new Error("Invalid type");this.indexes.clear(),this.data=new Map(e),this.size=this.data.size}return!0}reduce(e,t,s=!1){let r=t||this.data.keys().next().value;return this.forEach(((t,i)=>{r=e(r,t,i,this,s)}),this),r}reindex(e){const t=e?[e]:this.index;return e&&!1===this.index.includes(e)&&this.index.push(e),s(t,(e=>this.indexes.set(e,new Map))),this.forEach(((e,r)=>s(t,(t=>h(this.index,this.indexes,this.delimiter,r,e,t,this.pattern))))),this}search(e,t,r=!1){const i=new Map,n="function"==typeof e,a=e&&"function"==typeof e.test;return e&&s(t?Array.isArray(t)?t:[t]:this.index,(t=>{let s=this.indexes.get(t);s&&s.forEach(((s,h)=>{switch(!0){case n&&e(h,t):case a&&e.test(Array.isArray(h)?h.join(", "):h):case h===e:s.forEach((e=>{!i.has(e)&&this.has(e)&&i.set(e,this.get(e,r))}))}}))})),r?Array.from(i.values()):this.list(...Array.from(i.values()))}async set(e,s,r=!1,a=!1,c=!1,l=!1){let d,u=t(s);return this.exec((async()=>(null==e&&(e=this.key&&void 0!==u[this.key]?u[this.key]:o()),this.beforeSet(e,s,r,a,c,l),this.data.has(e)?(d=this.get(e,!0),i(this.index,this.indexes,this.delimiter,e,d,this.pattern),this.versioning&&this.versions.get(e).add(Object.freeze(t(d))),!1===a&&(u=n(t(d),u))):(++this.size,this.versioning&&this.versions.set(e,new Set)),this.data.set(e,u),h(this.index,this.indexes,this.delimiter,e,u,null,this.pattern),this.get(e))),(async e=>(this.onset(e,r,l,c),e)),(e=>{throw this.onerror("set",e),e}))}sort(e,t=!0){return t?Object.freeze(this.limit(0,this.size,!0).sort(e).map((e=>Object.freeze(e)))):this.limit(0,this.size,!0).sort(e)}sortBy(e,t=!1){const r=[],i=[];let n;return this.indexes.has(e)||this.reindex(e),n=this.indexes.get(e),n.forEach(((e,t)=>i.push(t))),s(i.sort(),(e=>n.get(e).forEach((e=>r.push(this.get(e,t)))))),t?r:this.list(...r)}toArray(e=!0){const r=Array.from(this.data.values()).map((e=>t(e)));return e&&(s(r,(e=>Object.freeze(e))),Object.freeze(r)),r}values(){return this.data.values()}where(e,t=!1,s="||"){const r=this.index.filter((t=>t in e));return r.length>0?this.filter(new Function("a",`return (${r.map((t=>{let r;if(Array.isArray(e[t]))r=`Array.isArray(a['${t}']) ? ${e[t].map((e=>`a['${t}'].includes(${"string"==typeof e?`'${e}'`:e})`)).join(` ${s} `)} : (${e[t].map((e=>`a['${t}'] === ${"string"==typeof e?`'${e}'`:e}`)).join(` ${s} `)})`;else if(e[t]instanceof RegExp)r=`Array.isArray(a['${t}']) ? a['${t}'].filter(i => ${e[t]}.test(a['${t}'])).length > 0 : ${e[t]}.test(a['${t}'])`;else{const s="string"==typeof e[t]?`'${e[t]}'`:e[t];r=`Array.isArray(a['${t}']) ? a['${t}'].includes(${s}) : a['${t}'] === ${s}`}return r})).join(") && (")});`),t):[]}}function l(e=null,t={}){const s=new c(t);return Array.isArray(e)&&s.batch(e,"set"),s}export{l as haro};