{"version":3,"file":"haro.min.js","sources":["../src/constants.js","../src/haro.js"],"sourcesContent":["// String constants - Single characters and symbols\nexport const STRING_COMMA = \",\";\nexport const STRING_EMPTY = \"\";\nexport const STRING_PIPE = \"|\";\nexport const STRING_DOUBLE_PIPE = \"||\";\n\n// String constants - Single letters\nexport const STRING_A = \"a\";\nexport const STRING_B = \"b\";\n\n// String constants - Operation and type names\nexport const STRING_DEL = \"del\";\nexport const STRING_FUNCTION = \"function\";\nexport const STRING_INDEXES = \"indexes\";\nexport const STRING_OBJECT = \"object\";\nexport const STRING_RECORDS = \"records\";\nexport const STRING_REGISTRY = \"registry\";\nexport const STRING_SET = \"set\";\nexport const STRING_SIZE = \"size\";\n\n// String constants - Error messages\nexport const STRING_INVALID_FIELD = \"Invalid field\";\nexport const STRING_INVALID_FUNCTION = \"Invalid function\";\nexport const STRING_INVALID_TYPE = \"Invalid type\";\nexport const STRING_RECORD_NOT_FOUND = \"Record not found\";\n\n// Integer constants\nexport const INT_0 = 0;\nexport const INT_1 = 1;\nexport const INT_3 = 3;\nexport const INT_4 = 4;\nexport const INT_8 = 8;\nexport const INT_9 = 9;\nexport const INT_16 = 16;\n","import {randomUUID as uuid} from \"crypto\";\nimport {\n\tINT_0,\n\tSTRING_COMMA,\n\tSTRING_DEL,\n\tSTRING_DOUBLE_PIPE,\n\tSTRING_EMPTY,\n\tSTRING_FUNCTION,\n\tSTRING_INDEXES,\n\tSTRING_INVALID_FIELD,\n\tSTRING_INVALID_FUNCTION,\n\tSTRING_INVALID_TYPE,\n\tSTRING_PIPE,\n\tSTRING_RECORD_NOT_FOUND,\n\tSTRING_RECORDS,\n\tSTRING_REGISTRY,\n\tSTRING_SET,\n\tSTRING_SIZE\n} from \"./constants.js\";\n\n/**\n * Haro is a modern immutable DataStore for collections of records with indexing,\n * versioning, and batch operations support. It provides a Map-like interface\n * with advanced querying capabilities through indexes.\n * @class\n * @example\n * const store = new Haro({\n *   index: ['name', 'age'],\n *   key: 'id',\n *   versioning: true\n * });\n *\n * store.set(null, {name: 'John', age: 30});\n * const results = store.find({name: 'John'});\n */\nexport class Haro {\n\t/**\n\t * Creates a new Haro instance with specified configuration\n\t * @param {Object} [config={}] - Configuration object for the store\n\t * @param {string} [config.delimiter=STRING_PIPE] - Delimiter for composite indexes (default: '|')\n\t * @param {string} [config.id] - Unique identifier for this instance (auto-generated if not provided)\n\t * @param {string[]} [config.index=[]] - Array of field names to create indexes for\n\t * @param {string} [config.key=\"id\"] - Primary key field name used for record identification\n\t * @param {boolean} [config.versioning=false] - Enable versioning to track record changes\n\t * @param {boolean} [config.immutable=false] - Return frozen/immutable objects for data safety\n\t * @constructor\n\t * @example\n\t * const store = new Haro({\n\t *   index: ['name', 'email', 'name|department'],\n\t *   key: 'userId',\n\t *   versioning: true,\n\t *   immutable: true\n\t * });\n\t */\n\tconstructor ({delimiter = STRING_PIPE, id = this.uuid(), index = [], key = \"id\", versioning = false, immutable = false} = {}) {\n\t\tthis.data = new Map();\n\t\tthis.delimiter = delimiter;\n\t\tthis.id = id;\n\t\tthis.index = Array.isArray(index) ? [...index] : [];\n\t\tthis.indexes = new Map();\n\t\tthis.immutable = immutable;\n\t\tthis.key = key;\n\t\tthis.versions = new Map();\n\t\tthis.versioning = versioning;\n\n\t\tObject.defineProperty(this, STRING_REGISTRY, {\n\t\t\tenumerable: true,\n\t\t\tget: () => Array.from(this.data.keys())\n\t\t});\n\t\tObject.defineProperty(this, STRING_SIZE, {\n\t\t\tenumerable: true,\n\t\t\tget: () => this.data.size\n\t\t});\n\n\t\treturn this.reindex();\n\t}\n\n\t/**\n\t * Performs batch operations on multiple records for efficient bulk processing\n\t * @param {Array<Object>} args - Array of records to process\n\t * @param {string} [type=STRING_SET] - Type of operation: 'set' for upsert, 'del' for delete\n\t * @returns {Array} Array of results from the batch operation\n\t * @example\n\t * const results = store.batch([\n\t *   {id: 1, name: 'John'},\n\t *   {id: 2, name: 'Jane'}\n\t * ], 'set');\n\t */\n\tbatch (args, type = STRING_SET) {\n\t\tconst fn = type === STRING_DEL ? i => this.del(i, true) : i => this.set(null, i, true, true);\n\n\t\treturn this.onbatch(this.beforeBatch(args, type).map(fn), type);\n\t}\n\n\t/**\n\t * Lifecycle hook executed before batch operations for custom preprocessing\n\t * @param {Array} arg - Arguments passed to batch operation\n\t * @param {string} [type=STRING_EMPTY] - Type of batch operation ('set' or 'del')\n\t * @returns {Array} Modified arguments (override this method to implement custom logic)\n\t */\n\tbeforeBatch (arg, type = STRING_EMPTY) { // eslint-disable-line no-unused-vars\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Lifecycle hook executed before clear operation for custom preprocessing\n\t * Override this method in subclasses to implement custom logic\n\t * @example\n\t * class MyStore extends Haro {\n\t *   beforeClear() {\n\t *     this.backup = this.toArray();\n\t *   }\n\t * }\n\t */\n\tbeforeClear () {\n\t\t// Hook for custom logic before clear; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed before delete operation for custom preprocessing\n\t * @param {string} [key=STRING_EMPTY] - Key of record to delete\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @returns {Array<string|boolean>} Array containing [key, batch] for further processing\n\t */\n\tbeforeDelete (key = STRING_EMPTY, batch = false) {\n\t\treturn [key, batch];\n\t}\n\n\t/**\n\t * Lifecycle hook executed before set operation for custom preprocessing\n\t * @param {string} [key=STRING_EMPTY] - Key of record to set\n\t * @param {Object} data - Record data being set\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @param {boolean} [override=false] - Whether to override existing data\n\t * @returns {Array<string|boolean>} Array containing [key, batch] for further processing\n\t */\n\tbeforeSet (key = STRING_EMPTY, data, batch = false, override = false) { // eslint-disable-line no-unused-vars\n\t\treturn [key, batch];\n\t}\n\n\t/**\n\t * Removes all records, indexes, and versions from the store\n\t * @returns {Haro} This instance for method chaining\n\t * @example\n\t * store.clear();\n\t * console.log(store.size); // 0\n\t */\n\tclear () {\n\t\tthis.beforeClear();\n\t\tthis.data.clear();\n\t\tthis.indexes.clear();\n\t\tthis.versions.clear();\n\t\tthis.reindex().onclear();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a deep clone of the given value, handling objects, arrays, and primitives\n\t * @param {*} arg - Value to clone (any type)\n\t * @returns {*} Deep clone of the argument\n\t * @example\n\t * const original = {name: 'John', tags: ['user', 'admin']};\n\t * const cloned = store.clone(original);\n\t * cloned.tags.push('new'); // original.tags is unchanged\n\t */\n\tclone (arg) {\n\t\treturn structuredClone(arg);\n\t}\n\n\t/**\n\t * Deletes a record from the store and removes it from all indexes\n\t * @param {string} [key=STRING_EMPTY] - Key of record to delete\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @throws {Error} Throws error if record with the specified key is not found\n\t * @example\n\t * store.del('user123');\n\t * // Throws error if 'user123' doesn't exist\n\t */\n\tdel (key = STRING_EMPTY, batch = false) {\n\t\tif (!this.data.has(key)) {\n\t\t\tthrow new Error(STRING_RECORD_NOT_FOUND);\n\t\t}\n\t\tconst og = this.get(key, true);\n\t\tthis.beforeDelete(key, batch);\n\t\tthis.delIndex(this.index, this.indexes, this.delimiter, key, og);\n\t\tthis.data.delete(key);\n\t\tthis.ondelete(key, batch);\n\t\tif (this.versioning) {\n\t\t\tthis.versions.delete(key);\n\t\t}\n\t}\n\n\t/**\n\t * Internal method to remove entries from indexes for a deleted record\n\t * @param {string[]} index - Array of index field names\n\t * @param {Map<string, Map<*, Set<string>>>} indexes - Map of index structures\n\t * @param {string} delimiter - Delimiter for composite indexes\n\t * @param {string} key - Key of record being deleted\n\t * @param {Object} data - Data of record being deleted\n\t * @private\n\t */\n\tdelIndex (index, indexes, delimiter, key, data) {\n\t\tindex.forEach(i => {\n\t\t\tconst idx = indexes.get(i);\n\t\t\tif (!idx) return;\n\t\t\tconst values = i.includes(delimiter) ?\n\t\t\t\tthis.indexKeys(i, delimiter, data) :\n\t\t\t\tArray.isArray(data[i]) ? data[i] : [data[i]];\n\t\t\tthis.each(values, value => {\n\t\t\t\tif (idx.has(value)) {\n\t\t\t\t\tconst o = idx.get(value);\n\t\t\t\t\to.delete(key);\n\t\t\t\t\tif (o.size === INT_0) {\n\t\t\t\t\t\tidx.delete(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Exports complete store data or indexes for persistence or debugging\n\t * @param {string} [type=STRING_RECORDS] - Type of data to export: 'records' or 'indexes'\n\t * @returns {Array} Array of [key, value] pairs for records, or serialized index structure\n\t * @example\n\t * const records = store.dump('records');\n\t * const indexes = store.dump('indexes');\n\t */\n\tdump (type = STRING_RECORDS) {\n\t\tlet result;\n\n\t\tif (type === STRING_RECORDS) {\n\t\t\tresult = Array.from(this.entries());\n\t\t} else {\n\t\t\tresult = Array.from(this.indexes).map(i => {\n\t\t\t\ti[1] = Array.from(i[1]).map(ii => {\n\t\t\t\t\tii[1] = Array.from(ii[1]);\n\n\t\t\t\t\treturn ii;\n\t\t\t\t});\n\n\t\t\t\treturn i;\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Utility method to iterate over an array with a callback function\n\t * @param {Array} [arr=[]] - Array to iterate over\n\t * @param {Function} fn - Function to call for each element (element, index)\n\t * @returns {Array} The original array for method chaining\n\t * @example\n\t * store.each([1, 2, 3], (item, index) => console.log(item, index));\n\t */\n\teach (arr = [], fn) {\n\t\tconst len = arr.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tfn(arr[i], i);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\t/**\n\t * Returns an iterator of [key, value] pairs for each record in the store\n\t * @returns {Iterator<Array>} Iterator of [key, value] pairs\n\t * @example\n\t * for (const [key, value] of store.entries()) {\n\t *   console.log(key, value);\n\t * }\n\t */\n\tentries () {\n\t\treturn this.data.entries();\n\t}\n\n\t/**\n\t * Finds records matching the specified criteria using indexes for optimal performance\n\t * @param {Object} [where={}] - Object with field-value pairs to match against\n\t * @returns {Array<Object>} Array of matching records (frozen if immutable mode)\n\t * @example\n\t * const users = store.find({department: 'engineering', active: true});\n\t * const admins = store.find({role: 'admin'});\n\t */\n\tfind (where = {}) {\n\t\tconst key = Object.keys(where).sort((a, b) => a.localeCompare(b)).join(this.delimiter);\n\t\tconst index = this.indexes.get(key) ?? new Map();\n\t\tlet result = [];\n\t\tif (index.size > 0) {\n\t\t\tconst keys = this.indexKeys(key, this.delimiter, where);\n\t\t\tresult = Array.from(keys.reduce((a, v) => {\n\t\t\t\tif (index.has(v)) {\n\t\t\t\t\tindex.get(v).forEach(k => a.add(k));\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\t\t\t}, new Set())).map(i => this.get(i));\n\t\t}\n\n\t\treturn this.immutable ? this.freeze(...result) : result;\n\t}\n\n\t/**\n\t * Filters records using a predicate function, similar to Array.filter\n\t * @param {Function} fn - Predicate function to test each record (record, key, store)\n\t * @returns {Array<Object>} Array of records that pass the predicate test\n\t * @throws {Error} Throws error if fn is not a function\n\t * @example\n\t * const adults = store.filter(record => record.age >= 18);\n\t * const recent = store.filter(record => record.created > Date.now() - 86400000);\n\t */\n\tfilter (fn) {\n\t\tif (typeof fn !== STRING_FUNCTION) {\n\t\t\tthrow new Error(STRING_INVALID_FUNCTION);\n\t\t}\n\t\tconst x = this.immutable ? (k, v) => Object.freeze([k, Object.freeze(v)]) : (k, v) => v;\n\t\tconst result = this.reduce((a, v, k, ctx) => {\n\t\t\tif (fn.call(ctx, v)) {\n\t\t\t\ta.push(x(k, v));\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}, []);\n\n\t\treturn this.immutable ? Object.freeze(result) : result;\n\t}\n\n\t/**\n\t * Executes a function for each record in the store, similar to Array.forEach\n\t * @param {Function} fn - Function to execute for each record (value, key)\n\t * @param {*} [ctx] - Context object to use as 'this' when executing the function\n\t * @returns {Haro} This instance for method chaining\n\t * @example\n\t * store.forEach((record, key) => {\n\t *   console.log(`${key}: ${record.name}`);\n\t * });\n\t */\n\tforEach (fn, ctx) {\n\t\tthis.data.forEach((value, key) => {\n\t\t\tfn(this.clone(value), key); // Only clone value, key is primitive\n\t\t}, ctx ?? this.data);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a frozen array from the given arguments for immutable data handling\n\t * @param {...*} args - Arguments to freeze into an array\n\t * @returns {Array} Frozen array containing frozen arguments\n\t * @example\n\t * const frozen = store.freeze(obj1, obj2, obj3);\n\t * // Returns Object.freeze([Object.freeze(obj1), Object.freeze(obj2), Object.freeze(obj3)])\n\t */\n\tfreeze (...args) {\n\t\treturn Object.freeze(args.map(i => Object.freeze(i)));\n\t}\n\n\t/**\n\t * Retrieves a record by its key\n\t * @param {string} key - Key of record to retrieve\n\t * @param {boolean} [raw=false] - Whether to return raw data (true) or processed/frozen data (false)\n\t * @returns {Object|null} The record if found, null if not found\n\t * @example\n\t * const user = store.get('user123');\n\t * const rawUser = store.get('user123', true);\n\t */\n\tget (key, raw = false) {\n\t\tlet result = this.data.get(key) ?? null;\n\n\t\tif (result !== null && !raw) {\n\t\t\tif (this.immutable) {\n\t\t\t\tresult = this.clone(result);\n\t\t\t}\n\n\t\t\treturn this.immutable ? this.freeze(key, result) : result;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Checks if a record with the specified key exists in the store\n\t * @param {string} key - Key to check for existence\n\t * @returns {boolean} True if record exists, false otherwise\n\t * @example\n\t * if (store.has('user123')) {\n\t *   console.log('User exists');\n\t * }\n\t */\n\thas (key) {\n\t\treturn this.data.has(key);\n\t}\n\n\t/**\n\t * Generates index keys for composite indexes from data values\n\t * @param {string} [arg=STRING_EMPTY] - Composite index field names joined by delimiter\n\t * @param {string} [delimiter=STRING_PIPE] - Delimiter used in composite index\n\t * @param {Object} [data={}] - Data object to extract field values from\n\t * @returns {string[]} Array of generated index keys\n\t * @example\n\t * // For index 'name|department' with data {name: 'John', department: 'IT'}\n\t * const keys = store.indexKeys('name|department', '|', data);\n\t * // Returns ['John|IT']\n\t */\n\tindexKeys (arg = STRING_EMPTY, delimiter = STRING_PIPE, data = {}) {\n\t\tconst fields = arg.split(delimiter);\n\t\tconst fieldsLen = fields.length;\n\t\tlet result = [\"\"];\n\n\t\tfor (let i = 0; i < fieldsLen; i++) {\n\t\t\tconst field = fields[i];\n\t\t\tconst values = Array.isArray(data[field]) ? data[field] : [data[field]];\n\t\t\tconst newResult = [];\n\t\t\tconst resultLen = result.length;\n\t\t\tconst valuesLen = values.length;\n\n\t\t\tfor (let j = 0; j < resultLen; j++) {\n\t\t\t\tfor (let k = 0; k < valuesLen; k++) {\n\t\t\t\t\tconst newKey = i === 0 ? values[k] : `${result[j]}${delimiter}${values[k]}`;\n\t\t\t\t\tnewResult.push(newKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = newResult;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns an iterator of all keys in the store\n\t * @returns {Iterator<string>} Iterator of record keys\n\t * @example\n\t * for (const key of store.keys()) {\n\t *   console.log(key);\n\t * }\n\t */\n\tkeys () {\n\t\treturn this.data.keys();\n\t}\n\n\t/**\n\t * Returns a limited subset of records with offset support for pagination\n\t * @param {number} [offset=INT_0] - Number of records to skip from the beginning\n\t * @param {number} [max=INT_0] - Maximum number of records to return\n\t * @returns {Array<Object>} Array of records within the specified range\n\t * @example\n\t * const page1 = store.limit(0, 10);   // First 10 records\n\t * const page2 = store.limit(10, 10);  // Next 10 records\n\t */\n\tlimit (offset = INT_0, max = INT_0) {\n\t\tconst result = this.registry.slice(offset, offset + max).map(i => this.get(i));\n\n\t\treturn this.immutable ? this.freeze(...result) : result;\n\t}\n\n\t/**\n\t * Transforms all records using a mapping function, similar to Array.map\n\t * @param {Function} fn - Function to transform each record (record, key)\n\t * @returns {Array} Array of transformed results\n\t * @throws {Error} Throws error if fn is not a function\n\t * @example\n\t * const names = store.map(record => record.name);\n\t * const summaries = store.map(record => ({id: record.id, name: record.name}));\n\t */\n\tmap (fn) {\n\t\tif (typeof fn !== STRING_FUNCTION) {\n\t\t\tthrow new Error(STRING_INVALID_FUNCTION);\n\t\t}\n\n\t\tconst result = [];\n\n\t\tthis.forEach((value, key) => result.push(fn(value, key)));\n\n\t\treturn this.immutable ? this.freeze(...result) : result;\n\t}\n\n\t/**\n\t * Merges two values together with support for arrays and objects\n\t * @param {*} a - First value (target)\n\t * @param {*} b - Second value (source)\n\t * @param {boolean} [override=false] - Whether to override arrays instead of concatenating\n\t * @returns {*} Merged result\n\t * @example\n\t * const merged = store.merge({a: 1}, {b: 2}); // {a: 1, b: 2}\n\t * const arrays = store.merge([1, 2], [3, 4]); // [1, 2, 3, 4]\n\t */\n\tmerge (a, b, override = false) {\n\t\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\t\ta = override ? b : a.concat(b);\n\t\t} else if (typeof a === \"object\" && a !== null && typeof b === \"object\" && b !== null) {\n\t\t\tthis.each(Object.keys(b), i => {\n\t\t\t\ta[i] = this.merge(a[i], b[i], override);\n\t\t\t});\n\t\t} else {\n\t\t\ta = b;\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Lifecycle hook executed after batch operations for custom postprocessing\n\t * @param {Array} arg - Result of batch operation\n\t * @param {string} [type=STRING_EMPTY] - Type of batch operation that was performed\n\t * @returns {Array} Modified result (override this method to implement custom logic)\n\t */\n\tonbatch (arg, type = STRING_EMPTY) { // eslint-disable-line no-unused-vars\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Lifecycle hook executed after clear operation for custom postprocessing\n\t * Override this method in subclasses to implement custom logic\n\t * @example\n\t * class MyStore extends Haro {\n\t *   onclear() {\n\t *     console.log('Store cleared');\n\t *   }\n\t * }\n\t */\n\tonclear () {\n\t\t// Hook for custom logic after clear; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed after delete operation for custom postprocessing\n\t * @param {string} [key=STRING_EMPTY] - Key of deleted record\n\t * @param {boolean} [batch=false] - Whether this was part of a batch operation\n\t * @returns {Array<string|boolean>} Array containing [key, batch] for further processing\n\t */\n\tondelete (key = STRING_EMPTY, batch = false) {\n\t\treturn [key, batch];\n\t}\n\n\t/**\n\t * Lifecycle hook executed after override operation for custom postprocessing\n\t * @param {string} [type=STRING_EMPTY] - Type of override operation that was performed\n\t * @returns {string} The type parameter for further processing\n\t */\n\tonoverride (type = STRING_EMPTY) {\n\t\treturn type;\n\t}\n\n\t/**\n\t * Lifecycle hook executed after set operation for custom postprocessing\n\t * @param {Object} [arg={}] - Record that was set\n\t * @param {boolean} [batch=false] - Whether this was part of a batch operation\n\t * @returns {Array<Object|boolean>} Array containing [record, batch] for further processing\n\t */\n\tonset (arg = {}, batch = false) {\n\t\treturn [arg, batch];\n\t}\n\n\t/**\n\t * Replaces all store data or indexes with new data for bulk operations\n\t * @param {Array} data - Data to replace with (format depends on type)\n\t * @param {string} [type=STRING_RECORDS] - Type of data: 'records' or 'indexes'\n\t * @returns {boolean} True if operation succeeded\n\t * @throws {Error} Throws error if type is invalid\n\t * @example\n\t * const records = [['key1', {name: 'John'}], ['key2', {name: 'Jane'}]];\n\t * store.override(records, 'records');\n\t */\n\toverride (data, type = STRING_RECORDS) {\n\t\tconst result = true;\n\n\t\tif (type === STRING_INDEXES) {\n\t\t\tthis.indexes = new Map(data.map(i => [i[0], new Map(i[1].map(ii => [ii[0], new Set(ii[1])]))]));\n\t\t} else if (type === STRING_RECORDS) {\n\t\t\tthis.indexes.clear();\n\t\t\tthis.data = new Map(data);\n\t\t} else {\n\t\t\tthrow new Error(STRING_INVALID_TYPE);\n\t\t}\n\n\t\tthis.onoverride(type);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Reduces all records to a single value using a reducer function\n\t * @param {Function} fn - Reducer function (accumulator, value, key, store)\n\t * @param {*} [accumulator] - Initial accumulator value\n\t * @returns {*} Final reduced value\n\t * @example\n\t * const totalAge = store.reduce((sum, record) => sum + record.age, 0);\n\t * const names = store.reduce((acc, record) => acc.concat(record.name), []);\n\t */\n\treduce (fn, accumulator) {\n\t\tlet a = accumulator ?? this.data.keys().next().value;\n\n\t\tthis.forEach((v, k) => {\n\t\t\ta = fn(a, v, k, this);\n\t\t}, this);\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Rebuilds indexes for specified fields or all fields for data consistency\n\t * @param {string|string[]} [index] - Specific index field(s) to rebuild, or all if not specified\n\t * @returns {Haro} This instance for method chaining\n\t * @example\n\t * store.reindex(); // Rebuild all indexes\n\t * store.reindex('name'); // Rebuild only name index\n\t * store.reindex(['name', 'email']); // Rebuild name and email indexes\n\t */\n\treindex (index) {\n\t\tconst indices = index ? [index] : this.index;\n\n\t\tif (index && this.index.includes(index) === false) {\n\t\t\tthis.index.push(index);\n\t\t}\n\n\t\tthis.each(indices, i => this.indexes.set(i, new Map()));\n\t\tthis.forEach((data, key) => this.each(indices, i => this.setIndex(this.index, this.indexes, this.delimiter, key, data, i)));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Searches for records containing a value across specified indexes\n\t * @param {*} value - Value to search for (string, function, or RegExp)\n\t * @param {string|string[]} [index] - Index(es) to search in, or all if not specified\n\t * @returns {Array<Object>} Array of matching records\n\t * @example\n\t * const results = store.search('john'); // Search all indexes\n\t * const nameResults = store.search('john', 'name'); // Search only name index\n\t * const regexResults = store.search(/^admin/, 'role'); // Regex search\n\t */\n\tsearch (value, index) {\n\t\tconst result = new Set(); // Use Set for unique keys\n\t\tconst fn = typeof value === STRING_FUNCTION;\n\t\tconst rgex = value && typeof value.test === STRING_FUNCTION;\n\n\t\tif (!value) return this.immutable ? this.freeze() : [];\n\n\t\tconst indices = index ? Array.isArray(index) ? index : [index] : this.index;\n\n\t\tfor (const i of indices) {\n\t\t\tconst idx = this.indexes.get(i);\n\t\t\tif (idx) {\n\t\t\t\tfor (const [lkey, lset] of idx) {\n\t\t\t\t\tlet match = false;\n\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\tmatch = value(lkey, i);\n\t\t\t\t\t} else if (rgex) {\n\t\t\t\t\t\tmatch = value.test(Array.isArray(lkey) ? lkey.join(STRING_COMMA) : lkey);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = lkey === value;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tfor (const key of lset) {\n\t\t\t\t\t\t\tif (this.data.has(key)) {\n\t\t\t\t\t\t\t\tresult.add(key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst records = Array.from(result).map(key => this.get(key));\n\n\t\treturn this.immutable ? this.freeze(...records) : records;\n\t}\n\n\t/**\n\t * Sets or updates a record in the store with automatic indexing\n\t * @param {string|null} [key=null] - Key for the record, or null to use record's key field\n\t * @param {Object} [data={}] - Record data to set\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @param {boolean} [override=false] - Whether to override existing data instead of merging\n\t * @returns {Object} The stored record (frozen if immutable mode)\n\t * @example\n\t * const user = store.set(null, {name: 'John', age: 30}); // Auto-generate key\n\t * const updated = store.set('user123', {age: 31}); // Update existing record\n\t */\n\tset (key = null, data = {}, batch = false, override = false) {\n\t\tif (key === null) {\n\t\t\tkey = data[this.key] ?? this.uuid();\n\t\t}\n\t\tlet x = {...data, [this.key]: key};\n\t\tthis.beforeSet(key, x, batch, override);\n\t\tif (!this.data.has(key)) {\n\t\t\tif (this.versioning) {\n\t\t\t\tthis.versions.set(key, new Set());\n\t\t\t}\n\t\t} else {\n\t\t\tconst og = this.get(key, true);\n\t\t\tthis.delIndex(this.index, this.indexes, this.delimiter, key, og);\n\t\t\tif (this.versioning) {\n\t\t\t\tthis.versions.get(key).add(Object.freeze(this.clone(og)));\n\t\t\t}\n\t\t\tif (!override) {\n\t\t\t\tx = this.merge(this.clone(og), x);\n\t\t\t}\n\t\t}\n\t\tthis.data.set(key, x);\n\t\tthis.setIndex(this.index, this.indexes, this.delimiter, key, x, null);\n\t\tconst result = this.get(key);\n\t\tthis.onset(result, batch);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Internal method to add entries to indexes for a record\n\t * @param {string[]} index - Array of index field names\n\t * @param {Map<string, Map<*, Set<string>>>} indexes - Map of index structures\n\t * @param {string} delimiter - Delimiter for composite indexes\n\t * @param {string} key - Key of record being indexed\n\t * @param {Object} data - Data of record being indexed\n\t * @param {string|null} indice - Specific index to update, or null for all\n\t * @private\n\t */\n\tsetIndex (index, indexes, delimiter, key, data, indice) {\n\t\tthis.each(indice === null ? index : [indice], i => {\n\t\t\tlet lindex = indexes.get(i);\n\t\t\tif (!lindex) {\n\t\t\t\tlindex = new Map();\n\t\t\t\tindexes.set(i, lindex);\n\t\t\t}\n\t\t\tif (i.includes(delimiter)) {\n\t\t\t\tthis.each(this.indexKeys(i, delimiter, data), c => {\n\t\t\t\t\tif (!lindex.has(c)) {\n\t\t\t\t\t\tlindex.set(c, new Set());\n\t\t\t\t\t}\n\t\t\t\t\tlindex.get(c).add(key);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.each(Array.isArray(data[i]) ? data[i] : [data[i]], d => {\n\t\t\t\t\tif (!lindex.has(d)) {\n\t\t\t\t\t\tlindex.set(d, new Set());\n\t\t\t\t\t}\n\t\t\t\t\tlindex.get(d).add(key);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Sorts all records using a comparator function\n\t * @param {Function} fn - Comparator function for sorting (a, b) => number\n\t * @param {boolean} [frozen=false] - Whether to return frozen records\n\t * @returns {Array<Object>} Sorted array of records\n\t * @example\n\t * const sorted = store.sort((a, b) => a.age - b.age); // Sort by age\n\t * const names = store.sort((a, b) => a.name.localeCompare(b.name)); // Sort by name\n\t */\n\tsort (fn, frozen = false) {\n\t\tconst dataSize = this.data.size;\n\n\t\treturn frozen ? Object.freeze(this.limit(INT_0, dataSize, true).sort(fn).map(i => Object.freeze(i))) : this.limit(INT_0, dataSize, true).sort(fn);\n\t}\n\n\t/**\n\t * Sorts records by a specific indexed field in ascending order\n\t * @param {string} [index=STRING_EMPTY] - Index field name to sort by\n\t * @returns {Array<Object>} Array of records sorted by the specified field\n\t * @throws {Error} Throws error if index field is empty or invalid\n\t * @example\n\t * const byAge = store.sortBy('age');\n\t * const byName = store.sortBy('name');\n\t */\n\tsortBy (index = STRING_EMPTY) {\n\t\tif (index === STRING_EMPTY) {\n\t\t\tthrow new Error(STRING_INVALID_FIELD);\n\t\t}\n\n\t\tconst result = [],\n\t\t\tkeys = [];\n\n\t\tif (this.indexes.has(index) === false) {\n\t\t\tthis.reindex(index);\n\t\t}\n\n\t\tconst lindex = this.indexes.get(index);\n\n\t\tlindex.forEach((idx, key) => keys.push(key));\n\t\tthis.each(keys.sort(), i => lindex.get(i).forEach(key => result.push(this.get(key))));\n\n\t\treturn this.immutable ? this.freeze(...result) : result;\n\t}\n\n\t/**\n\t * Converts all store data to a plain array of records\n\t * @returns {Array<Object>} Array containing all records in the store\n\t * @example\n\t * const allRecords = store.toArray();\n\t * console.log(`Store contains ${allRecords.length} records`);\n\t */\n\ttoArray () {\n\t\tconst result = Array.from(this.data.values());\n\n\t\tif (this.immutable) {\n\t\t\tthis.each(result, i => Object.freeze(i));\n\t\t\tObject.freeze(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Generates a RFC4122 v4 UUID for record identification\n\t * @returns {string} UUID string in standard format\n\t * @example\n\t * const id = store.uuid(); // \"f47ac10b-58cc-4372-a567-0e02b2c3d479\"\n\t */\n\tuuid () {\n\t\treturn uuid();\n\t}\n\n\t/**\n\t * Returns an iterator of all values in the store\n\t * @returns {Iterator<Object>} Iterator of record values\n\t * @example\n\t * for (const record of store.values()) {\n\t *   console.log(record.name);\n\t * }\n\t */\n\tvalues () {\n\t\treturn this.data.values();\n\t}\n\n\t/**\n\t * Internal helper method for predicate matching with support for arrays and regex\n\t * @param {Object} record - Record to test against predicate\n\t * @param {Object} predicate - Predicate object with field-value pairs\n\t * @param {string} op - Operator for array matching ('||' for OR, '&&' for AND)\n\t * @returns {boolean} True if record matches predicate criteria\n\t * @private\n\t */\n\tmatchesPredicate (record, predicate, op) {\n\t\tconst keys = Object.keys(predicate);\n\n\t\treturn keys.every(key => {\n\t\t\tconst pred = predicate[key];\n\t\t\tconst val = record[key];\n\n\t\t\tif (Array.isArray(pred)) {\n\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\treturn op === \"&&\" ? pred.every(p => val.includes(p)) : pred.some(p => val.includes(p));\n\t\t\t\t} else {\n\t\t\t\t\treturn op === \"&&\" ? pred.every(p => val === p) : pred.some(p => val === p);\n\t\t\t\t}\n\t\t\t} else if (pred instanceof RegExp) {\n\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\treturn op === \"&&\" ? val.every(v => pred.test(v)) : val.some(v => pred.test(v));\n\t\t\t\t} else {\n\t\t\t\t\treturn pred.test(val);\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(val)) {\n\t\t\t\treturn val.includes(pred);\n\t\t\t} else {\n\t\t\t\treturn val === pred;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Advanced filtering with predicate logic supporting AND/OR operations on arrays\n\t * @param {Object} [predicate={}] - Object with field-value pairs for filtering\n\t * @param {string} [op=STRING_DOUBLE_PIPE] - Operator for array matching ('||' for OR, '&&' for AND)\n\t * @returns {Array<Object>} Array of records matching the predicate criteria\n\t * @example\n\t * // Find records with tags containing 'admin' OR 'user'\n\t * const users = store.where({tags: ['admin', 'user']}, '||');\n\t *\n\t * // Find records with ALL specified tags\n\t * const powerUsers = store.where({tags: ['admin', 'power']}, '&&');\n\t *\n\t * // Regex matching\n\t * const emails = store.where({email: /^admin@/});\n\t */\n\twhere (predicate = {}, op = STRING_DOUBLE_PIPE) {\n\t\tconst keys = this.index.filter(i => i in predicate);\n\t\tif (keys.length === 0) return [];\n\n\t\t// Try to use indexes for better performance\n\t\tconst indexedKeys = keys.filter(k => this.indexes.has(k));\n\n\t\tif (indexedKeys.length > 0) {\n\t\t\t// Use index-based filtering for better performance\n\t\t\tlet candidateKeys = new Set();\n\t\t\tlet first = true;\n\n\t\t\tfor (const key of indexedKeys) {\n\t\t\t\tconst pred = predicate[key];\n\t\t\t\tconst idx = this.indexes.get(key);\n\t\t\t\tconst matchingKeys = new Set();\n\n\t\t\t\tif (Array.isArray(pred)) {\n\t\t\t\t\tfor (const p of pred) {\n\t\t\t\t\t\tif (idx.has(p)) {\n\t\t\t\t\t\t\tfor (const k of idx.get(p)) {\n\t\t\t\t\t\t\t\tmatchingKeys.add(k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (idx.has(pred)) {\n\t\t\t\t\tfor (const k of idx.get(pred)) {\n\t\t\t\t\t\tmatchingKeys.add(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (first) {\n\t\t\t\t\tcandidateKeys = matchingKeys;\n\t\t\t\t\tfirst = false;\n\t\t\t\t} else {\n\t\t\t\t\t// AND operation across different fields\n\t\t\t\t\tcandidateKeys = new Set([...candidateKeys].filter(k => matchingKeys.has(k)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Filter candidates with full predicate logic\n\t\t\tconst results = [];\n\t\t\tfor (const key of candidateKeys) {\n\t\t\t\tconst record = this.get(key, true);\n\t\t\t\tif (this.matchesPredicate(record, predicate, op)) {\n\t\t\t\t\tresults.push(this.immutable ? this.get(key) : record);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.immutable ? this.freeze(...results) : results;\n\t\t}\n\n\t\t// Fallback to full scan if no indexes available\n\t\treturn this.filter(a => this.matchesPredicate(a, predicate, op));\n\t}\n\n}\n\n/**\n * Factory function to create a new Haro instance with optional initial data\n * @param {Array<Object>|null} [data=null] - Initial data to populate the store\n * @param {Object} [config={}] - Configuration object passed to Haro constructor\n * @returns {Haro} New Haro instance configured and optionally populated\n * @example\n * const store = haro([\n *   {id: 1, name: 'John', age: 30},\n *   {id: 2, name: 'Jane', age: 25}\n * ], {\n *   index: ['name', 'age'],\n *   versioning: true\n * });\n */\nexport function haro (data = null, config = {}) {\n\tconst obj = new Haro(config);\n\n\tif (Array.isArray(data)) {\n\t\tobj.batch(data, STRING_SET);\n\t}\n\n\treturn obj;\n}\n"],"names":["randomUUID","STRING_EMPTY","STRING_FUNCTION","STRING_RECORDS","STRING_INVALID_FUNCTION","Haro","constructor","delimiter","id","this","uuid","index","key","versioning","immutable","data","Map","Array","isArray","indexes","versions","Object","defineProperty","enumerable","get","from","keys","size","reindex","batch","args","type","fn","i","del","set","onbatch","beforeBatch","map","arg","beforeClear","beforeDelete","beforeSet","override","clear","onclear","clone","structuredClone","has","Error","og","delIndex","delete","ondelete","forEach","idx","values","includes","indexKeys","each","value","o","dump","result","entries","ii","arr","len","length","find","where","sort","a","b","localeCompare","join","reduce","v","k","add","Set","freeze","filter","x","ctx","call","push","raw","fields","split","fieldsLen","field","newResult","resultLen","valuesLen","j","newKey","limit","offset","max","registry","slice","merge","concat","onoverride","onset","accumulator","next","indices","setIndex","search","rgex","test","lkey","lset","match","records","indice","lindex","c","d","frozen","dataSize","sortBy","toArray","matchesPredicate","record","predicate","op","every","pred","val","p","some","RegExp","indexedKeys","candidateKeys","first","matchingKeys","results","haro","config","obj"],"mappings":"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"}