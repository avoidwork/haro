{"version":3,"file":"haro.min.js","sources":["../src/constants.js","../src/haro.js"],"sourcesContent":["// String constants - Single characters and symbols\nexport const STRING_COMMA = \",\";\nexport const STRING_EMPTY = \"\";\nexport const STRING_PIPE = \"|\";\nexport const STRING_DOUBLE_PIPE = \"||\";\nexport const STRING_DOUBLE_AND = \"&&\";\n\n// String constants - Operation and type names\nexport const STRING_ID = \"id\";\nexport const STRING_DEL = \"del\";\nexport const STRING_FUNCTION = \"function\";\nexport const STRING_INDEXES = \"indexes\";\nexport const STRING_OBJECT = \"object\";\nexport const STRING_RECORDS = \"records\";\nexport const STRING_REGISTRY = \"registry\";\nexport const STRING_SET = \"set\";\nexport const STRING_SIZE = \"size\";\nexport const STRING_STRING = \"string\";\nexport const STRING_NUMBER = \"number\";\n\n// String constants - Error messages\nexport const STRING_INVALID_FIELD = \"Invalid field\";\nexport const STRING_INVALID_FUNCTION = \"Invalid function\";\nexport const STRING_INVALID_TYPE = \"Invalid type\";\nexport const STRING_RECORD_NOT_FOUND = \"Record not found\";\n\n// Integer constants\nexport const INT_0 = 0;\n","import {randomUUID as uuid} from \"crypto\";\nimport {\n\tINT_0,\n\tSTRING_COMMA,\n\tSTRING_DEL, STRING_DOUBLE_AND,\n\tSTRING_DOUBLE_PIPE,\n\tSTRING_EMPTY,\n\tSTRING_FUNCTION,\n\tSTRING_ID,\n\tSTRING_INDEXES,\n\tSTRING_INVALID_FIELD,\n\tSTRING_INVALID_FUNCTION,\n\tSTRING_INVALID_TYPE, STRING_NUMBER, STRING_OBJECT,\n\tSTRING_PIPE,\n\tSTRING_RECORD_NOT_FOUND,\n\tSTRING_RECORDS,\n\tSTRING_REGISTRY,\n\tSTRING_SET,\n\tSTRING_SIZE, STRING_STRING\n} from \"./constants.js\";\n\n/**\n * Haro is a modern immutable DataStore for collections of records with indexing,\n * versioning, and batch operations support. It provides a Map-like interface\n * with advanced querying capabilities through indexes.\n * @class\n * @example\n * const store = new Haro({\n *   index: ['name', 'age'],\n *   key: 'id',\n *   versioning: true\n * });\n *\n * store.set(null, {name: 'John', age: 30});\n * const results = store.find({name: 'John'});\n */\nexport class Haro {\n\t/**\n\t * Creates a new Haro instance with specified configuration\n\t * @param {Object} [config={}] - Configuration object for the store\n\t * @param {string} [config.delimiter=STRING_PIPE] - Delimiter for composite indexes (default: '|')\n\t * @param {string} [config.id] - Unique identifier for this instance (auto-generated if not provided)\n\t * @param {boolean} [config.immutable=false] - Return frozen/immutable objects for data safety\n\t * @param {string[]} [config.index=[]] - Array of field names to create indexes for\n\t * @param {string} [config.key=STRING_ID] - Primary key field name used for record identification\n\t * @param {boolean} [config.versioning=false] - Enable versioning to track record changes\n\t * @constructor\n\t * @example\n\t * const store = new Haro({\n\t *   index: ['name', 'email', 'name|department'],\n\t *   key: 'userId',\n\t *   versioning: true,\n\t *   immutable: true\n\t * });\n\t */\n\tconstructor ({delimiter = STRING_PIPE, id = this.uuid(), immutable = false, index = [], key = STRING_ID, versioning = false} = {}) {\n\t\tthis.data = new Map();\n\t\tthis.delimiter = delimiter;\n\t\tthis.id = id;\n\t\tthis.immutable = immutable;\n\t\tthis.index = Array.isArray(index) ? [...index] : [];\n\t\tthis.indexes = new Map();\n\t\tthis.key = key;\n\t\tthis.versions = new Map();\n\t\tthis.versioning = versioning;\n\t\tObject.defineProperty(this, STRING_REGISTRY, {\n\t\t\tenumerable: true,\n\t\t\tget: () => Array.from(this.data.keys())\n\t\t});\n\t\tObject.defineProperty(this, STRING_SIZE, {\n\t\t\tenumerable: true,\n\t\t\tget: () => this.data.size\n\t\t});\n\n\t\treturn this.reindex();\n\t}\n\n\t/**\n\t * Performs batch operations on multiple records for efficient bulk processing\n\t * @param {Array<Object>} args - Array of records to process\n\t * @param {string} [type=STRING_SET] - Type of operation: 'set' for upsert, 'del' for delete\n\t * @returns {Array<Object>} Array of results from the batch operation\n\t * @throws {Error} Throws error if individual operations fail during batch processing\n\t * @example\n\t * const results = store.batch([\n\t *   {id: 1, name: 'John'},\n\t *   {id: 2, name: 'Jane'}\n\t * ], 'set');\n\t */\n\tbatch (args, type = STRING_SET) {\n\t\tconst fn = type === STRING_DEL ? i => this.delete(i, true) : i => this.set(null, i, true, true);\n\n\t\treturn this.onbatch(this.beforeBatch(args, type).map(fn), type);\n\t}\n\n\t/**\n\t * Lifecycle hook executed before batch operations for custom preprocessing\n\t * @param {Array<Object>} arg - Arguments passed to batch operation\n\t * @param {string} [type=STRING_EMPTY] - Type of batch operation ('set' or 'del')\n\t * @returns {Array<Object>} The arguments array (possibly modified) to be processed\n\t */\n\tbeforeBatch (arg, type = STRING_EMPTY) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic before batch; override in subclass if needed\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Lifecycle hook executed before clear operation for custom preprocessing\n\t * @returns {void} Override this method in subclasses to implement custom logic\n\t * @example\n\t * class MyStore extends Haro {\n\t *   beforeClear() {\n\t *     this.backup = this.toArray();\n\t *   }\n\t * }\n\t */\n\tbeforeClear () {\n\t\t// Hook for custom logic before clear; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed before delete operation for custom preprocessing\n\t * @param {string} [key=STRING_EMPTY] - Key of record to delete\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @returns {void} Override this method in subclasses to implement custom logic\n\t */\n\tbeforeDelete (key = STRING_EMPTY, batch = false) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic before delete; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed before set operation for custom preprocessing\n\t * @param {string} [key=STRING_EMPTY] - Key of record to set\n\t * @param {Object} [data={}] - Record data being set\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @param {boolean} [override=false] - Whether to override existing data\n\t * @returns {void} Override this method in subclasses to implement custom logic\n\t */\n\tbeforeSet (key = STRING_EMPTY, data = {}, batch = false, override = false) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic before set; override in subclass if needed\n\t}\n\n\t/**\n\t * Removes all records, indexes, and versions from the store\n\t * @returns {Haro} This instance for method chaining\n\t * @example\n\t * store.clear();\n\t * console.log(store.size); // 0\n\t */\n\tclear () {\n\t\tthis.beforeClear();\n\t\tthis.data.clear();\n\t\tthis.indexes.clear();\n\t\tthis.versions.clear();\n\t\tthis.reindex().onclear();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a deep clone of the given value, handling objects, arrays, and primitives\n\t * @param {*} arg - Value to clone (any type)\n\t * @returns {*} Deep clone of the argument\n\t * @example\n\t * const original = {name: 'John', tags: ['user', 'admin']};\n\t * const cloned = store.clone(original);\n\t * cloned.tags.push('new'); // original.tags is unchanged\n\t */\n\tclone (arg) {\n\t\treturn structuredClone(arg);\n\t}\n\n\t/**\n\t * Deletes a record from the store and removes it from all indexes\n\t * @param {string} [key=STRING_EMPTY] - Key of record to delete\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @returns {void}\n\t * @throws {Error} Throws error if record with the specified key is not found\n\t * @example\n\t * store.delete('user123');\n\t * // Throws error if 'user123' doesn't exist\n\t */\n\tdelete (key = STRING_EMPTY, batch = false) {\n\t\tif (!this.data.has(key)) {\n\t\t\tthrow new Error(STRING_RECORD_NOT_FOUND);\n\t\t}\n\t\tconst og = this.get(key, true);\n\t\tthis.beforeDelete(key, batch);\n\t\tthis.deleteIndex(key, og);\n\t\tthis.data.delete(key);\n\t\tthis.ondelete(key, batch);\n\t\tif (this.versioning) {\n\t\t\tthis.versions.delete(key);\n\t\t}\n\t}\n\n\t/**\n\t * Internal method to remove entries from indexes for a deleted record\n\t * @param {string} key - Key of record being deleted\n\t * @param {Object} data - Data of record being deleted\n\t * @returns {Haro} This instance for method chaining\n\t */\n\tdeleteIndex (key, data) {\n\t\tthis.index.forEach(i => {\n\t\t\tconst idx = this.indexes.get(i);\n\t\t\tif (!idx) return;\n\t\t\tconst values = i.includes(this.delimiter) ?\n\t\t\t\tthis.indexKeys(i, this.delimiter, data) :\n\t\t\t\tArray.isArray(data[i]) ? data[i] : [data[i]];\n\t\t\tthis.each(values, value => {\n\t\t\t\tif (idx.has(value)) {\n\t\t\t\t\tconst o = idx.get(value);\n\t\t\t\t\to.delete(key);\n\t\t\t\t\tif (o.size === INT_0) {\n\t\t\t\t\t\tidx.delete(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Exports complete store data or indexes for persistence or debugging\n\t * @param {string} [type=STRING_RECORDS] - Type of data to export: 'records' or 'indexes'\n\t * @returns {Array<Array>} Array of [key, value] pairs for records, or serialized index structure\n\t * @example\n\t * const records = store.dump('records');\n\t * const indexes = store.dump('indexes');\n\t */\n\tdump (type = STRING_RECORDS) {\n\t\tlet result;\n\t\tif (type === STRING_RECORDS) {\n\t\t\tresult = Array.from(this.entries());\n\t\t} else {\n\t\t\tresult = Array.from(this.indexes).map(i => {\n\t\t\t\ti[1] = Array.from(i[1]).map(ii => {\n\t\t\t\t\tii[1] = Array.from(ii[1]);\n\n\t\t\t\t\treturn ii;\n\t\t\t\t});\n\n\t\t\t\treturn i;\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Utility method to iterate over an array with a callback function\n\t * @param {Array<*>} [arr=[]] - Array to iterate over\n\t * @param {Function} fn - Function to call for each element (element, index)\n\t * @returns {Array<*>} The original array for method chaining\n\t * @example\n\t * store.each([1, 2, 3], (item, index) => console.log(item, index));\n\t */\n\teach (arr = [], fn) {\n\t\tconst len = arr.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tfn(arr[i], i);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\t/**\n\t * Returns an iterator of [key, value] pairs for each record in the store\n\t * @returns {Iterator<Array<string|Object>>} Iterator of [key, value] pairs\n\t * @example\n\t * for (const [key, value] of store.entries()) {\n\t *   console.log(key, value);\n\t * }\n\t */\n\tentries () {\n\t\treturn this.data.entries();\n\t}\n\n\t/**\n\t * Finds records matching the specified criteria using indexes for optimal performance\n\t * @param {Object} [where={}] - Object with field-value pairs to match against\n\t * @param {boolean} [raw=false] - Whether to return raw data without processing\n\t * @returns {Array<Object>} Array of matching records (frozen if immutable mode)\n\t * @example\n\t * const users = store.find({department: 'engineering', active: true});\n\t * const admins = store.find({role: 'admin'});\n\t */\n\tfind (where = {}, raw = false) {\n\t\tconst key = Object.keys(where).sort(this.sortKeys).join(this.delimiter);\n\t\tconst index = this.indexes.get(key) ?? new Map();\n\t\tlet result = [];\n\t\tif (index.size > 0) {\n\t\t\tconst keys = this.indexKeys(key, this.delimiter, where);\n\t\t\tresult = Array.from(keys.reduce((a, v) => {\n\t\t\t\tif (index.has(v)) {\n\t\t\t\t\tindex.get(v).forEach(k => a.add(k));\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\t\t\t}, new Set())).map(i => this.get(i, raw));\n\t\t}\n\t\tif (!raw && this.immutable) {\n\t\t\tresult = Object.freeze(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Filters records using a predicate function, similar to Array.filter\n\t * @param {Function} fn - Predicate function to test each record (record, key, store)\n\t * @param {boolean} [raw=false] - Whether to return raw data without processing\n\t * @returns {Array<Object>} Array of records that pass the predicate test\n\t * @throws {Error} Throws error if fn is not a function\n\t * @example\n\t * const adults = store.filter(record => record.age >= 18);\n\t * const recent = store.filter(record => record.created > Date.now() - 86400000);\n\t */\n\tfilter (fn, raw = false) {\n\t\tif (typeof fn !== STRING_FUNCTION) {\n\t\t\tthrow new Error(STRING_INVALID_FUNCTION);\n\t\t}\n\t\tlet result = this.reduce((a, v) => {\n\t\t\tif (fn(v)) {\n\t\t\t\ta.push(v);\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}, []);\n\t\tif (!raw) {\n\t\t\tresult = result.map(i => this.list(i));\n\n\t\t\tif (this.immutable) {\n\t\t\t\tresult = Object.freeze(result);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Executes a function for each record in the store, similar to Array.forEach\n\t * @param {Function} fn - Function to execute for each record (value, key)\n\t * @param {*} [ctx] - Context object to use as 'this' when executing the function\n\t * @returns {Haro} This instance for method chaining\n\t * @example\n\t * store.forEach((record, key) => {\n\t *   console.log(`${key}: ${record.name}`);\n\t * });\n\t */\n\tforEach (fn, ctx = this) {\n\t\tthis.data.forEach((value, key) => {\n\t\t\tif (this.immutable) {\n\t\t\t\tvalue = this.clone(value);\n\t\t\t}\n\t\t\tfn.call(ctx, value, key);\n\t\t}, this);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a frozen array from the given arguments for immutable data handling\n\t * @param {...*} args - Arguments to freeze into an array\n\t * @returns {Array<*>} Frozen array containing frozen arguments\n\t * @example\n\t * const frozen = store.freeze(obj1, obj2, obj3);\n\t * // Returns Object.freeze([Object.freeze(obj1), Object.freeze(obj2), Object.freeze(obj3)])\n\t */\n\tfreeze (...args) {\n\t\treturn Object.freeze(args.map(i => Object.freeze(i)));\n\t}\n\n\t/**\n\t * Retrieves a record by its key\n\t * @param {string} key - Key of record to retrieve\n\t * @param {boolean} [raw=false] - Whether to return raw data (true) or processed/frozen data (false)\n\t * @returns {Object|null} The record if found, null if not found\n\t * @example\n\t * const user = store.get('user123');\n\t * const rawUser = store.get('user123', true);\n\t */\n\tget (key, raw = false) {\n\t\tlet result = this.data.get(key) ?? null;\n\t\tif (result !== null && !raw) {\n\t\t\tresult = this.list(result);\n\t\t\tif (this.immutable) {\n\t\t\t\tresult = Object.freeze(result);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Checks if a record with the specified key exists in the store\n\t * @param {string} key - Key to check for existence\n\t * @returns {boolean} True if record exists, false otherwise\n\t * @example\n\t * if (store.has('user123')) {\n\t *   console.log('User exists');\n\t * }\n\t */\n\thas (key) {\n\t\treturn this.data.has(key);\n\t}\n\n\t/**\n\t * Generates index keys for composite indexes from data values\n\t * @param {string} [arg=STRING_EMPTY] - Composite index field names joined by delimiter\n\t * @param {string} [delimiter=STRING_PIPE] - Delimiter used in composite index\n\t * @param {Object} [data={}] - Data object to extract field values from\n\t * @returns {string[]} Array of generated index keys\n\t * @example\n\t * // For index 'name|department' with data {name: 'John', department: 'IT'}\n\t * const keys = store.indexKeys('name|department', '|', data);\n\t * // Returns ['John|IT']\n\t */\n\tindexKeys (arg = STRING_EMPTY, delimiter = STRING_PIPE, data = {}) {\n\t\tconst fields = arg.split(delimiter).sort(this.sortKeys);\n\t\tconst fieldsLen = fields.length;\n\t\tlet result = [\"\"];\n\t\tfor (let i = 0; i < fieldsLen; i++) {\n\t\t\tconst field = fields[i];\n\t\t\tconst values = Array.isArray(data[field]) ? data[field] : [data[field]];\n\t\t\tconst newResult = [];\n\t\t\tconst resultLen = result.length;\n\t\t\tconst valuesLen = values.length;\n\t\t\tfor (let j = 0; j < resultLen; j++) {\n\t\t\t\tfor (let k = 0; k < valuesLen; k++) {\n\t\t\t\t\tconst newKey = i === 0 ? values[k] : `${result[j]}${delimiter}${values[k]}`;\n\t\t\t\t\tnewResult.push(newKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = newResult;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns an iterator of all keys in the store\n\t * @returns {Iterator<string>} Iterator of record keys\n\t * @example\n\t * for (const key of store.keys()) {\n\t *   console.log(key);\n\t * }\n\t */\n\tkeys () {\n\t\treturn this.data.keys();\n\t}\n\n\t/**\n\t * Returns a limited subset of records with offset support for pagination\n\t * @param {number} [offset=INT_0] - Number of records to skip from the beginning\n\t * @param {number} [max=INT_0] - Maximum number of records to return\n\t * @param {boolean} [raw=false] - Whether to return raw data without processing\n\t * @returns {Array<Object>} Array of records within the specified range\n\t * @example\n\t * const page1 = store.limit(0, 10);   // First 10 records\n\t * const page2 = store.limit(10, 10);  // Next 10 records\n\t */\n\tlimit (offset = INT_0, max = INT_0, raw = false) {\n\t\tlet result = this.registry.slice(offset, offset + max).map(i => this.get(i, raw));\n\t\tif (!raw && this.immutable) {\n\t\t\tresult = Object.freeze(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Converts a record into a [key, value] pair array format\n\t * @param {Object} arg - Record object to convert to list format\n\t * @returns {Array<*>} Array containing [key, record] where key is extracted from record's key field\n\t * @example\n\t * const record = {id: 'user123', name: 'John', age: 30};\n\t * const pair = store.list(record); // ['user123', {id: 'user123', name: 'John', age: 30}]\n\t */\n\tlist (arg) {\n\t\tconst result = [arg[this.key], arg];\n\n\t\treturn this.immutable ? this.freeze(...result) : result;\n\t}\n\n\t/**\n\t * Transforms all records using a mapping function, similar to Array.map\n\t * @param {Function} fn - Function to transform each record (record, key)\n\t * @param {boolean} [raw=false] - Whether to return raw data without processing\n\t * @returns {Array<*>} Array of transformed results\n\t * @throws {Error} Throws error if fn is not a function\n\t * @example\n\t * const names = store.map(record => record.name);\n\t * const summaries = store.map(record => ({id: record.id, name: record.name}));\n\t */\n\tmap (fn, raw = false) {\n\t\tif (typeof fn !== STRING_FUNCTION) {\n\t\t\tthrow new Error(STRING_INVALID_FUNCTION);\n\t\t}\n\t\tlet result = [];\n\t\tthis.forEach((value, key) => result.push(fn(value, key)));\n\t\tif (!raw) {\n\t\t\tresult = result.map(i => this.list(i));\n\t\t\tif (this.immutable) {\n\t\t\t\tresult = Object.freeze(result);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Merges two values together with support for arrays and objects\n\t * @param {*} a - First value (target)\n\t * @param {*} b - Second value (source)\n\t * @param {boolean} [override=false] - Whether to override arrays instead of concatenating\n\t * @returns {*} Merged result\n\t * @example\n\t * const merged = store.merge({a: 1}, {b: 2}); // {a: 1, b: 2}\n\t * const arrays = store.merge([1, 2], [3, 4]); // [1, 2, 3, 4]\n\t */\n\tmerge (a, b, override = false) {\n\t\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\t\ta = override ? b : a.concat(b);\n\t\t} else if (typeof a === STRING_OBJECT && a !== null && typeof b === STRING_OBJECT && b !== null) {\n\t\t\tthis.each(Object.keys(b), i => {\n\t\t\t\ta[i] = this.merge(a[i], b[i], override);\n\t\t\t});\n\t\t} else {\n\t\t\ta = b;\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Lifecycle hook executed after batch operations for custom postprocessing\n\t * @param {Array<Object>} arg - Result of batch operation\n\t * @param {string} [type=STRING_EMPTY] - Type of batch operation that was performed\n\t * @returns {Array<Object>} Modified result (override this method to implement custom logic)\n\t */\n\tonbatch (arg, type = STRING_EMPTY) { // eslint-disable-line no-unused-vars\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Lifecycle hook executed after clear operation for custom postprocessing\n\t * @returns {void} Override this method in subclasses to implement custom logic\n\t * @example\n\t * class MyStore extends Haro {\n\t *   onclear() {\n\t *     console.log('Store cleared');\n\t *   }\n\t * }\n\t */\n\tonclear () {\n\t\t// Hook for custom logic after clear; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed after delete operation for custom postprocessing\n\t * @param {string} [key=STRING_EMPTY] - Key of deleted record\n\t * @param {boolean} [batch=false] - Whether this was part of a batch operation\n\t * @returns {void} Override this method in subclasses to implement custom logic\n\t */\n\tondelete (key = STRING_EMPTY, batch = false) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic after delete; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed after override operation for custom postprocessing\n\t * @param {string} [type=STRING_EMPTY] - Type of override operation that was performed\n\t * @returns {void} Override this method in subclasses to implement custom logic\n\t */\n\tonoverride (type = STRING_EMPTY) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic after override; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed after set operation for custom postprocessing\n\t * @param {Object} [arg={}] - Record that was set\n\t * @param {boolean} [batch=false] - Whether this was part of a batch operation\n\t * @returns {void} Override this method in subclasses to implement custom logic\n\t */\n\tonset (arg = {}, batch = false) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic after set; override in subclass if needed\n\t}\n\n\t/**\n\t * Replaces all store data or indexes with new data for bulk operations\n\t * @param {Array<Array>} data - Data to replace with (format depends on type)\n\t * @param {string} [type=STRING_RECORDS] - Type of data: 'records' or 'indexes'\n\t * @returns {boolean} True if operation succeeded\n\t * @throws {Error} Throws error if type is invalid\n\t * @example\n\t * const records = [['key1', {name: 'John'}], ['key2', {name: 'Jane'}]];\n\t * store.override(records, 'records');\n\t */\n\toverride (data, type = STRING_RECORDS) {\n\t\tconst result = true;\n\t\tif (type === STRING_INDEXES) {\n\t\t\tthis.indexes = new Map(data.map(i => [i[0], new Map(i[1].map(ii => [ii[0], new Set(ii[1])]))]));\n\t\t} else if (type === STRING_RECORDS) {\n\t\t\tthis.indexes.clear();\n\t\t\tthis.data = new Map(data);\n\t\t} else {\n\t\t\tthrow new Error(STRING_INVALID_TYPE);\n\t\t}\n\t\tthis.onoverride(type);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Reduces all records to a single value using a reducer function\n\t * @param {Function} fn - Reducer function (accumulator, value, key, store)\n\t * @param {*} [accumulator] - Initial accumulator value\n\t * @returns {*} Final reduced value\n\t * @example\n\t * const totalAge = store.reduce((sum, record) => sum + record.age, 0);\n\t * const names = store.reduce((acc, record) => acc.concat(record.name), []);\n\t */\n\treduce (fn, accumulator = []) {\n\t\tlet a = accumulator;\n\t\tthis.forEach((v, k) => {\n\t\t\ta = fn(a, v, k, this);\n\t\t}, this);\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Rebuilds indexes for specified fields or all fields for data consistency\n\t * @param {string|string[]} [index] - Specific index field(s) to rebuild, or all if not specified\n\t * @returns {Haro} This instance for method chaining\n\t * @example\n\t * store.reindex(); // Rebuild all indexes\n\t * store.reindex('name'); // Rebuild only name index\n\t * store.reindex(['name', 'email']); // Rebuild name and email indexes\n\t */\n\treindex (index) {\n\t\tconst indices = index ? [index] : this.index;\n\t\tif (index && this.index.includes(index) === false) {\n\t\t\tthis.index.push(index);\n\t\t}\n\t\tthis.each(indices, i => this.indexes.set(i, new Map()));\n\t\tthis.forEach((data, key) => this.each(indices, i => this.setIndex(key, data, i)));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Searches for records containing a value across specified indexes\n\t * @param {*} value - Value to search for (string, function, or RegExp)\n\t * @param {string|string[]} [index] - Index(es) to search in, or all if not specified\n\t * @param {boolean} [raw=false] - Whether to return raw data without processing\n\t * @returns {Array<Object>} Array of matching records\n\t * @example\n\t * const results = store.search('john'); // Search all indexes\n\t * const nameResults = store.search('john', 'name'); // Search only name index\n\t * const regexResults = store.search(/^admin/, 'role'); // Regex search\n\t */\n\tsearch (value, index, raw = false) {\n\t\tconst result = new Set(); // Use Set for unique keys\n\t\tconst fn = typeof value === STRING_FUNCTION;\n\t\tconst rgex = value && typeof value.test === STRING_FUNCTION;\n\t\tif (!value) return this.immutable ? this.freeze() : [];\n\t\tconst indices = index ? Array.isArray(index) ? index : [index] : this.index;\n\t\tfor (const i of indices) {\n\t\t\tconst idx = this.indexes.get(i);\n\t\t\tif (idx) {\n\t\t\t\tfor (const [lkey, lset] of idx) {\n\t\t\t\t\tlet match = false;\n\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\tmatch = value(lkey, i);\n\t\t\t\t\t} else if (rgex) {\n\t\t\t\t\t\tmatch = value.test(Array.isArray(lkey) ? lkey.join(STRING_COMMA) : lkey);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = lkey === value;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tfor (const key of lset) {\n\t\t\t\t\t\t\tif (this.data.has(key)) {\n\t\t\t\t\t\t\t\tresult.add(key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet records = Array.from(result).map(key => this.get(key, raw));\n\t\tif (!raw && this.immutable) {\n\t\t\trecords = Object.freeze(records);\n\t\t}\n\n\t\treturn records;\n\t}\n\n\t/**\n\t * Sets or updates a record in the store with automatic indexing\n\t * @param {string|null} [key=null] - Key for the record, or null to use record's key field\n\t * @param {Object} [data={}] - Record data to set\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @param {boolean} [override=false] - Whether to override existing data instead of merging\n\t * @returns {Object} The stored record (frozen if immutable mode)\n\t * @example\n\t * const user = store.set(null, {name: 'John', age: 30}); // Auto-generate key\n\t * const updated = store.set('user123', {age: 31}); // Update existing record\n\t */\n\tset (key = null, data = {}, batch = false, override = false) {\n\t\tif (key === null) {\n\t\t\tkey = data[this.key] ?? this.uuid();\n\t\t}\n\t\tlet x = {...data, [this.key]: key};\n\t\tthis.beforeSet(key, x, batch, override);\n\t\tif (!this.data.has(key)) {\n\t\t\tif (this.versioning) {\n\t\t\t\tthis.versions.set(key, new Set());\n\t\t\t}\n\t\t} else {\n\t\t\tconst og = this.get(key, true);\n\t\t\tthis.deleteIndex(key, og);\n\t\t\tif (this.versioning) {\n\t\t\t\tthis.versions.get(key).add(Object.freeze(this.clone(og)));\n\t\t\t}\n\t\t\tif (!override) {\n\t\t\t\tx = this.merge(this.clone(og), x);\n\t\t\t}\n\t\t}\n\t\tthis.data.set(key, x);\n\t\tthis.setIndex(key, x, null);\n\t\tconst result = this.get(key);\n\t\tthis.onset(result, batch);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Internal method to add entries to indexes for a record\n\t * @param {string} key - Key of record being indexed\n\t * @param {Object} data - Data of record being indexed\n\t * @param {string|null} indice - Specific index to update, or null for all\n\t * @returns {Haro} This instance for method chaining\n\t */\n\tsetIndex (key, data, indice) {\n\t\tthis.each(indice === null ? this.index : [indice], i => {\n\t\t\tlet idx = this.indexes.get(i);\n\t\t\tif (!idx) {\n\t\t\t\tidx = new Map();\n\t\t\t\tthis.indexes.set(i, idx);\n\t\t\t}\n\t\t\tconst fn = c => {\n\t\t\t\tif (!idx.has(c)) {\n\t\t\t\t\tidx.set(c, new Set());\n\t\t\t\t}\n\t\t\t\tidx.get(c).add(key);\n\t\t\t};\n\t\t\tif (i.includes(this.delimiter)) {\n\t\t\t\tthis.each(this.indexKeys(i, this.delimiter, data), fn);\n\t\t\t} else {\n\t\t\t\tthis.each(Array.isArray(data[i]) ? data[i] : [data[i]], fn);\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sorts all records using a comparator function\n\t * @param {Function} fn - Comparator function for sorting (a, b) => number\n\t * @param {boolean} [frozen=false] - Whether to return frozen records\n\t * @returns {Array<Object>} Sorted array of records\n\t * @example\n\t * const sorted = store.sort((a, b) => a.age - b.age); // Sort by age\n\t * const names = store.sort((a, b) => a.name.localeCompare(b.name)); // Sort by name\n\t */\n\tsort (fn, frozen = false) {\n\t\tconst dataSize = this.data.size;\n\t\tlet result = this.limit(INT_0, dataSize, true).sort(fn);\n\t\tif (frozen) {\n\t\t\tresult = this.freeze(...result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Comparator function for sorting keys with type-aware comparison logic\n\t * @param {*} a - First value to compare\n\t * @param {*} b - Second value to compare\n\t * @returns {number} Negative number if a < b, positive if a > b, zero if equal\n\t * @example\n\t * const keys = ['name', 'age', 'email'];\n\t * keys.sort(store.sortKeys); // Alphabetical sort\n\t *\n\t * const mixed = [10, '5', 'abc', 3];\n\t * mixed.sort(store.sortKeys); // Type-aware sort: numbers first, then strings\n\t */\n\tsortKeys (a, b) {\n\t\t// Handle string comparison\n\t\tif (typeof a === STRING_STRING && typeof b === STRING_STRING) {\n\t\t\treturn a.localeCompare(b);\n\t\t}\n\t\t// Handle numeric comparison\n\t\tif (typeof a === STRING_NUMBER && typeof b === STRING_NUMBER) {\n\t\t\treturn a - b;\n\t\t}\n\n\t\t// Handle mixed types or other types by converting to string\n\n\t\treturn String(a).localeCompare(String(b));\n\t}\n\n\t/**\n\t * Sorts records by a specific indexed field in ascending order\n\t * @param {string} [index=STRING_EMPTY] - Index field name to sort by\n\t * @param {boolean} [raw=false] - Whether to return raw data without processing\n\t * @returns {Array<Object>} Array of records sorted by the specified field\n\t * @throws {Error} Throws error if index field is empty or invalid\n\t * @example\n\t * const byAge = store.sortBy('age');\n\t * const byName = store.sortBy('name');\n\t */\n\tsortBy (index = STRING_EMPTY, raw = false) {\n\t\tif (index === STRING_EMPTY) {\n\t\t\tthrow new Error(STRING_INVALID_FIELD);\n\t\t}\n\t\tlet result = [];\n\t\tconst keys = [];\n\t\tif (this.indexes.has(index) === false) {\n\t\t\tthis.reindex(index);\n\t\t}\n\t\tconst lindex = this.indexes.get(index);\n\t\tlindex.forEach((idx, key) => keys.push(key));\n\t\tthis.each(keys.sort(this.sortKeys), i => lindex.get(i).forEach(key => result.push(this.get(key, raw))));\n\t\tif (this.immutable) {\n\t\t\tresult = Object.freeze(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Converts all store data to a plain array of records\n\t * @returns {Array<Object>} Array containing all records in the store\n\t * @example\n\t * const allRecords = store.toArray();\n\t * console.log(`Store contains ${allRecords.length} records`);\n\t */\n\ttoArray () {\n\t\tconst result = Array.from(this.data.values());\n\t\tif (this.immutable) {\n\t\t\tthis.each(result, i => Object.freeze(i));\n\t\t\tObject.freeze(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Generates a RFC4122 v4 UUID for record identification\n\t * @returns {string} UUID string in standard format\n\t * @example\n\t * const id = store.uuid(); // \"f47ac10b-58cc-4372-a567-0e02b2c3d479\"\n\t */\n\tuuid () {\n\t\treturn uuid();\n\t}\n\n\t/**\n\t * Returns an iterator of all values in the store\n\t * @returns {Iterator<Object>} Iterator of record values\n\t * @example\n\t * for (const record of store.values()) {\n\t *   console.log(record.name);\n\t * }\n\t */\n\tvalues () {\n\t\treturn this.data.values();\n\t}\n\n\t/**\n\t * Internal helper method for predicate matching with support for arrays and regex\n\t * @param {Object} record - Record to test against predicate\n\t * @param {Object} predicate - Predicate object with field-value pairs\n\t * @param {string} op - Operator for array matching ('||' for OR, '&&' for AND)\n\t * @returns {boolean} True if record matches predicate criteria\n\t */\n\tmatchesPredicate (record, predicate, op) {\n\t\tconst keys = Object.keys(predicate);\n\n\t\treturn keys.every(key => {\n\t\t\tconst pred = predicate[key];\n\t\t\tconst val = record[key];\n\t\t\tif (Array.isArray(pred)) {\n\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\treturn op === STRING_DOUBLE_AND ? pred.every(p => val.includes(p)) : pred.some(p => val.includes(p));\n\t\t\t\t} else {\n\t\t\t\t\treturn op === STRING_DOUBLE_AND ? pred.every(p => val === p) : pred.some(p => val === p);\n\t\t\t\t}\n\t\t\t} else if (pred instanceof RegExp) {\n\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\treturn op === STRING_DOUBLE_AND ? val.every(v => pred.test(v)) : val.some(v => pred.test(v));\n\t\t\t\t} else {\n\t\t\t\t\treturn pred.test(val);\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(val)) {\n\t\t\t\treturn val.includes(pred);\n\t\t\t} else {\n\t\t\t\treturn val === pred;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Advanced filtering with predicate logic supporting AND/OR operations on arrays\n\t * @param {Object} [predicate={}] - Object with field-value pairs for filtering\n\t * @param {string} [op=STRING_DOUBLE_PIPE] - Operator for array matching ('||' for OR, '&&' for AND)\n\t * @returns {Array<Object>} Array of records matching the predicate criteria\n\t * @example\n\t * // Find records with tags containing 'admin' OR 'user'\n\t * const users = store.where({tags: ['admin', 'user']}, '||');\n\t *\n\t * // Find records with ALL specified tags\n\t * const powerUsers = store.where({tags: ['admin', 'power']}, '&&');\n\t *\n\t * // Regex matching\n\t * const emails = store.where({email: /^admin@/});\n\t */\n\twhere (predicate = {}, op = STRING_DOUBLE_PIPE) {\n\t\tconst keys = this.index.filter(i => i in predicate);\n\t\tif (keys.length === 0) return [];\n\n\t\t// Try to use indexes for better performance\n\t\tconst indexedKeys = keys.filter(k => this.indexes.has(k));\n\t\tif (indexedKeys.length > 0) {\n\t\t\t// Use index-based filtering for better performance\n\t\t\tlet candidateKeys = new Set();\n\t\t\tlet first = true;\n\t\t\tfor (const key of indexedKeys) {\n\t\t\t\tconst pred = predicate[key];\n\t\t\t\tconst idx = this.indexes.get(key);\n\t\t\t\tconst matchingKeys = new Set();\n\t\t\t\tif (Array.isArray(pred)) {\n\t\t\t\t\tfor (const p of pred) {\n\t\t\t\t\t\tif (idx.has(p)) {\n\t\t\t\t\t\t\tfor (const k of idx.get(p)) {\n\t\t\t\t\t\t\t\tmatchingKeys.add(k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (idx.has(pred)) {\n\t\t\t\t\tfor (const k of idx.get(pred)) {\n\t\t\t\t\t\tmatchingKeys.add(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (first) {\n\t\t\t\t\tcandidateKeys = matchingKeys;\n\t\t\t\t\tfirst = false;\n\t\t\t\t} else {\n\t\t\t\t\t// AND operation across different fields\n\t\t\t\t\tcandidateKeys = new Set([...candidateKeys].filter(k => matchingKeys.has(k)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Filter candidates with full predicate logic\n\t\t\tconst results = [];\n\t\t\tfor (const key of candidateKeys) {\n\t\t\t\tconst record = this.get(key, true);\n\t\t\t\tif (this.matchesPredicate(record, predicate, op)) {\n\t\t\t\t\tresults.push(this.immutable ? this.get(key) : record);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.immutable ? this.freeze(...results) : results;\n\t\t}\n\n\t\t// Fallback to full scan if no indexes available\n\t\treturn this.filter(a => this.matchesPredicate(a, predicate, op));\n\t}\n}\n\n/**\n * Factory function to create a new Haro instance with optional initial data\n * @param {Array<Object>|null} [data=null] - Initial data to populate the store\n * @param {Object} [config={}] - Configuration object passed to Haro constructor\n * @returns {Haro} New Haro instance configured and optionally populated\n * @example\n * const store = haro([\n *   {id: 1, name: 'John', age: 30},\n *   {id: 2, name: 'Jane', age: 25}\n * ], {\n *   index: ['name', 'age'],\n *   versioning: true\n * });\n */\nexport function haro (data = null, config = {}) {\n\tconst obj = new Haro(config);\n\n\tif (Array.isArray(data)) {\n\t\tobj.batch(data, STRING_SET);\n\t}\n\n\treturn obj;\n}\n"],"names":["randomUUID","STRING_EMPTY","STRING_DOUBLE_AND","STRING_FUNCTION","STRING_OBJECT","STRING_RECORDS","STRING_STRING","STRING_NUMBER","STRING_INVALID_FUNCTION","Haro","constructor","delimiter","id","this","uuid","immutable","index","key","versioning","data","Map","Array","isArray","indexes","versions","Object","defineProperty","enumerable","get","from","keys","size","reindex","batch","args","type","fn","i","delete","set","onbatch","beforeBatch","map","arg","beforeClear","beforeDelete","beforeSet","override","clear","onclear","clone","structuredClone","has","Error","og","deleteIndex","ondelete","forEach","idx","values","includes","indexKeys","each","value","o","dump","result","entries","ii","arr","len","length","find","where","raw","sort","sortKeys","join","reduce","a","v","k","add","Set","freeze","filter","push","list","ctx","call","fields","split","fieldsLen","field","newResult","resultLen","valuesLen","j","newKey","limit","offset","max","registry","slice","merge","b","concat","onoverride","onset","accumulator","indices","setIndex","search","rgex","test","lkey","lset","match","records","x","indice","c","frozen","dataSize","localeCompare","String","sortBy","lindex","toArray","matchesPredicate","record","predicate","op","every","pred","val","p","some","RegExp","indexedKeys","candidateKeys","first","matchingKeys","results","haro","config","obj"],"mappings":"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"}