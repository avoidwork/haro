{"version":3,"file":"haro.min.js","sources":["../src/constants.js","../src/haro.js"],"sourcesContent":["// String constants - Single characters and symbols\nexport const STRING_COMMA = \",\";\nexport const STRING_EMPTY = \"\";\nexport const STRING_PIPE = \"|\";\nexport const STRING_DOUBLE_PIPE = \"||\";\n\n// String constants - Single letters\nexport const STRING_A = \"a\";\nexport const STRING_B = \"b\";\n\n// String constants - Operation and type names\nexport const STRING_DEL = \"del\";\nexport const STRING_FUNCTION = \"function\";\nexport const STRING_INDEXES = \"indexes\";\nexport const STRING_OBJECT = \"object\";\nexport const STRING_RECORDS = \"records\";\nexport const STRING_REGISTRY = \"registry\";\nexport const STRING_SET = \"set\";\nexport const STRING_SIZE = \"size\";\n\n// String constants - Error messages\nexport const STRING_INVALID_FIELD = \"Invalid field\";\nexport const STRING_INVALID_FUNCTION = \"Invalid function\";\nexport const STRING_INVALID_TYPE = \"Invalid type\";\nexport const STRING_RECORD_NOT_FOUND = \"Record not found\";\n\n// Integer constants\nexport const INT_0 = 0;\nexport const INT_1 = 1;\nexport const INT_3 = 3;\nexport const INT_4 = 4;\nexport const INT_8 = 8;\nexport const INT_9 = 9;\nexport const INT_16 = 16;\n","import {randomUUID as uuid} from \"crypto\";\nimport {\n\tINT_0,\n\tSTRING_COMMA,\n\tSTRING_DEL,\n\tSTRING_DOUBLE_PIPE,\n\tSTRING_EMPTY,\n\tSTRING_FUNCTION,\n\tSTRING_INDEXES,\n\tSTRING_INVALID_FIELD,\n\tSTRING_INVALID_FUNCTION,\n\tSTRING_INVALID_TYPE,\n\tSTRING_PIPE,\n\tSTRING_RECORD_NOT_FOUND,\n\tSTRING_RECORDS,\n\tSTRING_REGISTRY,\n\tSTRING_SET,\n\tSTRING_SIZE\n} from \"./constants.js\";\n\n/**\n * Haro is a modern immutable DataStore for collections of records with indexing,\n * versioning, and batch operations support. It provides a Map-like interface\n * with advanced querying capabilities through indexes.\n * @class\n * @example\n * const store = new Haro({\n *   index: ['name', 'age'],\n *   key: 'id',\n *   versioning: true\n * });\n *\n * store.set(null, {name: 'John', age: 30});\n * const results = store.find({name: 'John'});\n */\nexport class Haro {\n\t/**\n\t * Creates a new Haro instance with specified configuration\n\t * @param {Object} [config={}] - Configuration object for the store\n\t * @param {string} [config.delimiter=STRING_PIPE] - Delimiter for composite indexes (default: '|')\n\t * @param {string} [config.id] - Unique identifier for this instance (auto-generated if not provided)\n\t * @param {boolean} [config.immutable=false] - Return frozen/immutable objects for data safety\n\t * @param {string[]} [config.index=[]] - Array of field names to create indexes for\n\t * @param {string} [config.key=\"id\"] - Primary key field name used for record identification\n\t * @param {boolean} [config.versioning=false] - Enable versioning to track record changes\n\t * @constructor\n\t * @example\n\t * const store = new Haro({\n\t *   index: ['name', 'email', 'name|department'],\n\t *   key: 'userId',\n\t *   versioning: true,\n\t *   immutable: true\n\t * });\n\t */\n\tconstructor ({delimiter = STRING_PIPE, id = this.uuid(), immutable = false, index = [], key = \"id\", versioning = false} = {}) {\n\t\tthis.data = new Map();\n\t\tthis.delimiter = delimiter;\n\t\tthis.id = id;\n\t\tthis.immutable = immutable;\n\t\tthis.index = Array.isArray(index) ? [...index] : [];\n\t\tthis.indexes = new Map();\n\t\tthis.key = key;\n\t\tthis.versions = new Map();\n\t\tthis.versioning = versioning;\n\t\tObject.defineProperty(this, STRING_REGISTRY, {\n\t\t\tenumerable: true,\n\t\t\tget: () => Array.from(this.data.keys())\n\t\t});\n\t\tObject.defineProperty(this, STRING_SIZE, {\n\t\t\tenumerable: true,\n\t\t\tget: () => this.data.size\n\t\t});\n\n\t\treturn this.reindex();\n\t}\n\n\t/**\n\t * Performs batch operations on multiple records for efficient bulk processing\n\t * @param {Array<Object>} args - Array of records to process\n\t * @param {string} [type=STRING_SET] - Type of operation: 'set' for upsert, 'del' for delete\n\t * @returns {Array<Object>} Array of results from the batch operation\n\t * @throws {Error} Throws error if individual operations fail during batch processing\n\t * @example\n\t * const results = store.batch([\n\t *   {id: 1, name: 'John'},\n\t *   {id: 2, name: 'Jane'}\n\t * ], 'set');\n\t */\n\tbatch (args, type = STRING_SET) {\n\t\tconst fn = type === STRING_DEL ? i => this.delete(i, true) : i => this.set(null, i, true, true);\n\n\t\treturn this.onbatch(this.beforeBatch(args, type).map(fn), type);\n\t}\n\n\t/**\n\t * Lifecycle hook executed before batch operations for custom preprocessing\n\t * @param {Array<Object>} arg - Arguments passed to batch operation\n\t * @param {string} [type=STRING_EMPTY] - Type of batch operation ('set' or 'del')\n\t * @returns {Array<Object>} Modified arguments (override this method to implement custom logic)\n\t */\n\tbeforeBatch (arg, type = STRING_EMPTY) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic before batch; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed before clear operation for custom preprocessing\n\t * @returns {void}\n\t * Override this method in subclasses to implement custom logic\n\t * @example\n\t * class MyStore extends Haro {\n\t *   beforeClear() {\n\t *     this.backup = this.toArray();\n\t *   }\n\t * }\n\t */\n\tbeforeClear () {\n\t\t// Hook for custom logic before clear; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed before delete operation for custom preprocessing\n\t * @param {string} [key=STRING_EMPTY] - Key of record to delete\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @returns {Array<string|boolean>} Array containing [key, batch] for further processing\n\t */\n\tbeforeDelete (key = STRING_EMPTY, batch = false) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic before delete; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed before set operation for custom preprocessing\n\t * @param {string} [key=STRING_EMPTY] - Key of record to set\n\t * @param {Object} data - Record data being set\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @param {boolean} [override=false] - Whether to override existing data\n\t * @returns {Array<string|boolean>} Array containing [key, batch] for further processing\n\t */\n\tbeforeSet (key = STRING_EMPTY, data, batch = false, override = false) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic before set; override in subclass if needed\n\t}\n\n\t/**\n\t * Removes all records, indexes, and versions from the store\n\t * @returns {Haro} This instance for method chaining\n\t * @example\n\t * store.clear();\n\t * console.log(store.size); // 0\n\t */\n\tclear () {\n\t\tthis.beforeClear();\n\t\tthis.data.clear();\n\t\tthis.indexes.clear();\n\t\tthis.versions.clear();\n\t\tthis.reindex().onclear();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a deep clone of the given value, handling objects, arrays, and primitives\n\t * @param {*} arg - Value to clone (any type)\n\t * @returns {*} Deep clone of the argument\n\t * @example\n\t * const original = {name: 'John', tags: ['user', 'admin']};\n\t * const cloned = store.clone(original);\n\t * cloned.tags.push('new'); // original.tags is unchanged\n\t */\n\tclone (arg) {\n\t\treturn structuredClone(arg);\n\t}\n\n\t/**\n\t * Deletes a record from the store and removes it from all indexes\n\t * @param {string} [key=STRING_EMPTY] - Key of record to delete\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @returns {void}\n\t * @throws {Error} Throws error if record with the specified key is not found\n\t * @example\n\t * store.delete('user123');\n\t * // Throws error if 'user123' doesn't exist\n\t */\n\tdelete (key = STRING_EMPTY, batch = false) {\n\t\tif (!this.data.has(key)) {\n\t\t\tthrow new Error(STRING_RECORD_NOT_FOUND);\n\t\t}\n\t\tconst og = this.get(key, true);\n\t\tthis.beforeDelete(key, batch);\n\t\tthis.deleteIndex(key, og);\n\t\tthis.data.delete(key);\n\t\tthis.ondelete(key, batch);\n\t\tif (this.versioning) {\n\t\t\tthis.versions.delete(key);\n\t\t}\n\t}\n\n\t/**\n\t * Internal method to remove entries from indexes for a deleted record\n\t * @param {string} key - Key of record being deleted\n\t * @param {Object} data - Data of record being deleted\n\t * @returns {Haro} This instance for method chaining\n\t */\n\tdeleteIndex (key, data) {\n\t\tthis.index.forEach(i => {\n\t\t\tconst idx = this.indexes.get(i);\n\t\t\tif (!idx) return;\n\t\t\tconst values = i.includes(this.delimiter) ?\n\t\t\t\tthis.indexKeys(i, this.delimiter, data) :\n\t\t\t\tArray.isArray(data[i]) ? data[i] : [data[i]];\n\t\t\tthis.each(values, value => {\n\t\t\t\tif (idx.has(value)) {\n\t\t\t\t\tconst o = idx.get(value);\n\t\t\t\t\to.delete(key);\n\t\t\t\t\tif (o.size === INT_0) {\n\t\t\t\t\t\tidx.delete(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Exports complete store data or indexes for persistence or debugging\n\t * @param {string} [type=STRING_RECORDS] - Type of data to export: 'records' or 'indexes'\n\t * @returns {Array<Array>} Array of [key, value] pairs for records, or serialized index structure\n\t * @example\n\t * const records = store.dump('records');\n\t * const indexes = store.dump('indexes');\n\t */\n\tdump (type = STRING_RECORDS) {\n\t\tlet result;\n\t\tif (type === STRING_RECORDS) {\n\t\t\tresult = Array.from(this.entries());\n\t\t} else {\n\t\t\tresult = Array.from(this.indexes).map(i => {\n\t\t\t\ti[1] = Array.from(i[1]).map(ii => {\n\t\t\t\t\tii[1] = Array.from(ii[1]);\n\n\t\t\t\t\treturn ii;\n\t\t\t\t});\n\n\t\t\t\treturn i;\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Utility method to iterate over an array with a callback function\n\t * @param {Array<*>} [arr=[]] - Array to iterate over\n\t * @param {Function} fn - Function to call for each element (element, index)\n\t * @returns {Array<*>} The original array for method chaining\n\t * @example\n\t * store.each([1, 2, 3], (item, index) => console.log(item, index));\n\t */\n\teach (arr = [], fn) {\n\t\tconst len = arr.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tfn(arr[i], i);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\t/**\n\t * Returns an iterator of [key, value] pairs for each record in the store\n\t * @returns {Iterator<Array<string|Object>>} Iterator of [key, value] pairs\n\t * @example\n\t * for (const [key, value] of store.entries()) {\n\t *   console.log(key, value);\n\t * }\n\t */\n\tentries () {\n\t\treturn this.data.entries();\n\t}\n\n\t/**\n\t * Finds records matching the specified criteria using indexes for optimal performance\n\t * @param {Object} [where={}] - Object with field-value pairs to match against\n\t * @param {boolean} [raw=false] - Whether to return raw data without processing\n\t * @returns {Array<Object>} Array of matching records (frozen if immutable mode)\n\t * @example\n\t * const users = store.find({department: 'engineering', active: true});\n\t * const admins = store.find({role: 'admin'});\n\t */\n\tfind (where = {}, raw = false) {\n\t\tconst key = Object.keys(where).sort((a, b) => a.localeCompare(b)).join(this.delimiter);\n\t\tconst index = this.indexes.get(key) ?? new Map();\n\t\tlet result = [];\n\t\tif (index.size > 0) {\n\t\t\tconst keys = this.indexKeys(key, this.delimiter, where);\n\t\t\tresult = Array.from(keys.reduce((a, v) => {\n\t\t\t\tif (index.has(v)) {\n\t\t\t\t\tindex.get(v).forEach(k => a.add(k));\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\t\t\t}, new Set())).map(i => this.get(i, raw));\n\t\t}\n\t\tif (!raw && this.immutable) {\n\t\t\tresult = Object.freeze(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Filters records using a predicate function, similar to Array.filter\n\t * @param {Function} fn - Predicate function to test each record (record, key, store)\n\t * @param {boolean} [raw=false] - Whether to return raw data without processing\n\t * @returns {Array<Object>} Array of records that pass the predicate test\n\t * @throws {Error} Throws error if fn is not a function\n\t * @example\n\t * const adults = store.filter(record => record.age >= 18);\n\t * const recent = store.filter(record => record.created > Date.now() - 86400000);\n\t */\n\tfilter (fn, raw = false) {\n\t\tif (typeof fn !== STRING_FUNCTION) {\n\t\t\tthrow new Error(STRING_INVALID_FUNCTION);\n\t\t}\n\t\tconst x = this.immutable ? (k, v) => Object.freeze([k, Object.freeze(v)]) : (k, v) => v;\n\t\tlet result = this.reduce((a, v, k, ctx) => {\n\t\t\tif (fn.call(ctx, v)) {\n\t\t\t\ta.push(x(k, v));\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}, []);\n\t\tif (!raw) {\n\t\t\tresult = result.map(i => this.list(i));\n\n\t\t\tif (this.immutable) {\n\t\t\t\tresult = Object.freeze(result);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Executes a function for each record in the store, similar to Array.forEach\n\t * @param {Function} fn - Function to execute for each record (value, key)\n\t * @param {*} [ctx] - Context object to use as 'this' when executing the function\n\t * @returns {Haro} This instance for method chaining\n\t * @example\n\t * store.forEach((record, key) => {\n\t *   console.log(`${key}: ${record.name}`);\n\t * });\n\t */\n\tforEach (fn, ctx) {\n\t\tthis.data.forEach((value, key) => {\n\t\t\tfn(this.clone(value), key); // Only clone value, key is primitive\n\t\t}, ctx ?? this.data);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a frozen array from the given arguments for immutable data handling\n\t * @param {...*} args - Arguments to freeze into an array\n\t * @returns {Array<*>} Frozen array containing frozen arguments\n\t * @example\n\t * const frozen = store.freeze(obj1, obj2, obj3);\n\t * // Returns Object.freeze([Object.freeze(obj1), Object.freeze(obj2), Object.freeze(obj3)])\n\t */\n\tfreeze (...args) {\n\t\treturn Object.freeze(args.map(i => Object.freeze(i)));\n\t}\n\n\t/**\n\t * Retrieves a record by its key\n\t * @param {string} key - Key of record to retrieve\n\t * @param {boolean} [raw=false] - Whether to return raw data (true) or processed/frozen data (false)\n\t * @returns {Object|null} The record if found, null if not found\n\t * @example\n\t * const user = store.get('user123');\n\t * const rawUser = store.get('user123', true);\n\t */\n\tget (key, raw = false) {\n\t\tlet result = this.data.get(key) ?? null;\n\t\tif (result !== null && !raw) {\n\t\t\tresult = this.list(result);\n\t\t\tif (this.immutable) {\n\t\t\t\tresult = Object.freeze(result);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Checks if a record with the specified key exists in the store\n\t * @param {string} key - Key to check for existence\n\t * @returns {boolean} True if record exists, false otherwise\n\t * @example\n\t * if (store.has('user123')) {\n\t *   console.log('User exists');\n\t * }\n\t */\n\thas (key) {\n\t\treturn this.data.has(key);\n\t}\n\n\t/**\n\t * Generates index keys for composite indexes from data values\n\t * @param {string} [arg=STRING_EMPTY] - Composite index field names joined by delimiter\n\t * @param {string} [delimiter=STRING_PIPE] - Delimiter used in composite index\n\t * @param {Object} [data={}] - Data object to extract field values from\n\t * @returns {string[]} Array of generated index keys\n\t * @example\n\t * // For index 'name|department' with data {name: 'John', department: 'IT'}\n\t * const keys = store.indexKeys('name|department', '|', data);\n\t * // Returns ['John|IT']\n\t */\n\tindexKeys (arg = STRING_EMPTY, delimiter = STRING_PIPE, data = {}) {\n\t\tconst fields = arg.split(delimiter).sort((a, b) => a.localeCompare(b));\n\t\tconst fieldsLen = fields.length;\n\t\tlet result = [\"\"];\n\t\tfor (let i = 0; i < fieldsLen; i++) {\n\t\t\tconst field = fields[i];\n\t\t\tconst values = Array.isArray(data[field]) ? data[field] : [data[field]];\n\t\t\tconst newResult = [];\n\t\t\tconst resultLen = result.length;\n\t\t\tconst valuesLen = values.length;\n\t\t\tfor (let j = 0; j < resultLen; j++) {\n\t\t\t\tfor (let k = 0; k < valuesLen; k++) {\n\t\t\t\t\tconst newKey = i === 0 ? values[k] : `${result[j]}${delimiter}${values[k]}`;\n\t\t\t\t\tnewResult.push(newKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = newResult;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns an iterator of all keys in the store\n\t * @returns {Iterator<string>} Iterator of record keys\n\t * @example\n\t * for (const key of store.keys()) {\n\t *   console.log(key);\n\t * }\n\t */\n\tkeys () {\n\t\treturn this.data.keys();\n\t}\n\n\t/**\n\t * Returns a limited subset of records with offset support for pagination\n\t * @param {number} [offset=INT_0] - Number of records to skip from the beginning\n\t * @param {number} [max=INT_0] - Maximum number of records to return\n\t * @param {boolean} [raw=false] - Whether to return raw data without processing\n\t * @returns {Array<Object>} Array of records within the specified range\n\t * @example\n\t * const page1 = store.limit(0, 10);   // First 10 records\n\t * const page2 = store.limit(10, 10);  // Next 10 records\n\t */\n\tlimit (offset = INT_0, max = INT_0, raw = false) {\n\t\tlet result = this.registry.slice(offset, offset + max).map(i => this.get(i, raw));\n\t\tif (!raw && this.immutable) {\n\t\t\tresult = Object.freeze(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Converts a record into a [key, value] pair array format\n\t * @param {Object} arg - Record object to convert to list format\n\t * @returns {Array<*>} Array containing [key, record] where key is extracted from record's key field\n\t * @example\n\t * const record = {id: 'user123', name: 'John', age: 30};\n\t * const pair = store.list(record); // ['user123', {id: 'user123', name: 'John', age: 30}]\n\t */\n\tlist (arg) {\n\t\tconst result = [arg[this.key], arg];\n\n\t\treturn this.immutable ? this.freeze(...result) : result;\n\t}\n\n\t/**\n\t * Transforms all records using a mapping function, similar to Array.map\n\t * @param {Function} fn - Function to transform each record (record, key)\n\t * @param {boolean} [raw=false] - Whether to return raw data without processing\n\t * @returns {Array<*>} Array of transformed results\n\t * @throws {Error} Throws error if fn is not a function\n\t * @example\n\t * const names = store.map(record => record.name);\n\t * const summaries = store.map(record => ({id: record.id, name: record.name}));\n\t */\n\tmap (fn, raw = false) {\n\t\tif (typeof fn !== STRING_FUNCTION) {\n\t\t\tthrow new Error(STRING_INVALID_FUNCTION);\n\t\t}\n\t\tlet result = [];\n\t\tthis.forEach((value, key) => result.push(fn(value, key)));\n\t\tif (!raw) {\n\t\t\tresult = result.map(i => this.list(i));\n\t\t\tif (this.immutable) {\n\t\t\t\tresult = Object.freeze(result);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Merges two values together with support for arrays and objects\n\t * @param {*} a - First value (target)\n\t * @param {*} b - Second value (source)\n\t * @param {boolean} [override=false] - Whether to override arrays instead of concatenating\n\t * @returns {*} Merged result\n\t * @example\n\t * const merged = store.merge({a: 1}, {b: 2}); // {a: 1, b: 2}\n\t * const arrays = store.merge([1, 2], [3, 4]); // [1, 2, 3, 4]\n\t */\n\tmerge (a, b, override = false) {\n\t\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\t\ta = override ? b : a.concat(b);\n\t\t} else if (typeof a === \"object\" && a !== null && typeof b === \"object\" && b !== null) {\n\t\t\tthis.each(Object.keys(b), i => {\n\t\t\t\ta[i] = this.merge(a[i], b[i], override);\n\t\t\t});\n\t\t} else {\n\t\t\ta = b;\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Lifecycle hook executed after batch operations for custom postprocessing\n\t * @param {Array<Object>} arg - Result of batch operation\n\t * @param {string} [type=STRING_EMPTY] - Type of batch operation that was performed\n\t * @returns {Array<Object>} Modified result (override this method to implement custom logic)\n\t */\n\tonbatch (arg, type = STRING_EMPTY) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic after batch; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed after clear operation for custom postprocessing\n\t * @returns {void}\n\t * Override this method in subclasses to implement custom logic\n\t * @example\n\t * class MyStore extends Haro {\n\t *   onclear() {\n\t *     console.log('Store cleared');\n\t *   }\n\t * }\n\t */\n\tonclear () {\n\t\t// Hook for custom logic after clear; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed after delete operation for custom postprocessing\n\t * @param {string} [key=STRING_EMPTY] - Key of deleted record\n\t * @param {boolean} [batch=false] - Whether this was part of a batch operation\n\t * @returns {Array<string|boolean>} Array containing [key, batch] for further processing\n\t */\n\tondelete (key = STRING_EMPTY, batch = false) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic after delete; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed after override operation for custom postprocessing\n\t * @param {string} [type=STRING_EMPTY] - Type of override operation that was performed\n\t * @returns {string} The type parameter for further processing\n\t */\n\tonoverride (type = STRING_EMPTY) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic after override; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed after set operation for custom postprocessing\n\t * @param {Object} [arg={}] - Record that was set\n\t * @param {boolean} [batch=false] - Whether this was part of a batch operation\n\t * @returns {Array<Object|boolean>} Array containing [record, batch] for further processing\n\t */\n\tonset (arg = {}, batch = false) { // eslint-disable-line no-unused-vars\n\t\t// Hook for custom logic after set; override in subclass if needed\n\t}\n\n\t/**\n\t * Replaces all store data or indexes with new data for bulk operations\n\t * @param {Array<Array>} data - Data to replace with (format depends on type)\n\t * @param {string} [type=STRING_RECORDS] - Type of data: 'records' or 'indexes'\n\t * @returns {boolean} True if operation succeeded\n\t * @throws {Error} Throws error if type is invalid\n\t * @example\n\t * const records = [['key1', {name: 'John'}], ['key2', {name: 'Jane'}]];\n\t * store.override(records, 'records');\n\t */\n\toverride (data, type = STRING_RECORDS) {\n\t\tconst result = true;\n\t\tif (type === STRING_INDEXES) {\n\t\t\tthis.indexes = new Map(data.map(i => [i[0], new Map(i[1].map(ii => [ii[0], new Set(ii[1])]))]));\n\t\t} else if (type === STRING_RECORDS) {\n\t\t\tthis.indexes.clear();\n\t\t\tthis.data = new Map(data);\n\t\t} else {\n\t\t\tthrow new Error(STRING_INVALID_TYPE);\n\t\t}\n\t\tthis.onoverride(type);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Reduces all records to a single value using a reducer function\n\t * @param {Function} fn - Reducer function (accumulator, value, key, store)\n\t * @param {*} [accumulator] - Initial accumulator value\n\t * @returns {*} Final reduced value\n\t * @example\n\t * const totalAge = store.reduce((sum, record) => sum + record.age, 0);\n\t * const names = store.reduce((acc, record) => acc.concat(record.name), []);\n\t */\n\treduce (fn, accumulator) {\n\t\tlet a = accumulator ?? this.data.keys().next().value;\n\t\tthis.forEach((v, k) => {\n\t\t\ta = fn(a, v, k, this);\n\t\t}, this);\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Rebuilds indexes for specified fields or all fields for data consistency\n\t * @param {string|string[]} [index] - Specific index field(s) to rebuild, or all if not specified\n\t * @returns {Haro} This instance for method chaining\n\t * @example\n\t * store.reindex(); // Rebuild all indexes\n\t * store.reindex('name'); // Rebuild only name index\n\t * store.reindex(['name', 'email']); // Rebuild name and email indexes\n\t */\n\treindex (index) {\n\t\tconst indices = index ? [index] : this.index;\n\t\tif (index && this.index.includes(index) === false) {\n\t\t\tthis.index.push(index);\n\t\t}\n\t\tthis.each(indices, i => this.indexes.set(i, new Map()));\n\t\tthis.forEach((data, key) => this.each(indices, i => this.setIndex(key, data, i)));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Searches for records containing a value across specified indexes\n\t * @param {*} value - Value to search for (string, function, or RegExp)\n\t * @param {string|string[]} [index] - Index(es) to search in, or all if not specified\n\t * @param {boolean} [raw=false] - Whether to return raw data without processing\n\t * @returns {Array<Object>} Array of matching records\n\t * @example\n\t * const results = store.search('john'); // Search all indexes\n\t * const nameResults = store.search('john', 'name'); // Search only name index\n\t * const regexResults = store.search(/^admin/, 'role'); // Regex search\n\t */\n\tsearch (value, index, raw = false) {\n\t\tconst result = new Set(); // Use Set for unique keys\n\t\tconst fn = typeof value === STRING_FUNCTION;\n\t\tconst rgex = value && typeof value.test === STRING_FUNCTION;\n\t\tif (!value) return this.immutable ? this.freeze() : [];\n\t\tconst indices = index ? Array.isArray(index) ? index : [index] : this.index;\n\t\tfor (const i of indices) {\n\t\t\tconst idx = this.indexes.get(i);\n\t\t\tif (idx) {\n\t\t\t\tfor (const [lkey, lset] of idx) {\n\t\t\t\t\tlet match = false;\n\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\tmatch = value(lkey, i);\n\t\t\t\t\t} else if (rgex) {\n\t\t\t\t\t\tmatch = value.test(Array.isArray(lkey) ? lkey.join(STRING_COMMA) : lkey);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = lkey === value;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tfor (const key of lset) {\n\t\t\t\t\t\t\tif (this.data.has(key)) {\n\t\t\t\t\t\t\t\tresult.add(key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet records = Array.from(result).map(key => this.get(key, raw));\n\t\tif (!raw && this.immutable) {\n\t\t\trecords = Object.freeze(records);\n\t\t}\n\n\t\treturn records;\n\t}\n\n\t/**\n\t * Sets or updates a record in the store with automatic indexing\n\t * @param {string|null} [key=null] - Key for the record, or null to use record's key field\n\t * @param {Object} [data={}] - Record data to set\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @param {boolean} [override=false] - Whether to override existing data instead of merging\n\t * @returns {Object} The stored record (frozen if immutable mode)\n\t * @example\n\t * const user = store.set(null, {name: 'John', age: 30}); // Auto-generate key\n\t * const updated = store.set('user123', {age: 31}); // Update existing record\n\t */\n\tset (key = null, data = {}, batch = false, override = false) {\n\t\tif (key === null) {\n\t\t\tkey = data[this.key] ?? this.uuid();\n\t\t}\n\t\tlet x = {...data, [this.key]: key};\n\t\tthis.beforeSet(key, x, batch, override);\n\t\tif (!this.data.has(key)) {\n\t\t\tif (this.versioning) {\n\t\t\t\tthis.versions.set(key, new Set());\n\t\t\t}\n\t\t} else {\n\t\t\tconst og = this.get(key, true);\n\t\t\tthis.deleteIndex(key, og);\n\t\t\tif (this.versioning) {\n\t\t\t\tthis.versions.get(key).add(Object.freeze(this.clone(og)));\n\t\t\t}\n\t\t\tif (!override) {\n\t\t\t\tx = this.merge(this.clone(og), x);\n\t\t\t}\n\t\t}\n\t\tthis.data.set(key, x);\n\t\tthis.setIndex(key, x, null);\n\t\tconst result = this.get(key);\n\t\tthis.onset(result, batch);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Internal method to add entries to indexes for a record\n\t * @param {string} key - Key of record being indexed\n\t * @param {Object} data - Data of record being indexed\n\t * @param {string|null} indice - Specific index to update, or null for all\n\t * @returns {Haro} This instance for method chaining\n\t */\n\tsetIndex (key, data, indice) {\n\t\tthis.each(indice === null ? this.index : [indice], i => {\n\t\t\tlet idx = this.indexes.get(i);\n\t\t\tif (!idx) {\n\t\t\t\tidx = new Map();\n\t\t\t\tthis.indexes.set(i, idx);\n\t\t\t}\n\t\t\tconst fn = c => {\n\t\t\t\tif (!idx.has(c)) {\n\t\t\t\t\tidx.set(c, new Set());\n\t\t\t\t}\n\t\t\t\tidx.get(c).add(key);\n\t\t\t};\n\t\t\tif (i.includes(this.delimiter)) {\n\t\t\t\tthis.each(this.indexKeys(i, this.delimiter, data), fn);\n\t\t\t} else {\n\t\t\t\tthis.each(Array.isArray(data[i]) ? data[i] : [data[i]], fn);\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sorts all records using a comparator function\n\t * @param {Function} fn - Comparator function for sorting (a, b) => number\n\t * @param {boolean} [frozen=false] - Whether to return frozen records\n\t * @returns {Array<Object>} Sorted array of records\n\t * @example\n\t * const sorted = store.sort((a, b) => a.age - b.age); // Sort by age\n\t * const names = store.sort((a, b) => a.name.localeCompare(b.name)); // Sort by name\n\t */\n\tsort (fn, frozen = false) {\n\t\tconst dataSize = this.data.size;\n\t\tlet result = this.limit(INT_0, dataSize, true).sort(fn);\n\t\tif (frozen) {\n\t\t\tresult = this.freeze(...result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sorts records by a specific indexed field in ascending order\n\t * @param {string} [index=STRING_EMPTY] - Index field name to sort by\n\t * @param {boolean} [raw=false] - Whether to return raw data without processing\n\t * @returns {Array<Object>} Array of records sorted by the specified field\n\t * @throws {Error} Throws error if index field is empty or invalid\n\t * @example\n\t * const byAge = store.sortBy('age');\n\t * const byName = store.sortBy('name');\n\t */\n\tsortBy (index = STRING_EMPTY, raw = false) {\n\t\tif (index === STRING_EMPTY) {\n\t\t\tthrow new Error(STRING_INVALID_FIELD);\n\t\t}\n\t\tlet result = [];\n\t\tconst keys = [];\n\t\tif (this.indexes.has(index) === false) {\n\t\t\tthis.reindex(index);\n\t\t}\n\t\tconst lindex = this.indexes.get(index);\n\t\tlindex.forEach((idx, key) => keys.push(key));\n\t\tthis.each(keys.sort((a, b) => a.localeCompare(b)), i => lindex.get(i).forEach(key => result.push(this.get(key, raw))));\n\t\tif (this.immutable) {\n\t\t\tresult = Object.freeze(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Converts all store data to a plain array of records\n\t * @returns {Array<Object>} Array containing all records in the store\n\t * @example\n\t * const allRecords = store.toArray();\n\t * console.log(`Store contains ${allRecords.length} records`);\n\t */\n\ttoArray () {\n\t\tconst result = Array.from(this.data.values());\n\t\tif (this.immutable) {\n\t\t\tthis.each(result, i => Object.freeze(i));\n\t\t\tObject.freeze(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Generates a RFC4122 v4 UUID for record identification\n\t * @returns {string} UUID string in standard format\n\t * @example\n\t * const id = store.uuid(); // \"f47ac10b-58cc-4372-a567-0e02b2c3d479\"\n\t */\n\tuuid () {\n\t\treturn uuid();\n\t}\n\n\t/**\n\t * Returns an iterator of all values in the store\n\t * @returns {Iterator<Object>} Iterator of record values\n\t * @example\n\t * for (const record of store.values()) {\n\t *   console.log(record.name);\n\t * }\n\t */\n\tvalues () {\n\t\treturn this.data.values();\n\t}\n\n\t/**\n\t * Internal helper method for predicate matching with support for arrays and regex\n\t * @param {Object} record - Record to test against predicate\n\t * @param {Object} predicate - Predicate object with field-value pairs\n\t * @param {string} op - Operator for array matching ('||' for OR, '&&' for AND)\n\t * @returns {boolean} True if record matches predicate criteria\n\t */\n\tmatchesPredicate (record, predicate, op) {\n\t\tconst keys = Object.keys(predicate);\n\n\t\treturn keys.every(key => {\n\t\t\tconst pred = predicate[key];\n\t\t\tconst val = record[key];\n\t\t\tif (Array.isArray(pred)) {\n\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\treturn op === \"&&\" ? pred.every(p => val.includes(p)) : pred.some(p => val.includes(p));\n\t\t\t\t} else {\n\t\t\t\t\treturn op === \"&&\" ? pred.every(p => val === p) : pred.some(p => val === p);\n\t\t\t\t}\n\t\t\t} else if (pred instanceof RegExp) {\n\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\treturn op === \"&&\" ? val.every(v => pred.test(v)) : val.some(v => pred.test(v));\n\t\t\t\t} else {\n\t\t\t\t\treturn pred.test(val);\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(val)) {\n\t\t\t\treturn val.includes(pred);\n\t\t\t} else {\n\t\t\t\treturn val === pred;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Advanced filtering with predicate logic supporting AND/OR operations on arrays\n\t * @param {Object} [predicate={}] - Object with field-value pairs for filtering\n\t * @param {string} [op=STRING_DOUBLE_PIPE] - Operator for array matching ('||' for OR, '&&' for AND)\n\t * @returns {Array<Object>} Array of records matching the predicate criteria\n\t * @example\n\t * // Find records with tags containing 'admin' OR 'user'\n\t * const users = store.where({tags: ['admin', 'user']}, '||');\n\t *\n\t * // Find records with ALL specified tags\n\t * const powerUsers = store.where({tags: ['admin', 'power']}, '&&');\n\t *\n\t * // Regex matching\n\t * const emails = store.where({email: /^admin@/});\n\t */\n\twhere (predicate = {}, op = STRING_DOUBLE_PIPE) {\n\t\tconst keys = this.index.filter(i => i in predicate);\n\t\tif (keys.length === 0) return [];\n\n\t\t// Try to use indexes for better performance\n\t\tconst indexedKeys = keys.filter(k => this.indexes.has(k));\n\t\tif (indexedKeys.length > 0) {\n\t\t\t// Use index-based filtering for better performance\n\t\t\tlet candidateKeys = new Set();\n\t\t\tlet first = true;\n\t\t\tfor (const key of indexedKeys) {\n\t\t\t\tconst pred = predicate[key];\n\t\t\t\tconst idx = this.indexes.get(key);\n\t\t\t\tconst matchingKeys = new Set();\n\t\t\t\tif (Array.isArray(pred)) {\n\t\t\t\t\tfor (const p of pred) {\n\t\t\t\t\t\tif (idx.has(p)) {\n\t\t\t\t\t\t\tfor (const k of idx.get(p)) {\n\t\t\t\t\t\t\t\tmatchingKeys.add(k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (idx.has(pred)) {\n\t\t\t\t\tfor (const k of idx.get(pred)) {\n\t\t\t\t\t\tmatchingKeys.add(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (first) {\n\t\t\t\t\tcandidateKeys = matchingKeys;\n\t\t\t\t\tfirst = false;\n\t\t\t\t} else {\n\t\t\t\t\t// AND operation across different fields\n\t\t\t\t\tcandidateKeys = new Set([...candidateKeys].filter(k => matchingKeys.has(k)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Filter candidates with full predicate logic\n\t\t\tconst results = [];\n\t\t\tfor (const key of candidateKeys) {\n\t\t\t\tconst record = this.get(key, true);\n\t\t\t\tif (this.matchesPredicate(record, predicate, op)) {\n\t\t\t\t\tresults.push(this.immutable ? this.get(key) : record);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.immutable ? this.freeze(...results) : results;\n\t\t}\n\n\t\t// Fallback to full scan if no indexes available\n\t\treturn this.filter(a => this.matchesPredicate(a, predicate, op));\n\t}\n}\n\n/**\n * Factory function to create a new Haro instance with optional initial data\n * @param {Array<Object>|null} [data=null] - Initial data to populate the store\n * @param {Object} [config={}] - Configuration object passed to Haro constructor\n * @returns {Haro} New Haro instance configured and optionally populated\n * @example\n * const store = haro([\n *   {id: 1, name: 'John', age: 30},\n *   {id: 2, name: 'Jane', age: 25}\n * ], {\n *   index: ['name', 'age'],\n *   versioning: true\n * });\n */\nexport function haro (data = null, config = {}) {\n\tconst obj = new Haro(config);\n\n\tif (Array.isArray(data)) {\n\t\tobj.batch(data, STRING_SET);\n\t}\n\n\treturn obj;\n}\n"],"names":["randomUUID","STRING_EMPTY","STRING_FUNCTION","STRING_RECORDS","STRING_INVALID_FUNCTION","Haro","constructor","delimiter","id","this","uuid","immutable","index","key","versioning","data","Map","Array","isArray","indexes","versions","Object","defineProperty","enumerable","get","from","keys","size","reindex","batch","args","type","fn","i","delete","set","onbatch","beforeBatch","map","arg","beforeClear","beforeDelete","beforeSet","override","clear","onclear","clone","structuredClone","has","Error","og","deleteIndex","ondelete","forEach","idx","values","includes","indexKeys","each","value","o","dump","result","entries","ii","arr","len","length","find","where","raw","sort","a","b","localeCompare","join","reduce","v","k","add","Set","freeze","filter","x","ctx","call","push","list","fields","split","fieldsLen","field","newResult","resultLen","valuesLen","j","newKey","limit","offset","max","registry","slice","merge","concat","onoverride","onset","accumulator","next","indices","setIndex","search","rgex","test","lkey","lset","match","records","indice","c","frozen","dataSize","sortBy","lindex","toArray","matchesPredicate","record","predicate","op","every","pred","val","p","some","RegExp","indexedKeys","candidateKeys","first","matchingKeys","results","haro","config","obj"],"mappings":"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"}