{"version":3,"file":"haro.umd.min.js","sources":["../src/constants.js","../src/haro.js"],"sourcesContent":["// String constants - Single characters and symbols\nexport const STRING_COMMA = \",\";\nexport const STRING_EMPTY = \"\";\nexport const STRING_PIPE = \"|\";\nexport const STRING_DOUBLE_PIPE = \"||\";\n\n// String constants - Single letters\nexport const STRING_A = \"a\";\nexport const STRING_B = \"b\";\n\n// String constants - Operation and type names\nexport const STRING_DEL = \"del\";\nexport const STRING_FUNCTION = \"function\";\nexport const STRING_INDEXES = \"indexes\";\nexport const STRING_OBJECT = \"object\";\nexport const STRING_RECORDS = \"records\";\nexport const STRING_REGISTRY = \"registry\";\nexport const STRING_SET = \"set\";\nexport const STRING_SIZE = \"size\";\n\n// String constants - Error messages\nexport const STRING_INVALID_FIELD = \"Invalid field\";\nexport const STRING_INVALID_FUNCTION = \"Invalid function\";\nexport const STRING_INVALID_TYPE = \"Invalid type\";\nexport const STRING_RECORD_NOT_FOUND = \"Record not found\";\n\n// Integer constants\nexport const INT_0 = 0;\nexport const INT_1 = 1;\nexport const INT_3 = 3;\nexport const INT_4 = 4;\nexport const INT_8 = 8;\nexport const INT_9 = 9;\nexport const INT_16 = 16;\n","import {randomUUID as uuid} from \"crypto\";\nimport {\n\tINT_0,\n\tSTRING_COMMA,\n\tSTRING_DEL,\n\tSTRING_DOUBLE_PIPE,\n\tSTRING_EMPTY,\n\tSTRING_FUNCTION,\n\tSTRING_INDEXES,\n\tSTRING_INVALID_FIELD,\n\tSTRING_INVALID_FUNCTION,\n\tSTRING_INVALID_TYPE,\n\tSTRING_PIPE,\n\tSTRING_RECORD_NOT_FOUND,\n\tSTRING_RECORDS,\n\tSTRING_REGISTRY,\n\tSTRING_SET,\n\tSTRING_SIZE\n} from \"./constants.js\";\n\n/**\n * Haro is a modern immutable DataStore for collections of records with indexing,\n * versioning, and batch operations support. It provides a Map-like interface\n * with advanced querying capabilities through indexes.\n * @class\n * @example\n * const store = new Haro({\n *   index: ['name', 'age'],\n *   key: 'id',\n *   versioning: true\n * });\n *\n * store.set(null, {name: 'John', age: 30});\n * const results = store.find({name: 'John'});\n */\nexport class Haro {\n\t/**\n\t * Creates a new Haro instance with specified configuration\n\t * @param {Object} [config={}] - Configuration object for the store\n\t * @param {string} [config.delimiter=STRING_PIPE] - Delimiter for composite indexes (default: '|')\n\t * @param {string} [config.id] - Unique identifier for this instance (auto-generated if not provided)\n\t * @param {string[]} [config.index=[]] - Array of field names to create indexes for\n\t * @param {string} [config.key=\"id\"] - Primary key field name used for record identification\n\t * @param {boolean} [config.versioning=false] - Enable versioning to track record changes\n\t * @param {boolean} [config.immutable=false] - Return frozen/immutable objects for data safety\n\t * @constructor\n\t * @example\n\t * const store = new Haro({\n\t *   index: ['name', 'email', 'name|department'],\n\t *   key: 'userId',\n\t *   versioning: true,\n\t *   immutable: true\n\t * });\n\t */\n\tconstructor ({delimiter = STRING_PIPE, id = this.uuid(), index = [], key = \"id\", versioning = false, immutable = false} = {}) {\n\t\tthis.data = new Map();\n\t\tthis.delimiter = delimiter;\n\t\tthis.id = id;\n\t\tthis.index = Array.isArray(index) ? [...index] : [];\n\t\tthis.indexes = new Map();\n\t\tthis.immutable = immutable;\n\t\tthis.key = key;\n\t\tthis.versions = new Map();\n\t\tthis.versioning = versioning;\n\n\t\tObject.defineProperty(this, STRING_REGISTRY, {\n\t\t\tenumerable: true,\n\t\t\tget: () => Array.from(this.data.keys())\n\t\t});\n\t\tObject.defineProperty(this, STRING_SIZE, {\n\t\t\tenumerable: true,\n\t\t\tget: () => this.data.size\n\t\t});\n\n\t\treturn this.reindex();\n\t}\n\n\t/**\n\t * Performs batch operations on multiple records for efficient bulk processing\n\t * @param {Array<Object>} args - Array of records to process\n\t * @param {string} [type=STRING_SET] - Type of operation: 'set' for upsert, 'del' for delete\n\t * @returns {Array} Array of results from the batch operation\n\t * @example\n\t * const results = store.batch([\n\t *   {id: 1, name: 'John'},\n\t *   {id: 2, name: 'Jane'}\n\t * ], 'set');\n\t */\n\tbatch (args, type = STRING_SET) {\n\t\tconst fn = type === STRING_DEL ? i => this.del(i, true) : i => this.set(null, i, true, true);\n\n\t\treturn this.onbatch(this.beforeBatch(args, type).map(fn), type);\n\t}\n\n\t/**\n\t * Lifecycle hook executed before batch operations for custom preprocessing\n\t * @param {Array} arg - Arguments passed to batch operation\n\t * @param {string} [type=STRING_EMPTY] - Type of batch operation ('set' or 'del')\n\t * @returns {Array} Modified arguments (override this method to implement custom logic)\n\t */\n\tbeforeBatch (arg, type = STRING_EMPTY) { // eslint-disable-line no-unused-vars\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Lifecycle hook executed before clear operation for custom preprocessing\n\t * Override this method in subclasses to implement custom logic\n\t * @example\n\t * class MyStore extends Haro {\n\t *   beforeClear() {\n\t *     this.backup = this.toArray();\n\t *   }\n\t * }\n\t */\n\tbeforeClear () {\n\t\t// Hook for custom logic before clear; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed before delete operation for custom preprocessing\n\t * @param {string} [key=STRING_EMPTY] - Key of record to delete\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @returns {Array<string|boolean>} Array containing [key, batch] for further processing\n\t */\n\tbeforeDelete (key = STRING_EMPTY, batch = false) {\n\t\treturn [key, batch];\n\t}\n\n\t/**\n\t * Lifecycle hook executed before set operation for custom preprocessing\n\t * @param {string} [key=STRING_EMPTY] - Key of record to set\n\t * @param {Object} data - Record data being set\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @param {boolean} [override=false] - Whether to override existing data\n\t * @returns {Array<string|boolean>} Array containing [key, batch] for further processing\n\t */\n\tbeforeSet (key = STRING_EMPTY, data, batch = false, override = false) { // eslint-disable-line no-unused-vars\n\t\treturn [key, batch];\n\t}\n\n\t/**\n\t * Removes all records, indexes, and versions from the store\n\t * @returns {Haro} This instance for method chaining\n\t * @example\n\t * store.clear();\n\t * console.log(store.size); // 0\n\t */\n\tclear () {\n\t\tthis.beforeClear();\n\t\tthis.data.clear();\n\t\tthis.indexes.clear();\n\t\tthis.versions.clear();\n\t\tthis.reindex().onclear();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a deep clone of the given value, handling objects, arrays, and primitives\n\t * @param {*} arg - Value to clone (any type)\n\t * @returns {*} Deep clone of the argument\n\t * @example\n\t * const original = {name: 'John', tags: ['user', 'admin']};\n\t * const cloned = store.clone(original);\n\t * cloned.tags.push('new'); // original.tags is unchanged\n\t */\n\tclone (arg) {\n\t\treturn structuredClone(arg);\n\t}\n\n\t/**\n\t * Deletes a record from the store and removes it from all indexes\n\t * @param {string} [key=STRING_EMPTY] - Key of record to delete\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @throws {Error} Throws error if record with the specified key is not found\n\t * @example\n\t * store.del('user123');\n\t * // Throws error if 'user123' doesn't exist\n\t */\n\tdel (key = STRING_EMPTY, batch = false) {\n\t\tif (!this.data.has(key)) {\n\t\t\tthrow new Error(STRING_RECORD_NOT_FOUND);\n\t\t}\n\t\tconst og = this.get(key, true);\n\t\tthis.beforeDelete(key, batch);\n\t\tthis.delIndex(this.index, this.indexes, this.delimiter, key, og);\n\t\tthis.data.delete(key);\n\t\tthis.ondelete(key, batch);\n\t\tif (this.versioning) {\n\t\t\tthis.versions.delete(key);\n\t\t}\n\t}\n\n\t/**\n\t * Internal method to remove entries from indexes for a deleted record\n\t * @param {string[]} index - Array of index field names\n\t * @param {Map<string, Map<*, Set<string>>>} indexes - Map of index structures\n\t * @param {string} delimiter - Delimiter for composite indexes\n\t * @param {string} key - Key of record being deleted\n\t * @param {Object} data - Data of record being deleted\n\t * @private\n\t */\n\tdelIndex (index, indexes, delimiter, key, data) {\n\t\tindex.forEach(i => {\n\t\t\tconst idx = indexes.get(i);\n\t\t\tif (!idx) return;\n\t\t\tconst values = i.includes(delimiter) ?\n\t\t\t\tthis.indexKeys(i, delimiter, data) :\n\t\t\t\tArray.isArray(data[i]) ? data[i] : [data[i]];\n\t\t\tthis.each(values, value => {\n\t\t\t\tif (idx.has(value)) {\n\t\t\t\t\tconst o = idx.get(value);\n\t\t\t\t\to.delete(key);\n\t\t\t\t\tif (o.size === INT_0) {\n\t\t\t\t\t\tidx.delete(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Exports complete store data or indexes for persistence or debugging\n\t * @param {string} [type=STRING_RECORDS] - Type of data to export: 'records' or 'indexes'\n\t * @returns {Array} Array of [key, value] pairs for records, or serialized index structure\n\t * @example\n\t * const records = store.dump('records');\n\t * const indexes = store.dump('indexes');\n\t */\n\tdump (type = STRING_RECORDS) {\n\t\tlet result;\n\n\t\tif (type === STRING_RECORDS) {\n\t\t\tresult = Array.from(this.entries());\n\t\t} else {\n\t\t\tresult = Array.from(this.indexes).map(i => {\n\t\t\t\ti[1] = Array.from(i[1]).map(ii => {\n\t\t\t\t\tii[1] = Array.from(ii[1]);\n\n\t\t\t\t\treturn ii;\n\t\t\t\t});\n\n\t\t\t\treturn i;\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Utility method to iterate over an array with a callback function\n\t * @param {Array} [arr=[]] - Array to iterate over\n\t * @param {Function} fn - Function to call for each element (element, index)\n\t * @returns {Array} The original array for method chaining\n\t * @example\n\t * store.each([1, 2, 3], (item, index) => console.log(item, index));\n\t */\n\teach (arr = [], fn) {\n\t\tconst len = arr.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tfn(arr[i], i);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\t/**\n\t * Returns an iterator of [key, value] pairs for each record in the store\n\t * @returns {Iterator<Array>} Iterator of [key, value] pairs\n\t * @example\n\t * for (const [key, value] of store.entries()) {\n\t *   console.log(key, value);\n\t * }\n\t */\n\tentries () {\n\t\treturn this.data.entries();\n\t}\n\n\t/**\n\t * Finds records matching the specified criteria using indexes for optimal performance\n\t * @param {Object} [where={}] - Object with field-value pairs to match against\n\t * @returns {Array<Object>} Array of matching records (frozen if immutable mode)\n\t * @example\n\t * const users = store.find({department: 'engineering', active: true});\n\t * const admins = store.find({role: 'admin'});\n\t */\n\tfind (where = {}) {\n\t\tconst key = Object.keys(where).sort((a, b) => a.localeCompare(b)).join(this.delimiter);\n\t\tconst index = this.indexes.get(key) ?? new Map();\n\t\tlet result = [];\n\t\tif (index.size > 0) {\n\t\t\tconst keys = this.indexKeys(key, this.delimiter, where);\n\t\t\tresult = Array.from(keys.reduce((a, v) => {\n\t\t\t\tif (index.has(v)) {\n\t\t\t\t\tindex.get(v).forEach(k => a.add(k));\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\t\t\t}, new Set())).map(i => this.get(i));\n\t\t}\n\n\t\treturn this.immutable ? this.freeze(...result) : result;\n\t}\n\n\t/**\n\t * Filters records using a predicate function, similar to Array.filter\n\t * @param {Function} fn - Predicate function to test each record (record, key, store)\n\t * @returns {Array<Object>} Array of records that pass the predicate test\n\t * @throws {Error} Throws error if fn is not a function\n\t * @example\n\t * const adults = store.filter(record => record.age >= 18);\n\t * const recent = store.filter(record => record.created > Date.now() - 86400000);\n\t */\n\tfilter (fn) {\n\t\tif (typeof fn !== STRING_FUNCTION) {\n\t\t\tthrow new Error(STRING_INVALID_FUNCTION);\n\t\t}\n\t\tconst x = this.immutable ? (k, v) => Object.freeze([k, Object.freeze(v)]) : (k, v) => v;\n\t\tconst result = this.reduce((a, v, k, ctx) => {\n\t\t\tif (fn.call(ctx, v)) {\n\t\t\t\ta.push(x(k, v));\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}, []);\n\n\t\treturn this.immutable ? Object.freeze(result) : result;\n\t}\n\n\t/**\n\t * Executes a function for each record in the store, similar to Array.forEach\n\t * @param {Function} fn - Function to execute for each record (value, key)\n\t * @param {*} [ctx] - Context object to use as 'this' when executing the function\n\t * @returns {Haro} This instance for method chaining\n\t * @example\n\t * store.forEach((record, key) => {\n\t *   console.log(`${key}: ${record.name}`);\n\t * });\n\t */\n\tforEach (fn, ctx) {\n\t\tthis.data.forEach((value, key) => {\n\t\t\tfn(this.clone(value), key); // Only clone value, key is primitive\n\t\t}, ctx ?? this.data);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a frozen array from the given arguments for immutable data handling\n\t * @param {...*} args - Arguments to freeze into an array\n\t * @returns {Array} Frozen array containing frozen arguments\n\t * @example\n\t * const frozen = store.freeze(obj1, obj2, obj3);\n\t * // Returns Object.freeze([Object.freeze(obj1), Object.freeze(obj2), Object.freeze(obj3)])\n\t */\n\tfreeze (...args) {\n\t\treturn Object.freeze(args.map(i => Object.freeze(i)));\n\t}\n\n\t/**\n\t * Retrieves a record by its key\n\t * @param {string} key - Key of record to retrieve\n\t * @param {boolean} [raw=false] - Whether to return raw data (true) or processed/frozen data (false)\n\t * @returns {Object|null} The record if found, null if not found\n\t * @example\n\t * const user = store.get('user123');\n\t * const rawUser = store.get('user123', true);\n\t */\n\tget (key, raw = false) {\n\t\tlet result = this.data.get(key) ?? null;\n\n\t\tif (result !== null && !raw) {\n\t\t\tif (this.immutable) {\n\t\t\t\tresult = this.clone(result);\n\t\t\t}\n\n\t\t\treturn this.immutable ? this.freeze(key, result) : result;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Checks if a record with the specified key exists in the store\n\t * @param {string} key - Key to check for existence\n\t * @returns {boolean} True if record exists, false otherwise\n\t * @example\n\t * if (store.has('user123')) {\n\t *   console.log('User exists');\n\t * }\n\t */\n\thas (key) {\n\t\treturn this.data.has(key);\n\t}\n\n\t/**\n\t * Generates index keys for composite indexes from data values\n\t * @param {string} [arg=STRING_EMPTY] - Composite index field names joined by delimiter\n\t * @param {string} [delimiter=STRING_PIPE] - Delimiter used in composite index\n\t * @param {Object} [data={}] - Data object to extract field values from\n\t * @returns {string[]} Array of generated index keys\n\t * @example\n\t * // For index 'name|department' with data {name: 'John', department: 'IT'}\n\t * const keys = store.indexKeys('name|department', '|', data);\n\t * // Returns ['John|IT']\n\t */\n\tindexKeys (arg = STRING_EMPTY, delimiter = STRING_PIPE, data = {}) {\n\t\tconst fields = arg.split(delimiter);\n\t\tconst fieldsLen = fields.length;\n\t\tlet result = [\"\"];\n\n\t\tfor (let i = 0; i < fieldsLen; i++) {\n\t\t\tconst field = fields[i];\n\t\t\tconst values = Array.isArray(data[field]) ? data[field] : [data[field]];\n\t\t\tconst newResult = [];\n\t\t\tconst resultLen = result.length;\n\t\t\tconst valuesLen = values.length;\n\n\t\t\tfor (let j = 0; j < resultLen; j++) {\n\t\t\t\tfor (let k = 0; k < valuesLen; k++) {\n\t\t\t\t\tconst newKey = i === 0 ? values[k] : `${result[j]}${delimiter}${values[k]}`;\n\t\t\t\t\tnewResult.push(newKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = newResult;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns an iterator of all keys in the store\n\t * @returns {Iterator<string>} Iterator of record keys\n\t * @example\n\t * for (const key of store.keys()) {\n\t *   console.log(key);\n\t * }\n\t */\n\tkeys () {\n\t\treturn this.data.keys();\n\t}\n\n\t/**\n\t * Returns a limited subset of records with offset support for pagination\n\t * @param {number} [offset=INT_0] - Number of records to skip from the beginning\n\t * @param {number} [max=INT_0] - Maximum number of records to return\n\t * @returns {Array<Object>} Array of records within the specified range\n\t * @example\n\t * const page1 = store.limit(0, 10);   // First 10 records\n\t * const page2 = store.limit(10, 10);  // Next 10 records\n\t */\n\tlimit (offset = INT_0, max = INT_0) {\n\t\tconst result = this.registry.slice(offset, offset + max).map(i => this.get(i));\n\n\t\treturn this.immutable ? this.freeze(...result) : result;\n\t}\n\n\t/**\n\t * Transforms all records using a mapping function, similar to Array.map\n\t * @param {Function} fn - Function to transform each record (record, key)\n\t * @returns {Array} Array of transformed results\n\t * @throws {Error} Throws error if fn is not a function\n\t * @example\n\t * const names = store.map(record => record.name);\n\t * const summaries = store.map(record => ({id: record.id, name: record.name}));\n\t */\n\tmap (fn) {\n\t\tif (typeof fn !== STRING_FUNCTION) {\n\t\t\tthrow new Error(STRING_INVALID_FUNCTION);\n\t\t}\n\n\t\tconst result = [];\n\n\t\tthis.forEach((value, key) => result.push(fn(value, key)));\n\n\t\treturn this.immutable ? this.freeze(...result) : result;\n\t}\n\n\t/**\n\t * Merges two values together with support for arrays and objects\n\t * @param {*} a - First value (target)\n\t * @param {*} b - Second value (source)\n\t * @param {boolean} [override=false] - Whether to override arrays instead of concatenating\n\t * @returns {*} Merged result\n\t * @example\n\t * const merged = store.merge({a: 1}, {b: 2}); // {a: 1, b: 2}\n\t * const arrays = store.merge([1, 2], [3, 4]); // [1, 2, 3, 4]\n\t */\n\tmerge (a, b, override = false) {\n\t\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\t\ta = override ? b : a.concat(b);\n\t\t} else if (typeof a === \"object\" && a !== null && typeof b === \"object\" && b !== null) {\n\t\t\tthis.each(Object.keys(b), i => {\n\t\t\t\ta[i] = this.merge(a[i], b[i], override);\n\t\t\t});\n\t\t} else {\n\t\t\ta = b;\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Lifecycle hook executed after batch operations for custom postprocessing\n\t * @param {Array} arg - Result of batch operation\n\t * @param {string} [type=STRING_EMPTY] - Type of batch operation that was performed\n\t * @returns {Array} Modified result (override this method to implement custom logic)\n\t */\n\tonbatch (arg, type = STRING_EMPTY) { // eslint-disable-line no-unused-vars\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Lifecycle hook executed after clear operation for custom postprocessing\n\t * Override this method in subclasses to implement custom logic\n\t * @example\n\t * class MyStore extends Haro {\n\t *   onclear() {\n\t *     console.log('Store cleared');\n\t *   }\n\t * }\n\t */\n\tonclear () {\n\t\t// Hook for custom logic after clear; override in subclass if needed\n\t}\n\n\t/**\n\t * Lifecycle hook executed after delete operation for custom postprocessing\n\t * @param {string} [key=STRING_EMPTY] - Key of deleted record\n\t * @param {boolean} [batch=false] - Whether this was part of a batch operation\n\t * @returns {Array<string|boolean>} Array containing [key, batch] for further processing\n\t */\n\tondelete (key = STRING_EMPTY, batch = false) {\n\t\treturn [key, batch];\n\t}\n\n\t/**\n\t * Lifecycle hook executed after override operation for custom postprocessing\n\t * @param {string} [type=STRING_EMPTY] - Type of override operation that was performed\n\t * @returns {string} The type parameter for further processing\n\t */\n\tonoverride (type = STRING_EMPTY) {\n\t\treturn type;\n\t}\n\n\t/**\n\t * Lifecycle hook executed after set operation for custom postprocessing\n\t * @param {Object} [arg={}] - Record that was set\n\t * @param {boolean} [batch=false] - Whether this was part of a batch operation\n\t * @returns {Array<Object|boolean>} Array containing [record, batch] for further processing\n\t */\n\tonset (arg = {}, batch = false) {\n\t\treturn [arg, batch];\n\t}\n\n\t/**\n\t * Replaces all store data or indexes with new data for bulk operations\n\t * @param {Array} data - Data to replace with (format depends on type)\n\t * @param {string} [type=STRING_RECORDS] - Type of data: 'records' or 'indexes'\n\t * @returns {boolean} True if operation succeeded\n\t * @throws {Error} Throws error if type is invalid\n\t * @example\n\t * const records = [['key1', {name: 'John'}], ['key2', {name: 'Jane'}]];\n\t * store.override(records, 'records');\n\t */\n\toverride (data, type = STRING_RECORDS) {\n\t\tconst result = true;\n\n\t\tif (type === STRING_INDEXES) {\n\t\t\tthis.indexes = new Map(data.map(i => [i[0], new Map(i[1].map(ii => [ii[0], new Set(ii[1])]))]));\n\t\t} else if (type === STRING_RECORDS) {\n\t\t\tthis.indexes.clear();\n\t\t\tthis.data = new Map(data);\n\t\t} else {\n\t\t\tthrow new Error(STRING_INVALID_TYPE);\n\t\t}\n\n\t\tthis.onoverride(type);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Reduces all records to a single value using a reducer function\n\t * @param {Function} fn - Reducer function (accumulator, value, key, store)\n\t * @param {*} [accumulator] - Initial accumulator value\n\t * @returns {*} Final reduced value\n\t * @example\n\t * const totalAge = store.reduce((sum, record) => sum + record.age, 0);\n\t * const names = store.reduce((acc, record) => acc.concat(record.name), []);\n\t */\n\treduce (fn, accumulator) {\n\t\tlet a = accumulator ?? this.data.keys().next().value;\n\n\t\tthis.forEach((v, k) => {\n\t\t\ta = fn(a, v, k, this);\n\t\t}, this);\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Rebuilds indexes for specified fields or all fields for data consistency\n\t * @param {string|string[]} [index] - Specific index field(s) to rebuild, or all if not specified\n\t * @returns {Haro} This instance for method chaining\n\t * @example\n\t * store.reindex(); // Rebuild all indexes\n\t * store.reindex('name'); // Rebuild only name index\n\t * store.reindex(['name', 'email']); // Rebuild name and email indexes\n\t */\n\treindex (index) {\n\t\tconst indices = index ? [index] : this.index;\n\n\t\tif (index && this.index.includes(index) === false) {\n\t\t\tthis.index.push(index);\n\t\t}\n\n\t\tthis.each(indices, i => this.indexes.set(i, new Map()));\n\t\tthis.forEach((data, key) => this.each(indices, i => this.setIndex(this.index, this.indexes, this.delimiter, key, data, i)));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Searches for records containing a value across specified indexes\n\t * @param {*} value - Value to search for (string, function, or RegExp)\n\t * @param {string|string[]} [index] - Index(es) to search in, or all if not specified\n\t * @returns {Array<Object>} Array of matching records\n\t * @example\n\t * const results = store.search('john'); // Search all indexes\n\t * const nameResults = store.search('john', 'name'); // Search only name index\n\t * const regexResults = store.search(/^admin/, 'role'); // Regex search\n\t */\n\tsearch (value, index) {\n\t\tconst result = new Set(); // Use Set for unique keys\n\t\tconst fn = typeof value === STRING_FUNCTION;\n\t\tconst rgex = value && typeof value.test === STRING_FUNCTION;\n\n\t\tif (!value) return this.immutable ? this.freeze() : [];\n\n\t\tconst indices = index ? Array.isArray(index) ? index : [index] : this.index;\n\n\t\tfor (const i of indices) {\n\t\t\tconst idx = this.indexes.get(i);\n\t\t\tif (idx) {\n\t\t\t\tfor (const [lkey, lset] of idx) {\n\t\t\t\t\tlet match = false;\n\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\tmatch = value(lkey, i);\n\t\t\t\t\t} else if (rgex) {\n\t\t\t\t\t\tmatch = value.test(Array.isArray(lkey) ? lkey.join(STRING_COMMA) : lkey);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = lkey === value;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tfor (const key of lset) {\n\t\t\t\t\t\t\tif (this.data.has(key)) {\n\t\t\t\t\t\t\t\tresult.add(key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst records = Array.from(result).map(key => this.get(key));\n\n\t\treturn this.immutable ? this.freeze(...records) : records;\n\t}\n\n\t/**\n\t * Sets or updates a record in the store with automatic indexing\n\t * @param {string|null} [key=null] - Key for the record, or null to use record's key field\n\t * @param {Object} [data={}] - Record data to set\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @param {boolean} [override=false] - Whether to override existing data instead of merging\n\t * @returns {Object} The stored record (frozen if immutable mode)\n\t * @example\n\t * const user = store.set(null, {name: 'John', age: 30}); // Auto-generate key\n\t * const updated = store.set('user123', {age: 31}); // Update existing record\n\t */\n\tset (key = null, data = {}, batch = false, override = false) {\n\t\tif (key === null) {\n\t\t\tkey = data[this.key] ?? this.uuid();\n\t\t}\n\t\tlet x = {...data, [this.key]: key};\n\t\tthis.beforeSet(key, x, batch, override);\n\t\tif (!this.data.has(key)) {\n\t\t\tif (this.versioning) {\n\t\t\t\tthis.versions.set(key, new Set());\n\t\t\t}\n\t\t} else {\n\t\t\tconst og = this.get(key, true);\n\t\t\tthis.delIndex(this.index, this.indexes, this.delimiter, key, og);\n\t\t\tif (this.versioning) {\n\t\t\t\tthis.versions.get(key).add(Object.freeze(this.clone(og)));\n\t\t\t}\n\t\t\tif (!override) {\n\t\t\t\tx = this.merge(this.clone(og), x);\n\t\t\t}\n\t\t}\n\t\tthis.data.set(key, x);\n\t\tthis.setIndex(this.index, this.indexes, this.delimiter, key, x, null);\n\t\tconst result = this.get(key);\n\t\tthis.onset(result, batch);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Internal method to add entries to indexes for a record\n\t * @param {string[]} index - Array of index field names\n\t * @param {Map<string, Map<*, Set<string>>>} indexes - Map of index structures\n\t * @param {string} delimiter - Delimiter for composite indexes\n\t * @param {string} key - Key of record being indexed\n\t * @param {Object} data - Data of record being indexed\n\t * @param {string|null} indice - Specific index to update, or null for all\n\t * @private\n\t */\n\tsetIndex (index, indexes, delimiter, key, data, indice) {\n\t\tthis.each(indice === null ? index : [indice], i => {\n\t\t\tlet lindex = indexes.get(i);\n\t\t\tif (!lindex) {\n\t\t\t\tlindex = new Map();\n\t\t\t\tindexes.set(i, lindex);\n\t\t\t}\n\t\t\tif (i.includes(delimiter)) {\n\t\t\t\tthis.each(this.indexKeys(i, delimiter, data), c => {\n\t\t\t\t\tif (!lindex.has(c)) {\n\t\t\t\t\t\tlindex.set(c, new Set());\n\t\t\t\t\t}\n\t\t\t\t\tlindex.get(c).add(key);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.each(Array.isArray(data[i]) ? data[i] : [data[i]], d => {\n\t\t\t\t\tif (!lindex.has(d)) {\n\t\t\t\t\t\tlindex.set(d, new Set());\n\t\t\t\t\t}\n\t\t\t\t\tlindex.get(d).add(key);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Sorts all records using a comparator function\n\t * @param {Function} fn - Comparator function for sorting (a, b) => number\n\t * @param {boolean} [frozen=false] - Whether to return frozen records\n\t * @returns {Array<Object>} Sorted array of records\n\t * @example\n\t * const sorted = store.sort((a, b) => a.age - b.age); // Sort by age\n\t * const names = store.sort((a, b) => a.name.localeCompare(b.name)); // Sort by name\n\t */\n\tsort (fn, frozen = false) {\n\t\tconst dataSize = this.data.size;\n\n\t\treturn frozen ? Object.freeze(this.limit(INT_0, dataSize, true).sort(fn).map(i => Object.freeze(i))) : this.limit(INT_0, dataSize, true).sort(fn);\n\t}\n\n\t/**\n\t * Sorts records by a specific indexed field in ascending order\n\t * @param {string} [index=STRING_EMPTY] - Index field name to sort by\n\t * @returns {Array<Object>} Array of records sorted by the specified field\n\t * @throws {Error} Throws error if index field is empty or invalid\n\t * @example\n\t * const byAge = store.sortBy('age');\n\t * const byName = store.sortBy('name');\n\t */\n\tsortBy (index = STRING_EMPTY) {\n\t\tif (index === STRING_EMPTY) {\n\t\t\tthrow new Error(STRING_INVALID_FIELD);\n\t\t}\n\n\t\tconst result = [],\n\t\t\tkeys = [];\n\n\t\tif (this.indexes.has(index) === false) {\n\t\t\tthis.reindex(index);\n\t\t}\n\n\t\tconst lindex = this.indexes.get(index);\n\n\t\tlindex.forEach((idx, key) => keys.push(key));\n\t\tthis.each(keys.sort(), i => lindex.get(i).forEach(key => result.push(this.get(key))));\n\n\t\treturn this.immutable ? this.freeze(...result) : result;\n\t}\n\n\t/**\n\t * Converts all store data to a plain array of records\n\t * @returns {Array<Object>} Array containing all records in the store\n\t * @example\n\t * const allRecords = store.toArray();\n\t * console.log(`Store contains ${allRecords.length} records`);\n\t */\n\ttoArray () {\n\t\tconst result = Array.from(this.data.values());\n\n\t\tif (this.immutable) {\n\t\t\tthis.each(result, i => Object.freeze(i));\n\t\t\tObject.freeze(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Generates a RFC4122 v4 UUID for record identification\n\t * @returns {string} UUID string in standard format\n\t * @example\n\t * const id = store.uuid(); // \"f47ac10b-58cc-4372-a567-0e02b2c3d479\"\n\t */\n\tuuid () {\n\t\treturn uuid();\n\t}\n\n\t/**\n\t * Returns an iterator of all values in the store\n\t * @returns {Iterator<Object>} Iterator of record values\n\t * @example\n\t * for (const record of store.values()) {\n\t *   console.log(record.name);\n\t * }\n\t */\n\tvalues () {\n\t\treturn this.data.values();\n\t}\n\n\t/**\n\t * Internal helper method for predicate matching with support for arrays and regex\n\t * @param {Object} record - Record to test against predicate\n\t * @param {Object} predicate - Predicate object with field-value pairs\n\t * @param {string} op - Operator for array matching ('||' for OR, '&&' for AND)\n\t * @returns {boolean} True if record matches predicate criteria\n\t * @private\n\t */\n\tmatchesPredicate (record, predicate, op) {\n\t\tconst keys = Object.keys(predicate);\n\n\t\treturn keys.every(key => {\n\t\t\tconst pred = predicate[key];\n\t\t\tconst val = record[key];\n\n\t\t\tif (Array.isArray(pred)) {\n\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\treturn op === \"&&\" ? pred.every(p => val.includes(p)) : pred.some(p => val.includes(p));\n\t\t\t\t} else {\n\t\t\t\t\treturn op === \"&&\" ? pred.every(p => val === p) : pred.some(p => val === p);\n\t\t\t\t}\n\t\t\t} else if (pred instanceof RegExp) {\n\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\treturn op === \"&&\" ? val.every(v => pred.test(v)) : val.some(v => pred.test(v));\n\t\t\t\t} else {\n\t\t\t\t\treturn pred.test(val);\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(val)) {\n\t\t\t\treturn val.includes(pred);\n\t\t\t} else {\n\t\t\t\treturn val === pred;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Advanced filtering with predicate logic supporting AND/OR operations on arrays\n\t * @param {Object} [predicate={}] - Object with field-value pairs for filtering\n\t * @param {string} [op=STRING_DOUBLE_PIPE] - Operator for array matching ('||' for OR, '&&' for AND)\n\t * @returns {Array<Object>} Array of records matching the predicate criteria\n\t * @example\n\t * // Find records with tags containing 'admin' OR 'user'\n\t * const users = store.where({tags: ['admin', 'user']}, '||');\n\t *\n\t * // Find records with ALL specified tags\n\t * const powerUsers = store.where({tags: ['admin', 'power']}, '&&');\n\t *\n\t * // Regex matching\n\t * const emails = store.where({email: /^admin@/});\n\t */\n\twhere (predicate = {}, op = STRING_DOUBLE_PIPE) {\n\t\tconst keys = this.index.filter(i => i in predicate);\n\t\tif (keys.length === 0) return [];\n\n\t\t// Try to use indexes for better performance\n\t\tconst indexedKeys = keys.filter(k => this.indexes.has(k));\n\n\t\tif (indexedKeys.length > 0) {\n\t\t\t// Use index-based filtering for better performance\n\t\t\tlet candidateKeys = new Set();\n\t\t\tlet first = true;\n\n\t\t\tfor (const key of indexedKeys) {\n\t\t\t\tconst pred = predicate[key];\n\t\t\t\tconst idx = this.indexes.get(key);\n\t\t\t\tconst matchingKeys = new Set();\n\n\t\t\t\tif (Array.isArray(pred)) {\n\t\t\t\t\tfor (const p of pred) {\n\t\t\t\t\t\tif (idx.has(p)) {\n\t\t\t\t\t\t\tfor (const k of idx.get(p)) {\n\t\t\t\t\t\t\t\tmatchingKeys.add(k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (idx.has(pred)) {\n\t\t\t\t\tfor (const k of idx.get(pred)) {\n\t\t\t\t\t\tmatchingKeys.add(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (first) {\n\t\t\t\t\tcandidateKeys = matchingKeys;\n\t\t\t\t\tfirst = false;\n\t\t\t\t} else {\n\t\t\t\t\t// AND operation across different fields\n\t\t\t\t\tcandidateKeys = new Set([...candidateKeys].filter(k => matchingKeys.has(k)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Filter candidates with full predicate logic\n\t\t\tconst results = [];\n\t\t\tfor (const key of candidateKeys) {\n\t\t\t\tconst record = this.get(key, true);\n\t\t\t\tif (this.matchesPredicate(record, predicate, op)) {\n\t\t\t\t\tresults.push(this.immutable ? this.get(key) : record);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.immutable ? this.freeze(...results) : results;\n\t\t}\n\n\t\t// Fallback to full scan if no indexes available\n\t\treturn this.filter(a => this.matchesPredicate(a, predicate, op));\n\t}\n\n}\n\n/**\n * Factory function to create a new Haro instance with optional initial data\n * @param {Array<Object>|null} [data=null] - Initial data to populate the store\n * @param {Object} [config={}] - Configuration object passed to Haro constructor\n * @returns {Haro} New Haro instance configured and optionally populated\n * @example\n * const store = haro([\n *   {id: 1, name: 'John', age: 30},\n *   {id: 2, name: 'Jane', age: 25}\n * ], {\n *   index: ['name', 'age'],\n *   versioning: true\n * });\n */\nexport function haro (data = null, config = {}) {\n\tconst obj = new Haro(config);\n\n\tif (Array.isArray(data)) {\n\t\tobj.batch(data, STRING_SET);\n\t}\n\n\treturn obj;\n}\n"],"names":["g","f","exports","module","require","define","amd","globalThis","self","lru","crypto","this","STRING_EMPTY","STRING_FUNCTION","STRING_RECORDS","STRING_INVALID_FUNCTION","Haro","constructor","delimiter","id","uuid","index","key","versioning","immutable","data","Map","Array","isArray","indexes","versions","Object","defineProperty","enumerable","get","from","keys","size","reindex","batch","args","type","fn","i","del","set","onbatch","beforeBatch","map","arg","beforeClear","beforeDelete","beforeSet","override","clear","onclear","clone","structuredClone","has","Error","og","delIndex","delete","ondelete","forEach","idx","values","includes","indexKeys","each","value","o","dump","result","entries","ii","arr","len","length","find","where","sort","a","b","localeCompare","join","reduce","v","k","add","Set","freeze","filter","x","ctx","call","push","raw","fields","split","fieldsLen","field","newResult","resultLen","valuesLen","j","newKey","limit","offset","max","registry","slice","merge","concat","onoverride","onset","accumulator","next","indices","setIndex","search","rgex","test","lkey","lset","match","records","indice","lindex","c","d","frozen","dataSize","sortBy","toArray","matchesPredicate","record","predicate","op","every","pred","val","p","some","RegExp","indexedKeys","candidateKeys","first","matchingKeys","results","haro","config","obj"],"mappings":"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"}