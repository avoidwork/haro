{"version":3,"file":"haro.umd.min.js","sources":["../src/constants.js","../src/utils.js","../src/haro.js"],"sourcesContent":["export const STRING_COMMA = \",\";\r\nexport const STRING_EMPTY = \"\";\r\nexport const STRING_PIPE = \"|\";\r\nexport const STRING_DOUBLE_PIPE = \"||\";\r\nexport const STRING_A = \"a\";\r\nexport const STRING_B = \"b\";\r\nexport const STRING_DEL = \"del\";\r\nexport const STRING_FUNCTION = \"function\";\r\nexport const STRING_INDEXES = \"indexes\";\r\nexport const STRING_INVALID_FIELD = \"Invalid field\";\r\nexport const STRING_INVALID_TYPE = \"Invalid type\";\r\nexport const STRING_OBJECT = \"object\";\r\nexport const STRING_RECORD_NOT_FOUND = \"Record not found\";\r\nexport const STRING_RECORDS = \"records\";\r\nexport const STRING_REGISTRY = \"registry\";\r\nexport const STRING_SET = \"set\";\r\nexport const STRING_SIZE = \"size\";\r\nexport const INT_0 = 0;\r\nexport const INT_1 = 1;\r\nexport const INT_3 = 3;\r\nexport const INT_4 = 4;\r\nexport const INT_8 = 8;\r\nexport const INT_9 = 9;\r\nexport const INT_16 = 16;","import {\r\n    INT_0,\r\n    INT_1,\r\n    INT_16,\r\n    INT_3,\r\n    INT_4,\r\n    INT_8,\r\n    INT_9,\r\n    STRING_A,\r\n    STRING_B,\r\n    STRING_EMPTY,\r\n    STRING_OBJECT,\r\n    STRING_PIPE\r\n} from \"./constants.js\";\r\n\r\nconst r = [INT_8, INT_9, STRING_A, STRING_B];\r\n\r\nexport const clone = structuredClone ?? function shallowClone(arg) {\r\n    return JSON.parse(JSON.stringify(arg, null, INT_0));\r\n};\r\n\r\nexport function each(arr = [], fn) {\r\n    for (const [idx, value] of arr.entries()) {\r\n        fn(value, idx);\r\n    }\r\n\r\n    return arr;\r\n}\r\n\r\nexport function indexKeys(arg = STRING_EMPTY, delimiter = STRING_PIPE, data = {}) {\r\n    return arg.split(delimiter).reduce((a, li, lidx) => {\r\n        const result = [];\r\n\r\n        (Array.isArray(data[li]) ? data[li] : [data[li]]).forEach(lli => lidx === INT_0 ? result.push(lli) : a.forEach(x => result.push(`${x}${delimiter}${lli}`)));\r\n\r\n        return result;\r\n    }, []);\r\n}\r\n\r\nexport function delIndex(index, indexes, delimiter, key, data) {\r\n    index.forEach(i => {\r\n        const idx = indexes.get(i);\r\n\r\n        each(i.includes(delimiter) ? indexKeys(i, delimiter, data) : Array.isArray(data[i]) ? data[i] : [data[i]], value => {\r\n            if (idx.has(value)) {\r\n                const o = idx.get(value);\r\n\r\n                o.delete(key);\r\n\r\n                if (o.size === INT_0) {\r\n                    idx.delete(value);\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nexport function merge(a, b) {\r\n    if (a instanceof Object && b instanceof Object) {\r\n        each(Object.keys(b), i => {\r\n            if (a[i] instanceof Object && b[i] instanceof Object) {\r\n                a[i] = merge(a[i], b[i]);\r\n            } else if (Array.isArray(a[i]) && Array.isArray(b[i])) {\r\n                a[i] = a[i].concat(b[i]);\r\n            } else {\r\n                a[i] = b[i];\r\n            }\r\n        });\r\n    } else if (Array.isArray(a) && Array.isArray(b)) {\r\n        a = a.concat(b);\r\n    } else {\r\n        a = b;\r\n    }\r\n\r\n    return a;\r\n}\r\n\r\nexport function s() {\r\n    return ((Math.random() + INT_1) * 0x10000 | INT_0).toString(INT_16).substring(INT_1);\r\n}\r\n\r\nexport function setIndex(index, indexes, delimiter, key, data, indice) {\r\n    each(indice === null ? index : [indice], i => {\r\n        const lindex = indexes.get(i);\r\n\r\n        if (i.includes(delimiter)) {\r\n            each(indexKeys(i, delimiter, data), c => {\r\n                if (lindex.has(c) === false) {\r\n                    lindex.set(c, new Set());\r\n                }\r\n\r\n                lindex.get(c).add(key);\r\n            });\r\n        } else {\r\n            each(Array.isArray(data[i]) ? data[i] : [data[i]], d => {\r\n                if (lindex.has(d) === false) {\r\n                    lindex.set(d, new Set());\r\n                }\r\n\r\n                lindex.get(d).add(key);\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nexport const uuid = typeof crypto === STRING_OBJECT ? crypto.randomUUID : () => `${s()}${s()}-${s()}-4${s().slice(INT_0, INT_3)}-${r[Math.floor(Math.random() * INT_4)]}${s().slice(INT_0, INT_3)}-${s()}${s()}${s()}`;\r\n","import {clone, delIndex, each, indexKeys, merge, setIndex, uuid} from \"./utils.js\";\r\nimport {\r\n\tINT_0,\r\n\tSTRING_A,\r\n\tSTRING_COMMA,\r\n\tSTRING_DEL,\r\n\tSTRING_DOUBLE_PIPE,\r\n\tSTRING_EMPTY,\r\n\tSTRING_FUNCTION,\r\n\tSTRING_INDEXES,\r\n\tSTRING_INVALID_FIELD,\r\n\tSTRING_INVALID_TYPE,\r\n\tSTRING_PIPE,\r\n\tSTRING_RECORD_NOT_FOUND,\r\n\tSTRING_RECORDS,\r\n\tSTRING_REGISTRY,\r\n\tSTRING_SET,\r\n\tSTRING_SIZE\r\n} from \"./constants.js\";\r\n\r\nexport class Haro {\r\n    constructor({delimiter = STRING_PIPE, id = uuid(), index = [], key = \"\", versioning = false} = {}) {\r\n        this.data = new Map();\r\n        this.delimiter = delimiter;\r\n        this.id = id;\r\n        this.index = index;\r\n        this.indexes = new Map();\r\n        this.key = key;\r\n        this.versions = new Map();\r\n        this.versioning = versioning;\r\n\r\n        Object.defineProperty(this, STRING_REGISTRY, {\r\n            enumerable: true,\r\n            get: () => Array.from(this.data.keys())\r\n        });\r\n\r\n        Object.defineProperty(this, STRING_SIZE, {\r\n            enumerable: true,\r\n            get: () => this.data.size\r\n        });\r\n\r\n        return this.reindex();\r\n    }\r\n\r\n    batch(args, type = STRING_SET) {\r\n        const fn = type === STRING_DEL ? i => this.del(i, true) : i => this.set(null, i, true, true);\r\n\r\n        return this.onbatch(this.beforeBatch(args, type).map(fn), type);\r\n    }\r\n\r\n    beforeBatch(arg) {\r\n        return arg;\r\n    }\r\n\r\n    beforeClear() {\r\n    }\r\n\r\n    beforeDelete() {\r\n    }\r\n\r\n    beforeSet() {\r\n    }\r\n\r\n    clear() {\r\n        this.beforeClear();\r\n        this.data.clear();\r\n        this.indexes.clear();\r\n        this.versions.clear();\r\n        this.reindex().onclear();\r\n\r\n        return this;\r\n    }\r\n\r\n    del(key, batch = false) {\r\n        if (this.has(key) === false) {\r\n            throw new Error(STRING_RECORD_NOT_FOUND);\r\n        }\r\n\r\n        const og = this.get(key, true);\r\n\r\n        this.beforeDelete(key, batch);\r\n        delIndex(this.index, this.indexes, this.delimiter, key, og);\r\n        this.data.delete(key);\r\n        this.ondelete(key, batch);\r\n\r\n        if (this.versioning) {\r\n            this.versions.delete(key);\r\n        }\r\n    }\r\n\r\n    dump(type = STRING_RECORDS) {\r\n        let result;\r\n\r\n        if (type === STRING_RECORDS) {\r\n            result = Array.from(this.entries());\r\n        } else {\r\n            result = Array.from(this.indexes).map(i => {\r\n                i[1] = Array.from(i[1]).map(ii => {\r\n                    ii[1] = Array.from(ii[1]);\r\n\r\n                    return ii;\r\n                });\r\n\r\n                return i;\r\n            });\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    entries() {\r\n        return this.data.entries();\r\n    }\r\n\r\n    find(where = {}, raw = false) {\r\n        const key = Object.keys(where).sort((a, b) => a.localeCompare(b)).join(this.delimiter),\r\n            index = this.indexes.get(key) || new Map();\r\n        let result = [];\r\n\r\n        if (index.size > 0) {\r\n            const keys = indexKeys(key, this.delimiter, where);\r\n\r\n            result = Array.from(keys.reduce((a, v) => {\r\n                if (index.has(v)) {\r\n                    index.get(v).forEach(k => a.add(k));\r\n                }\r\n\r\n                return a;\r\n            }, new Set())).map(i => this.get(i, raw));\r\n        }\r\n\r\n        return raw ? result : this.list(...result);\r\n    }\r\n\r\n    filter(fn = () => void 0, raw = false) {\r\n        const x = raw ? (k, v) => v : (k, v) => Object.freeze([k, Object.freeze(v)]),\r\n            result = this.reduce((a, v, k, ctx) => {\r\n                if (fn.call(ctx, v)) {\r\n                    a.push(x(k, v));\r\n                }\r\n\r\n                return a;\r\n            }, []);\r\n\r\n        return raw ? result : Object.freeze(result);\r\n    }\r\n\r\n    forEach(fn, ctx) {\r\n        this.data.forEach((value, key) => fn(clone(value), clone(key)), ctx || this.data);\r\n\r\n        return this;\r\n    }\r\n\r\n    get(key, raw = false) {\r\n        const result = clone(this.data.get(key) || null);\r\n\r\n        return raw ? result : this.list(key, result);\r\n    }\r\n\r\n    has(key) {\r\n        return this.data.has(key);\r\n    }\r\n\r\n    keys() {\r\n        return this.data.keys();\r\n    }\r\n\r\n    limit(offset = INT_0, max = INT_0, raw = false) {\r\n        const result = this.registry.slice(offset, offset + max).map(i => this.get(i, raw));\r\n\r\n        return raw ? result : this.list(...result);\r\n    }\r\n\r\n    list(...args) {\r\n        return Object.freeze(args.map(i => Object.freeze(i)));\r\n    }\r\n\r\n    map(fn, raw = false) {\r\n        const result = [];\r\n\r\n        this.forEach((value, key) => result.push(fn(value, key)));\r\n\r\n        return raw ? result : this.list(...result);\r\n    }\r\n\r\n    onbatch(arg) {\r\n        return arg;\r\n    }\r\n\r\n    onclear() {\r\n    }\r\n\r\n    ondelete() {\r\n    }\r\n\r\n    onoverride() {\r\n    }\r\n\r\n    onset() {\r\n    }\r\n\r\n    override(data, type = STRING_RECORDS) {\r\n        const result = true;\r\n\r\n        if (type === STRING_INDEXES) {\r\n            this.indexes = new Map(data.map(i => [i[0], new Map(i[1].map(ii => [ii[0], new Set(ii[1])]))]));\r\n        } else if (type === STRING_RECORDS) {\r\n            this.indexes.clear();\r\n            this.data = new Map(data);\r\n        } else {\r\n            throw new Error(STRING_INVALID_TYPE);\r\n        }\r\n\r\n        this.onoverride(type);\r\n\r\n        return result;\r\n    }\r\n\r\n    reduce(fn, accumulator, raw = false) {\r\n        let a = accumulator || this.data.keys().next().value;\r\n\r\n        this.forEach((v, k) => {\r\n            a = fn(a, v, k, this, raw);\r\n        }, this);\r\n\r\n        return a;\r\n    }\r\n\r\n    reindex(index) {\r\n        const indices = index ? [index] : this.index;\r\n\r\n        if (index && this.index.includes(index) === false) {\r\n            this.index.push(index);\r\n        }\r\n\r\n        each(indices, i => this.indexes.set(i, new Map()));\r\n        this.forEach((data, key) => each(indices, i => setIndex(this.index, this.indexes, this.delimiter, key, data, i)));\r\n\r\n        return this;\r\n    }\r\n\r\n    search(value, index, raw = false) {\r\n        const result = new Map(),\r\n            fn = typeof value === STRING_FUNCTION,\r\n            rgex = value && typeof value.test === STRING_FUNCTION;\r\n\r\n        if (value) {\r\n            each(index ? Array.isArray(index) ? index : [index] : this.index, i => {\r\n                let idx = this.indexes.get(i);\r\n\r\n                if (idx) {\r\n                    idx.forEach((lset, lkey) => {\r\n                        switch (true) {\r\n                            case fn && value(lkey, i):\r\n                            case rgex && value.test(Array.isArray(lkey) ? lkey.join(STRING_COMMA) : lkey):\r\n                            case lkey === value:\r\n                                lset.forEach(key => {\r\n                                    if (result.has(key) === false && this.has(key)) {\r\n                                        result.set(key, this.get(key, raw));\r\n                                    }\r\n                                });\r\n                                break;\r\n                            default:\r\n                                void 0;\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        return raw ? Array.from(result.values()) : this.list(...Array.from(result.values()));\r\n    }\r\n\r\n    set(key = null, data = {}, batch = false, override = false) {\r\n        let x = clone(data),\r\n            og, result;\r\n\r\n        if (key === null) {\r\n            if (this.key in x) {\r\n                key = x[this.key];\r\n            } else {\r\n                x[this.key] = key = uuid();\r\n            }\r\n        }\r\n\r\n        this.beforeSet(key, data, batch, override);\r\n\r\n        if (this.has(key) === false) {\r\n            if (this.versioning) {\r\n                this.versions.set(key, new Set());\r\n            }\r\n        } else {\r\n            og = this.get(key, true);\r\n            delIndex(this.index, this.indexes, this.delimiter, key, og);\r\n\r\n            if (this.versioning) {\r\n                this.versions.get(key).add(Object.freeze(clone(og)));\r\n            }\r\n\r\n            if (override === false) {\r\n                x = merge(clone(og), x);\r\n            }\r\n        }\r\n\r\n        this.data.set(key, x);\r\n        setIndex(this.index, this.indexes, this.delimiter, key, x, null);\r\n        result = this.get(key);\r\n        this.onset(result, batch);\r\n\r\n        return result;\r\n    }\r\n\r\n    sort(fn, frozen = true) {\r\n        return frozen ? Object.freeze(this.limit(INT_0, this.data.size, true).sort(fn).map(i => Object.freeze(i))) : this.limit(INT_0, this.data.size, true).sort(fn);\r\n    }\r\n\r\n    sortBy(index = STRING_EMPTY, raw = false) {\r\n        if (index === STRING_EMPTY) {\r\n            throw new Error(STRING_INVALID_FIELD)\r\n        }\r\n\r\n        const result = [],\r\n            keys = [];\r\n\r\n        if (this.indexes.has(index) === false) {\r\n            this.reindex(index);\r\n        }\r\n\r\n        const lindex = this.indexes.get(index);\r\n\r\n        lindex.forEach((idx, key) => keys.push(key));\r\n        each(keys.sort(), i => lindex.get(i).forEach(key => result.push(this.get(key, raw))));\r\n\r\n        return raw ? result : this.list(...result);\r\n    }\r\n\r\n    toArray(frozen = true) {\r\n        const result = Array.from(this.data.values());\r\n\r\n        if (frozen) {\r\n            each(result, i => Object.freeze(i));\r\n            Object.freeze(result);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    values() {\r\n        return this.data.values();\r\n    }\r\n\r\n    where(predicate, raw = false, op = STRING_DOUBLE_PIPE) {\r\n        const keys = this.index.filter(i => i in predicate);\r\n\r\n        return keys.length > INT_0 ? this.filter(new Function(STRING_A, `return (${keys.map(i => {\r\n            let result;\r\n\r\n            if (Array.isArray(predicate[i])) {\r\n                result = `Array.isArray(a['${i}']) ? ${predicate[i].map(arg => `a['${i}'].includes(${typeof arg === \"string\" ? `'${arg}'` : arg})`).join(` ${op} `)} : (${predicate[i].map(arg => `a['${i}'] === ${typeof arg === \"string\" ? `'${arg}'` : arg}`).join(` ${op} `)})`;\r\n            } else if (predicate[i] instanceof RegExp) {\r\n                result = `Array.isArray(a['${i}']) ? a['${i}'].filter(i => ${predicate[i]}.test(a['${i}'])).length > 0 : ${predicate[i]}.test(a['${i}'])`;\r\n            } else {\r\n                const arg = typeof predicate[i] === \"string\" ? `'${predicate[i]}'` : predicate[i];\r\n\r\n                result = `Array.isArray(a['${i}']) ? a['${i}'].includes(${arg}) : a['${i}'] === ${arg}`;\r\n            }\r\n\r\n            return result;\r\n        }).join(\") && (\")});`), raw) : [];\r\n    }\r\n}\r\n\r\nexport function haro(data = null, config = {}) {\r\n    const obj = new Haro(config);\r\n\r\n    if (Array.isArray(data)) {\r\n        obj.batch(data, STRING_SET);\r\n    }\r\n\r\n    return obj;\r\n}\r\n"],"names":["STRING_EMPTY","STRING_PIPE","STRING_FUNCTION","STRING_RECORDS","INT_0","r","clone","structuredClone","arg","JSON","parse","stringify","each","arr","fn","idx","value","entries","indexKeys","delimiter","data","split","reduce","a","li","lidx","result","Array","isArray","forEach","lli","push","x","delIndex","index","indexes","key","i","get","includes","has","o","delete","size","merge","b","Object","keys","concat","s","Math","random","toString","substring","setIndex","indice","lindex","c","set","Set","add","d","uuid","crypto","randomUUID","slice","floor","Haro","constructor","id","versioning","this","Map","versions","defineProperty","enumerable","from","reindex","batch","args","type","del","onbatch","beforeBatch","map","beforeClear","beforeDelete","beforeSet","clear","onclear","Error","og","ondelete","dump","ii","find","where","raw","sort","localeCompare","join","v","k","list","filter","freeze","ctx","call","limit","offset","max","registry","onoverride","onset","override","accumulator","next","indices","search","rgex","test","lset","lkey","values","frozen","sortBy","toArray","predicate","op","length","Function","RegExp","exports","haro","config","obj"],"mappings":"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"}