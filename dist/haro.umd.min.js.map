{"version":3,"file":"haro.umd.min.js","sources":["../src/constants.js","../src/utils.js","../src/haro.js"],"sourcesContent":["export const STRING_COMMA = \",\";\r\nexport const STRING_EMPTY = \"\";\r\nexport const STRING_PIPE = \"|\";\r\nexport const STRING_DOUBLE_PIPE = \"||\";\r\nexport const STRING_A = \"a\";\r\nexport const STRING_B = \"b\";\r\nexport const STRING_DEL = \"del\";\r\nexport const STRING_FUNCTION = \"function\";\r\nexport const STRING_INDEXES = \"indexes\";\r\nexport const STRING_INVALID_FIELD = \"Invalid field\";\r\nexport const STRING_INVALID_TYPE = \"Invalid type\";\r\nexport const STRING_OBJECT = \"object\";\r\nexport const STRING_RECORD_NOT_FOUND = \"Record not found\";\r\nexport const STRING_RECORDS = \"records\";\r\nexport const STRING_REGISTRY = \"registry\";\r\nexport const STRING_SET = \"set\";\r\nexport const STRING_SIZE = \"size\";\r\nexport const INT_0 = 0;\r\nexport const INT_1 = 1;\r\nexport const INT_3 = 3;\r\nexport const INT_4 = 4;\r\nexport const INT_8 = 8;\r\nexport const INT_9 = 9;\r\nexport const INT_16 = 16;","import {\r\n    INT_0,\r\n    INT_1,\r\n    INT_16,\r\n    INT_3,\r\n    INT_4,\r\n    INT_8,\r\n    INT_9,\r\n    STRING_A,\r\n    STRING_B,\r\n    STRING_EMPTY,\r\n    STRING_OBJECT,\r\n    STRING_PIPE\r\n} from \"./constants.js\";\r\n\r\nconst r = [INT_8, INT_9, STRING_A, STRING_B];\r\n\r\nexport const clone = structuredClone ?? function shallowClone(arg) {\r\n    return JSON.parse(JSON.stringify(arg, null, INT_0));\r\n};\r\n\r\nexport function each(arr = [], fn) {\r\n    for (const [idx, value] of arr.entries()) {\r\n        fn(value, idx);\r\n    }\r\n\r\n    return arr;\r\n}\r\n\r\nexport function indexKeys(arg = STRING_EMPTY, delimiter = STRING_PIPE, data = {}) {\r\n    return arg.split(delimiter).reduce((a, li, lidx) => {\r\n        const result = [];\r\n\r\n        (Array.isArray(data[li]) ? data[li] : [data[li]]).forEach(lli => lidx === INT_0 ? result.push(lli) : a.forEach(x => result.push(`${x}${delimiter}${lli}`)));\r\n\r\n        return result;\r\n    }, []);\r\n}\r\n\r\nexport function delIndex(index, indexes, delimiter, key, data) {\r\n    index.forEach(i => {\r\n        const idx = indexes.get(i);\r\n\r\n        each(i.includes(delimiter) ? indexKeys(i, delimiter, data) : Array.isArray(data[i]) ? data[i] : [data[i]], value => {\r\n            if (idx.has(value)) {\r\n                const o = idx.get(value);\r\n\r\n                o.delete(key);\r\n\r\n                if (o.size === INT_0) {\r\n                    idx.delete(value);\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nexport function merge(a, b) {\r\n    if (a instanceof Object && b instanceof Object) {\r\n        each(Object.keys(b), i => {\r\n            if (a[i] instanceof Object && b[i] instanceof Object) {\r\n                a[i] = merge(a[i], b[i]);\r\n            } else if (Array.isArray(a[i]) && Array.isArray(b[i])) {\r\n                a[i] = a[i].concat(b[i]);\r\n            } else {\r\n                a[i] = b[i];\r\n            }\r\n        });\r\n    } else if (Array.isArray(a) && Array.isArray(b)) {\r\n        a = a.concat(b);\r\n    } else {\r\n        a = b;\r\n    }\r\n\r\n    return a;\r\n}\r\n\r\nexport function s() {\r\n    return ((Math.random() + INT_1) * 0x10000 | INT_0).toString(INT_16).substring(INT_1);\r\n}\r\n\r\nexport function setIndex(index, indexes, delimiter, key, data, indice) {\r\n    each(indice === null ? index : [indice], i => {\r\n        const lindex = indexes.get(i);\r\n\r\n        if (i.includes(delimiter)) {\r\n            each(indexKeys(i, delimiter, data), c => {\r\n                if (lindex.has(c) === false) {\r\n                    lindex.set(c, new Set());\r\n                }\r\n\r\n                lindex.get(c).add(key);\r\n            });\r\n        } else {\r\n            each(Array.isArray(data[i]) ? data[i] : [data[i]], d => {\r\n                if (lindex.has(d) === false) {\r\n                    lindex.set(d, new Set());\r\n                }\r\n\r\n                lindex.get(d).add(key);\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nexport const uuid = typeof crypto === STRING_OBJECT ? crypto.randomUUID.bind(crypto) : () => `${s()}${s()}-${s()}-4${s().slice(INT_0, INT_3)}-${r[Math.floor(Math.random() * INT_4)]}${s().slice(INT_0, INT_3)}-${s()}${s()}${s()}`;\r\n","import {clone, delIndex, each, indexKeys, merge, setIndex, uuid} from \"./utils.js\";\r\nimport {\r\n\tINT_0,\r\n\tSTRING_A,\r\n\tSTRING_COMMA,\r\n\tSTRING_DEL,\r\n\tSTRING_DOUBLE_PIPE,\r\n\tSTRING_EMPTY,\r\n\tSTRING_FUNCTION,\r\n\tSTRING_INDEXES,\r\n\tSTRING_INVALID_FIELD,\r\n\tSTRING_INVALID_TYPE,\r\n\tSTRING_PIPE,\r\n\tSTRING_RECORD_NOT_FOUND,\r\n\tSTRING_RECORDS,\r\n\tSTRING_REGISTRY,\r\n\tSTRING_SET,\r\n\tSTRING_SIZE\r\n} from \"./constants.js\";\r\n\r\nexport class Haro {\r\n    constructor({delimiter = STRING_PIPE, id = uuid(), index = [], key = STRING_EMPTY, versioning = false} = {}) {\r\n        this.data = new Map();\r\n        this.delimiter = delimiter;\r\n        this.id = id;\r\n        this.index = index;\r\n        this.indexes = new Map();\r\n        this.key = key;\r\n        this.versions = new Map();\r\n        this.versioning = versioning;\r\n\r\n        Object.defineProperty(this, STRING_REGISTRY, {\r\n            enumerable: true,\r\n            get: () => Array.from(this.data.keys())\r\n        });\r\n\r\n        Object.defineProperty(this, STRING_SIZE, {\r\n            enumerable: true,\r\n            get: () => this.data.size\r\n        });\r\n\r\n        return this.reindex();\r\n    }\r\n\r\n    batch(args, type = STRING_SET) {\r\n        const fn = type === STRING_DEL ? i => this.del(i, true) : i => this.set(null, i, true, true);\r\n\r\n        return this.onbatch(this.beforeBatch(args, type).map(fn), type);\r\n    }\r\n\r\n    beforeBatch(arg) {\r\n        return arg;\r\n    }\r\n\r\n    beforeClear() {\r\n    }\r\n\r\n    beforeDelete() {\r\n    }\r\n\r\n    beforeSet() {\r\n    }\r\n\r\n    clear() {\r\n        this.beforeClear();\r\n        this.data.clear();\r\n        this.indexes.clear();\r\n        this.versions.clear();\r\n        this.reindex().onclear();\r\n\r\n        return this;\r\n    }\r\n\r\n    del(key, batch = false) {\r\n        if (this.has(key) === false) {\r\n            throw new Error(STRING_RECORD_NOT_FOUND);\r\n        }\r\n\r\n        const og = this.get(key, true);\r\n\r\n        this.beforeDelete(key, batch);\r\n        delIndex(this.index, this.indexes, this.delimiter, key, og);\r\n        this.data.delete(key);\r\n        this.ondelete(key, batch);\r\n\r\n        if (this.versioning) {\r\n            this.versions.delete(key);\r\n        }\r\n    }\r\n\r\n    dump(type = STRING_RECORDS) {\r\n        let result;\r\n\r\n        if (type === STRING_RECORDS) {\r\n            result = Array.from(this.entries());\r\n        } else {\r\n            result = Array.from(this.indexes).map(i => {\r\n                i[1] = Array.from(i[1]).map(ii => {\r\n                    ii[1] = Array.from(ii[1]);\r\n\r\n                    return ii;\r\n                });\r\n\r\n                return i;\r\n            });\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    entries() {\r\n        return this.data.entries();\r\n    }\r\n\r\n    find(where = {}, raw = false) {\r\n        const key = Object.keys(where).sort((a, b) => a.localeCompare(b)).join(this.delimiter),\r\n            index = this.indexes.get(key) || new Map();\r\n        let result = [];\r\n\r\n        if (index.size > 0) {\r\n            const keys = indexKeys(key, this.delimiter, where);\r\n\r\n            result = Array.from(keys.reduce((a, v) => {\r\n                if (index.has(v)) {\r\n                    index.get(v).forEach(k => a.add(k));\r\n                }\r\n\r\n                return a;\r\n            }, new Set())).map(i => this.get(i, raw));\r\n        }\r\n\r\n        return raw ? result : this.list(...result);\r\n    }\r\n\r\n    filter(fn = () => void 0, raw = false) {\r\n        const x = raw ? (k, v) => v : (k, v) => Object.freeze([k, Object.freeze(v)]),\r\n            result = this.reduce((a, v, k, ctx) => {\r\n                if (fn.call(ctx, v)) {\r\n                    a.push(x(k, v));\r\n                }\r\n\r\n                return a;\r\n            }, []);\r\n\r\n        return raw ? result : Object.freeze(result);\r\n    }\r\n\r\n    forEach(fn, ctx) {\r\n        this.data.forEach((value, key) => fn(clone(value), clone(key)), ctx || this.data);\r\n\r\n        return this;\r\n    }\r\n\r\n    get(key, raw = false) {\r\n        const result = clone(this.data.get(key) || null);\r\n\r\n        return raw ? result : this.list(key, result);\r\n    }\r\n\r\n    has(key) {\r\n        return this.data.has(key);\r\n    }\r\n\r\n    keys() {\r\n        return this.data.keys();\r\n    }\r\n\r\n    limit(offset = INT_0, max = INT_0, raw = false) {\r\n        const result = this.registry.slice(offset, offset + max).map(i => this.get(i, raw));\r\n\r\n        return raw ? result : this.list(...result);\r\n    }\r\n\r\n    list(...args) {\r\n        return Object.freeze(args.map(i => Object.freeze(i)));\r\n    }\r\n\r\n    map(fn, raw = false) {\r\n        const result = [];\r\n\r\n        this.forEach((value, key) => result.push(fn(value, key)));\r\n\r\n        return raw ? result : this.list(...result);\r\n    }\r\n\r\n    onbatch(arg) {\r\n        return arg;\r\n    }\r\n\r\n    onclear() {\r\n    }\r\n\r\n    ondelete() {\r\n    }\r\n\r\n    onoverride() {\r\n    }\r\n\r\n    onset() {\r\n    }\r\n\r\n    override(data, type = STRING_RECORDS) {\r\n        const result = true;\r\n\r\n        if (type === STRING_INDEXES) {\r\n            this.indexes = new Map(data.map(i => [i[0], new Map(i[1].map(ii => [ii[0], new Set(ii[1])]))]));\r\n        } else if (type === STRING_RECORDS) {\r\n            this.indexes.clear();\r\n            this.data = new Map(data);\r\n        } else {\r\n            throw new Error(STRING_INVALID_TYPE);\r\n        }\r\n\r\n        this.onoverride(type);\r\n\r\n        return result;\r\n    }\r\n\r\n    reduce(fn, accumulator, raw = false) {\r\n        let a = accumulator || this.data.keys().next().value;\r\n\r\n        this.forEach((v, k) => {\r\n            a = fn(a, v, k, this, raw);\r\n        }, this);\r\n\r\n        return a;\r\n    }\r\n\r\n    reindex(index) {\r\n        const indices = index ? [index] : this.index;\r\n\r\n        if (index && this.index.includes(index) === false) {\r\n            this.index.push(index);\r\n        }\r\n\r\n        each(indices, i => this.indexes.set(i, new Map()));\r\n        this.forEach((data, key) => each(indices, i => setIndex(this.index, this.indexes, this.delimiter, key, data, i)));\r\n\r\n        return this;\r\n    }\r\n\r\n    search(value, index, raw = false) {\r\n        const result = new Map(),\r\n            fn = typeof value === STRING_FUNCTION,\r\n            rgex = value && typeof value.test === STRING_FUNCTION;\r\n\r\n        if (value) {\r\n            each(index ? Array.isArray(index) ? index : [index] : this.index, i => {\r\n                let idx = this.indexes.get(i);\r\n\r\n                if (idx) {\r\n                    idx.forEach((lset, lkey) => {\r\n                        switch (true) {\r\n                            case fn && value(lkey, i):\r\n                            case rgex && value.test(Array.isArray(lkey) ? lkey.join(STRING_COMMA) : lkey):\r\n                            case lkey === value:\r\n                                lset.forEach(key => {\r\n                                    if (result.has(key) === false && this.has(key)) {\r\n                                        result.set(key, this.get(key, raw));\r\n                                    }\r\n                                });\r\n                                break;\r\n                            default:\r\n                                void 0;\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        return raw ? Array.from(result.values()) : this.list(...Array.from(result.values()));\r\n    }\r\n\r\n    set(key = null, data = {}, batch = false, override = false) {\r\n        let x = clone(data),\r\n            og, result;\r\n\r\n        if (key === null) {\r\n            if (this.key in x) {\r\n                key = x[this.key];\r\n            } else {\r\n                x[this.key] = key = uuid();\r\n            }\r\n        }\r\n\r\n        this.beforeSet(key, data, batch, override);\r\n\r\n        if (this.has(key) === false) {\r\n            if (this.versioning) {\r\n                this.versions.set(key, new Set());\r\n            }\r\n        } else {\r\n            og = this.get(key, true);\r\n            delIndex(this.index, this.indexes, this.delimiter, key, og);\r\n\r\n            if (this.versioning) {\r\n                this.versions.get(key).add(Object.freeze(clone(og)));\r\n            }\r\n\r\n            if (override === false) {\r\n                x = merge(clone(og), x);\r\n            }\r\n        }\r\n\r\n        this.data.set(key, x);\r\n        setIndex(this.index, this.indexes, this.delimiter, key, x, null);\r\n        result = this.get(key);\r\n        this.onset(result, batch);\r\n\r\n        return result;\r\n    }\r\n\r\n    sort(fn, frozen = true) {\r\n        return frozen ? Object.freeze(this.limit(INT_0, this.data.size, true).sort(fn).map(i => Object.freeze(i))) : this.limit(INT_0, this.data.size, true).sort(fn);\r\n    }\r\n\r\n    sortBy(index = STRING_EMPTY, raw = false) {\r\n        if (index === STRING_EMPTY) {\r\n            throw new Error(STRING_INVALID_FIELD)\r\n        }\r\n\r\n        const result = [],\r\n            keys = [];\r\n\r\n        if (this.indexes.has(index) === false) {\r\n            this.reindex(index);\r\n        }\r\n\r\n        const lindex = this.indexes.get(index);\r\n\r\n        lindex.forEach((idx, key) => keys.push(key));\r\n        each(keys.sort(), i => lindex.get(i).forEach(key => result.push(this.get(key, raw))));\r\n\r\n        return raw ? result : this.list(...result);\r\n    }\r\n\r\n    toArray(frozen = true) {\r\n        const result = Array.from(this.data.values());\r\n\r\n        if (frozen) {\r\n            each(result, i => Object.freeze(i));\r\n            Object.freeze(result);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    values() {\r\n        return this.data.values();\r\n    }\r\n\r\n    where(predicate = {}, raw = false, op = STRING_DOUBLE_PIPE) {\r\n        const keys = this.index.filter(i => i in predicate);\r\n\r\n        return keys.length > INT_0 ? this.filter(new Function(STRING_A, `return (${keys.map(i => {\r\n            let result;\r\n\r\n            if (Array.isArray(predicate[i])) {\r\n                result = `Array.isArray(a['${i}']) ? ${predicate[i].map(arg => `a['${i}'].includes(${typeof arg === \"string\" ? `'${arg}'` : arg})`).join(` ${op} `)} : (${predicate[i].map(arg => `a['${i}'] === ${typeof arg === \"string\" ? `'${arg}'` : arg}`).join(` ${op} `)})`;\r\n            } else if (predicate[i] instanceof RegExp) {\r\n                result = `Array.isArray(a['${i}']) ? a['${i}'].filter(i => ${predicate[i]}.test(a['${i}'])).length > 0 : ${predicate[i]}.test(a['${i}'])`;\r\n            } else {\r\n                const arg = typeof predicate[i] === \"string\" ? `'${predicate[i]}'` : predicate[i];\r\n\r\n                result = `Array.isArray(a['${i}']) ? a['${i}'].includes(${arg}) : a['${i}'] === ${arg}`;\r\n            }\r\n\r\n            return result;\r\n        }).join(\") && (\")});`), raw) : [];\r\n    }\r\n}\r\n\r\nexport function haro(data = null, config = {}) {\r\n    const obj = new Haro(config);\r\n\r\n    if (Array.isArray(data)) {\r\n        obj.batch(data, STRING_SET);\r\n    }\r\n\r\n    return obj;\r\n}\r\n"],"names":["STRING_EMPTY","STRING_PIPE","STRING_FUNCTION","STRING_RECORDS","INT_0","r","clone","structuredClone","arg","JSON","parse","stringify","each","arr","fn","idx","value","entries","indexKeys","delimiter","data","split","reduce","a","li","lidx","result","Array","isArray","forEach","lli","push","x","delIndex","index","indexes","key","i","get","includes","has","o","delete","size","merge","b","Object","keys","concat","s","Math","random","toString","substring","setIndex","indice","lindex","c","set","Set","add","d","uuid","crypto","randomUUID","bind","slice","floor","Haro","constructor","id","versioning","this","Map","versions","defineProperty","enumerable","from","reindex","batch","args","type","del","onbatch","beforeBatch","map","beforeClear","beforeDelete","beforeSet","clear","onclear","Error","og","ondelete","dump","ii","find","where","raw","sort","localeCompare","join","v","k","list","filter","freeze","ctx","call","limit","offset","max","registry","onoverride","onset","override","accumulator","next","indices","search","rgex","test","lset","lkey","values","frozen","sortBy","toArray","predicate","op","length","Function","RegExp","exports","haro","config","obj"],"mappings":";;;;2OAAO,MACMA,EAAe,GACfC,EAAc,IAKdC,EAAkB,WAMlBC,EAAiB,UAIjBC,EAAQ,ECFfC,EAAI,CDMW,EACA,EAlBG,IACA,KCYXC,EAAQC,iBAAmB,SAAsBC,GAC1D,OAAOC,KAAKC,MAAMD,KAAKE,UAAUH,EAAK,KAAMJ,GAChD,EAEO,SAASQ,EAAKC,EAAM,GAAIC,GAC3B,IAAK,MAAOC,EAAKC,KAAUH,EAAII,UAC3BH,EAAGE,EAAOD,GAGd,OAAOF,CACX,CAEO,SAASK,EAAUV,EAAMR,EAAcmB,EAAYlB,EAAamB,EAAO,IAC1E,OAAOZ,EAAIa,MAAMF,GAAWG,QAAO,CAACC,EAAGC,EAAIC,KACvC,MAAMC,EAAS,GAIf,OAFCC,MAAMC,QAAQR,EAAKI,IAAOJ,EAAKI,GAAM,CAACJ,EAAKI,KAAMK,SAAQC,GAAOL,IAASrB,EAAQsB,EAAOK,KAAKD,GAAOP,EAAEM,SAAQG,GAAKN,EAAOK,KAAK,GAAGC,IAAIb,IAAYW,SAE5IJ,CAAM,GACd,GACP,CAEO,SAASO,EAASC,EAAOC,EAAShB,EAAWiB,EAAKhB,GACrDc,EAAML,SAAQQ,IACV,MAAMtB,EAAMoB,EAAQG,IAAID,GAExBzB,EAAKyB,EAAEE,SAASpB,GAAaD,EAAUmB,EAAGlB,EAAWC,GAAQO,MAAMC,QAAQR,EAAKiB,IAAMjB,EAAKiB,GAAK,CAACjB,EAAKiB,KAAKrB,IACvG,GAAID,EAAIyB,IAAIxB,GAAQ,CAChB,MAAMyB,EAAI1B,EAAIuB,IAAItB,GAElByB,EAAEC,OAAON,GAELK,EAAEE,OAASvC,GACXW,EAAI2B,OAAO1B,EAElB,IACH,GAEV,CAEO,SAAS4B,EAAMrB,EAAGsB,GAiBrB,OAhBItB,aAAauB,QAAUD,aAAaC,OACpClC,EAAKkC,OAAOC,KAAKF,IAAIR,IACbd,EAAEc,aAAcS,QAAUD,EAAER,aAAcS,OAC1CvB,EAAEc,GAAKO,EAAMrB,EAAEc,GAAIQ,EAAER,IACdV,MAAMC,QAAQL,EAAEc,KAAOV,MAAMC,QAAQiB,EAAER,IAC9Cd,EAAEc,GAAKd,EAAEc,GAAGW,OAAOH,EAAER,IAErBd,EAAEc,GAAKQ,EAAER,EACZ,IAGLd,EADOI,MAAMC,QAAQL,IAAMI,MAAMC,QAAQiB,GACrCtB,EAAEyB,OAAOH,GAETA,EAGDtB,CACX,CAEO,SAAS0B,IACZ,OAAkC,OAAzBC,KAAKC,SD5DG,GC4D2B/C,GAAOgD,SDvDjC,ICuDkDC,UD5DnD,EC6DrB,CAEO,SAASC,EAASpB,EAAOC,EAAShB,EAAWiB,EAAKhB,EAAMmC,GAC3D3C,EAAgB,OAAX2C,EAAkBrB,EAAQ,CAACqB,IAASlB,IACrC,MAAMmB,EAASrB,EAAQG,IAAID,GAEvBA,EAAEE,SAASpB,GACXP,EAAKM,EAAUmB,EAAGlB,EAAWC,IAAOqC,KACV,IAAlBD,EAAOhB,IAAIiB,IACXD,EAAOE,IAAID,EAAG,IAAIE,KAGtBH,EAAOlB,IAAImB,GAAGG,IAAIxB,EAAI,IAG1BxB,EAAKe,MAAMC,QAAQR,EAAKiB,IAAMjB,EAAKiB,GAAK,CAACjB,EAAKiB,KAAKwB,KACzB,IAAlBL,EAAOhB,IAAIqB,IACXL,EAAOE,IAAIG,EAAG,IAAIF,KAGtBH,EAAOlB,IAAIuB,GAAGD,IAAIxB,EAAI,GAE7B,GAET,CAEO,MAAM0B,ED9FgB,iBC8FFC,OAA2BA,OAAOC,WAAWC,KAAKF,QAAU,IAAM,GAAGd,MAAMA,OAAOA,QAAQA,IAAIiB,MAAM9D,EDtF1G,MCsF2HC,EAAE6C,KAAKiB,MDrFlI,ECqFwIjB,KAAKC,aAAqBF,IAAIiB,MAAM9D,EDtF5K,MCsF6L6C,MAAMA,MAAMA,MCrFvN,MAAMmB,EACT,WAAAC,EAAYlD,UAACA,EAAYlB,EAAWqE,GAAEA,EAAKR,IAAM5B,MAAEA,EAAQ,GAAEE,IAAEA,EAAMpC,EAAYuE,WAAEA,GAAa,GAAS,CAAA,GAoBrG,OAnBAC,KAAKpD,KAAO,IAAIqD,IAChBD,KAAKrD,UAAYA,EACjBqD,KAAKF,GAAKA,EACVE,KAAKtC,MAAQA,EACbsC,KAAKrC,QAAU,IAAIsC,IACnBD,KAAKpC,IAAMA,EACXoC,KAAKE,SAAW,IAAID,IACpBD,KAAKD,WAAaA,EAElBzB,OAAO6B,eAAeH,KFjBC,WEiBsB,CACzCI,YAAY,EACZtC,IAAK,IAAMX,MAAMkD,KAAKL,KAAKpD,KAAK2B,UAGpCD,OAAO6B,eAAeH,KFpBH,OEoBsB,CACrCI,YAAY,EACZtC,IAAK,IAAMkC,KAAKpD,KAAKuB,OAGlB6B,KAAKM,SACf,CAED,KAAAC,CAAMC,EAAMC,EF7BU,OE8BlB,MAAMnE,EFvCY,QEuCPmE,EAAsB5C,GAAKmC,KAAKU,IAAI7C,GAAG,GAAQA,GAAKmC,KAAKd,IAAI,KAAMrB,GAAG,GAAM,GAEvF,OAAOmC,KAAKW,QAAQX,KAAKY,YAAYJ,EAAMC,GAAMI,IAAIvE,GAAKmE,EAC7D,CAED,WAAAG,CAAY5E,GACR,OAAOA,CACV,CAED,WAAA8E,GACC,CAED,YAAAC,GACC,CAED,SAAAC,GACC,CAED,KAAAC,GAOI,OANAjB,KAAKc,cACLd,KAAKpD,KAAKqE,QACVjB,KAAKrC,QAAQsD,QACbjB,KAAKE,SAASe,QACdjB,KAAKM,UAAUY,UAERlB,IACV,CAED,GAAAU,CAAI9C,EAAK2C,GAAQ,GACb,IAAsB,IAAlBP,KAAKhC,IAAIJ,GACT,MAAM,IAAIuD,MF/DiB,oBEkE/B,MAAMC,EAAKpB,KAAKlC,IAAIF,GAAK,GAEzBoC,KAAKe,aAAanD,EAAK2C,GACvB9C,EAASuC,KAAKtC,MAAOsC,KAAKrC,QAASqC,KAAKrD,UAAWiB,EAAKwD,GACxDpB,KAAKpD,KAAKsB,OAAON,GACjBoC,KAAKqB,SAASzD,EAAK2C,GAEfP,KAAKD,YACLC,KAAKE,SAAShC,OAAON,EAE5B,CAED,IAAA0D,CAAKb,EAAO9E,GACR,IAAIuB,EAgBJ,OAbIA,EADAuD,IAAS9E,EACAwB,MAAMkD,KAAKL,KAAKvD,WAEhBU,MAAMkD,KAAKL,KAAKrC,SAASkD,KAAIhD,IAClCA,EAAE,GAAKV,MAAMkD,KAAKxC,EAAE,IAAIgD,KAAIU,IACxBA,EAAG,GAAKpE,MAAMkD,KAAKkB,EAAG,IAEfA,KAGJ1D,KAIRX,CACV,CAED,OAAAT,GACI,OAAOuD,KAAKpD,KAAKH,SACpB,CAED,IAAA+E,CAAKC,EAAQ,GAAIC,GAAM,GACnB,MAAM9D,EAAMU,OAAOC,KAAKkD,GAAOE,MAAK,CAAC5E,EAAGsB,IAAMtB,EAAE6E,cAAcvD,KAAIwD,KAAK7B,KAAKrD,WACxEe,EAAQsC,KAAKrC,QAAQG,IAAIF,IAAQ,IAAIqC,IACzC,IAAI/C,EAAS,GAEb,GAAIQ,EAAMS,KAAO,EAAG,CAChB,MAAMI,EAAO7B,EAAUkB,EAAKoC,KAAKrD,UAAW8E,GAE5CvE,EAASC,MAAMkD,KAAK9B,EAAKzB,QAAO,CAACC,EAAG+E,KAC5BpE,EAAMM,IAAI8D,IACVpE,EAAMI,IAAIgE,GAAGzE,SAAQ0E,GAAKhF,EAAEqC,IAAI2C,KAG7BhF,IACR,IAAIoC,MAAQ0B,KAAIhD,GAAKmC,KAAKlC,IAAID,EAAG6D,IACvC,CAED,OAAOA,EAAMxE,EAAS8C,KAAKgC,QAAQ9E,EACtC,CAED,MAAA+E,CAAO3F,EAAK,MAAY,GAAEoF,GAAM,GAC5B,MAAMlE,EAAIkE,EAAM,CAACK,EAAGD,IAAMA,EAAI,CAACC,EAAGD,IAAMxD,OAAO4D,OAAO,CAACH,EAAGzD,OAAO4D,OAAOJ,KACpE5E,EAAS8C,KAAKlD,QAAO,CAACC,EAAG+E,EAAGC,EAAGI,KACvB7F,EAAG8F,KAAKD,EAAKL,IACb/E,EAAEQ,KAAKC,EAAEuE,EAAGD,IAGT/E,IACR,IAEP,OAAO2E,EAAMxE,EAASoB,OAAO4D,OAAOhF,EACvC,CAED,OAAAG,CAAQf,EAAI6F,GAGR,OAFAnC,KAAKpD,KAAKS,SAAQ,CAACb,EAAOoB,IAAQtB,EAAGR,EAAMU,GAAQV,EAAM8B,KAAOuE,GAAOnC,KAAKpD,MAErEoD,IACV,CAED,GAAAlC,CAAIF,EAAK8D,GAAM,GACX,MAAMxE,EAASpB,EAAMkE,KAAKpD,KAAKkB,IAAIF,IAAQ,MAE3C,OAAO8D,EAAMxE,EAAS8C,KAAKgC,KAAKpE,EAAKV,EACxC,CAED,GAAAc,CAAIJ,GACA,OAAOoC,KAAKpD,KAAKoB,IAAIJ,EACxB,CAED,IAAAW,GACI,OAAOyB,KAAKpD,KAAK2B,MACpB,CAED,KAAA8D,CAAMC,EAAS1G,EAAO2G,EAAM3G,EAAO8F,GAAM,GACrC,MAAMxE,EAAS8C,KAAKwC,SAAS9C,MAAM4C,EAAQA,EAASC,GAAK1B,KAAIhD,GAAKmC,KAAKlC,IAAID,EAAG6D,KAE9E,OAAOA,EAAMxE,EAAS8C,KAAKgC,QAAQ9E,EACtC,CAED,IAAA8E,IAAQxB,GACJ,OAAOlC,OAAO4D,OAAO1B,EAAKK,KAAIhD,GAAKS,OAAO4D,OAAOrE,KACpD,CAED,GAAAgD,CAAIvE,EAAIoF,GAAM,GACV,MAAMxE,EAAS,GAIf,OAFA8C,KAAK3C,SAAQ,CAACb,EAAOoB,IAAQV,EAAOK,KAAKjB,EAAGE,EAAOoB,MAE5C8D,EAAMxE,EAAS8C,KAAKgC,QAAQ9E,EACtC,CAED,OAAAyD,CAAQ3E,GACJ,OAAOA,CACV,CAED,OAAAkF,GACC,CAED,QAAAG,GACC,CAED,UAAAoB,GACC,CAED,KAAAC,GACC,CAED,QAAAC,CAAS/F,EAAM6D,EAAO9E,GAGlB,GFpMsB,YEoMlB8E,EACAT,KAAKrC,QAAU,IAAIsC,IAAIrD,EAAKiE,KAAIhD,GAAK,CAACA,EAAE,GAAI,IAAIoC,IAAIpC,EAAE,GAAGgD,KAAIU,GAAM,CAACA,EAAG,GAAI,IAAIpC,IAAIoC,EAAG,gBACnF,IAAId,IAAS9E,EAIhB,MAAM,IAAIwF,MFxMa,gBEqMvBnB,KAAKrC,QAAQsD,QACbjB,KAAKpD,KAAO,IAAIqD,IAAIrD,EAGvB,CAID,OAFAoD,KAAKyC,WAAWhC,IAXD,CAclB,CAED,MAAA3D,CAAOR,EAAIsG,EAAalB,GAAM,GAC1B,IAAI3E,EAAI6F,GAAe5C,KAAKpD,KAAK2B,OAAOsE,OAAOrG,MAM/C,OAJAwD,KAAK3C,SAAQ,CAACyE,EAAGC,KACbhF,EAAIT,EAAGS,EAAG+E,EAAGC,EAAG/B,KAAM0B,EAAI,GAC3B1B,MAEIjD,CACV,CAED,OAAAuD,CAAQ5C,GACJ,MAAMoF,EAAUpF,EAAQ,CAACA,GAASsC,KAAKtC,MASvC,OAPIA,IAAwC,IAA/BsC,KAAKtC,MAAMK,SAASL,IAC7BsC,KAAKtC,MAAMH,KAAKG,GAGpBtB,EAAK0G,GAASjF,GAAKmC,KAAKrC,QAAQuB,IAAIrB,EAAG,IAAIoC,OAC3CD,KAAK3C,SAAQ,CAACT,EAAMgB,IAAQxB,EAAK0G,GAASjF,GAAKiB,EAASkB,KAAKtC,MAAOsC,KAAKrC,QAASqC,KAAKrD,UAAWiB,EAAKhB,EAAMiB,OAEtGmC,IACV,CAED,MAAA+C,CAAOvG,EAAOkB,EAAOgE,GAAM,GACvB,MAAMxE,EAAS,IAAI+C,IACf3D,SAAYE,IAAUd,EACtBsH,EAAOxG,UAAgBA,EAAMyG,OAASvH,EA0B1C,OAxBIc,GACAJ,EAAKsB,EAAQP,MAAMC,QAAQM,GAASA,EAAQ,CAACA,GAASsC,KAAKtC,OAAOG,IAC9D,IAAItB,EAAMyD,KAAKrC,QAAQG,IAAID,GAEvBtB,GACAA,EAAIc,SAAQ,CAAC6F,EAAMC,KACf,QAAQ,GACJ,KAAK7G,GAAME,EAAM2G,EAAMtF,GACvB,KAAKmF,GAAQxG,EAAMyG,KAAK9F,MAAMC,QAAQ+F,GAAQA,EAAKtB,KF9PnD,KE8PwEsB,GACxE,KAAKA,IAAS3G,EACV0G,EAAK7F,SAAQO,KACe,IAApBV,EAAOc,IAAIJ,IAAkBoC,KAAKhC,IAAIJ,IACtCV,EAAOgC,IAAItB,EAAKoC,KAAKlC,IAAIF,EAAK8D,GACjC,IAKZ,GAER,IAIFA,EAAMvE,MAAMkD,KAAKnD,EAAOkG,UAAYpD,KAAKgC,QAAQ7E,MAAMkD,KAAKnD,EAAOkG,UAC7E,CAED,GAAAlE,CAAItB,EAAM,KAAMhB,EAAO,CAAE,EAAE2D,GAAQ,EAAOoC,GAAW,GACjD,IACIvB,EAAIlE,EADJM,EAAI1B,EAAMc,GAmCd,OAhCY,OAARgB,IACIoC,KAAKpC,OAAOJ,EACZI,EAAMJ,EAAEwC,KAAKpC,KAEbJ,EAAEwC,KAAKpC,KAAOA,EAAM0B,KAI5BU,KAAKgB,UAAUpD,EAAKhB,EAAM2D,EAAOoC,IAEX,IAAlB3C,KAAKhC,IAAIJ,GACLoC,KAAKD,YACLC,KAAKE,SAAShB,IAAItB,EAAK,IAAIuB,MAG/BiC,EAAKpB,KAAKlC,IAAIF,GAAK,GACnBH,EAASuC,KAAKtC,MAAOsC,KAAKrC,QAASqC,KAAKrD,UAAWiB,EAAKwD,GAEpDpB,KAAKD,YACLC,KAAKE,SAASpC,IAAIF,GAAKwB,IAAId,OAAO4D,OAAOpG,EAAMsF,MAGlC,IAAbuB,IACAnF,EAAIY,EAAMtC,EAAMsF,GAAK5D,KAI7BwC,KAAKpD,KAAKsC,IAAItB,EAAKJ,GACnBsB,EAASkB,KAAKtC,MAAOsC,KAAKrC,QAASqC,KAAKrD,UAAWiB,EAAKJ,EAAG,MAC3DN,EAAS8C,KAAKlC,IAAIF,GAClBoC,KAAK0C,MAAMxF,EAAQqD,GAEZrD,CACV,CAED,IAAAyE,CAAKrF,EAAI+G,GAAS,GACd,OAAOA,EAAS/E,OAAO4D,OAAOlC,KAAKqC,MAAMzG,EAAOoE,KAAKpD,KAAKuB,MAAM,GAAMwD,KAAKrF,GAAIuE,KAAIhD,GAAKS,OAAO4D,OAAOrE,MAAOmC,KAAKqC,MAAMzG,EAAOoE,KAAKpD,KAAKuB,MAAM,GAAMwD,KAAKrF,EAC7J,CAED,MAAAgH,CAAO5F,EAAQlC,EAAckG,GAAM,GAC/B,GAAIhE,IAAUlC,EACV,MAAM,IAAI2F,MFrTc,iBEwT5B,MAAMjE,EAAS,GACXqB,EAAO,IAEqB,IAA5ByB,KAAKrC,QAAQK,IAAIN,IACjBsC,KAAKM,QAAQ5C,GAGjB,MAAMsB,EAASgB,KAAKrC,QAAQG,IAAIJ,GAKhC,OAHAsB,EAAO3B,SAAQ,CAACd,EAAKqB,IAAQW,EAAKhB,KAAKK,KACvCxB,EAAKmC,EAAKoD,QAAQ9D,GAAKmB,EAAOlB,IAAID,GAAGR,SAAQO,GAAOV,EAAOK,KAAKyC,KAAKlC,IAAIF,EAAK8D,QAEvEA,EAAMxE,EAAS8C,KAAKgC,QAAQ9E,EACtC,CAED,OAAAqG,CAAQF,GAAS,GACb,MAAMnG,EAASC,MAAMkD,KAAKL,KAAKpD,KAAKwG,UAOpC,OALIC,IACAjH,EAAKc,GAAQW,GAAKS,OAAO4D,OAAOrE,KAChCS,OAAO4D,OAAOhF,IAGXA,CACV,CAED,MAAAkG,GACI,OAAOpD,KAAKpD,KAAKwG,QACpB,CAED,KAAA3B,CAAM+B,EAAY,CAAE,EAAE9B,GAAM,EAAO+B,EF5VL,ME6V1B,MAAMlF,EAAOyB,KAAKtC,MAAMuE,QAAOpE,GAAKA,KAAK2F,IAEzC,OAAOjF,EAAKmF,OAAS9H,EAAQoE,KAAKiC,OAAO,IAAI0B,SF9V7B,IE8VgD,WAAWpF,EAAKsC,KAAIhD,IAChF,IAAIX,EAEJ,GAAIC,MAAMC,QAAQoG,EAAU3F,IACxBX,EAAS,oBAAoBW,UAAU2F,EAAU3F,GAAGgD,KAAI7E,GAAO,MAAM6B,gBAA+B,iBAAR7B,EAAmB,IAAIA,KAASA,OAAQ6F,KAAK,IAAI4B,YAAaD,EAAU3F,GAAGgD,KAAI7E,GAAO,MAAM6B,WAA0B,iBAAR7B,EAAmB,IAAIA,KAASA,MAAO6F,KAAK,IAAI4B,cACvP,GAAID,EAAU3F,aAAc+F,OAC/B1G,EAAS,oBAAoBW,aAAaA,mBAAmB2F,EAAU3F,cAAcA,sBAAsB2F,EAAU3F,cAAcA,WAChI,CACH,MAAM7B,EAA8B,iBAAjBwH,EAAU3F,GAAkB,IAAI2F,EAAU3F,MAAQ2F,EAAU3F,GAE/EX,EAAS,oBAAoBW,aAAaA,gBAAgB7B,WAAa6B,WAAW7B,GACrF,CAED,OAAOkB,CAAM,IACd2E,KAAK,eAAgBH,GAAO,EAClC,EAWLmC,EAAAjE,KAAAA,EAAAiE,EAAAC,KARO,SAAclH,EAAO,KAAMmH,EAAS,CAAA,GACvC,MAAMC,EAAM,IAAIpE,EAAKmE,GAMrB,OAJI5G,MAAMC,QAAQR,IACdoH,EAAIzD,MAAM3D,EFzWQ,OE4WfoH,CACX,CAAA"}