{"version":3,"file":"haro.umd.min.js","sources":["../src/constants.js","../src/haro.js"],"sourcesContent":["// String constants - Single characters and symbols\nexport const STRING_COMMA = \",\";\nexport const STRING_EMPTY = \"\";\nexport const STRING_PIPE = \"|\";\nexport const STRING_DOUBLE_PIPE = \"||\";\n\n// String constants - Single letters\nexport const STRING_A = \"a\";\nexport const STRING_B = \"b\";\n\n// String constants - Operation and type names\nexport const STRING_DEL = \"del\";\nexport const STRING_FUNCTION = \"function\";\nexport const STRING_INDEXES = \"indexes\";\nexport const STRING_OBJECT = \"object\";\nexport const STRING_RECORDS = \"records\";\nexport const STRING_REGISTRY = \"registry\";\nexport const STRING_SET = \"set\";\nexport const STRING_SIZE = \"size\";\n\n// String constants - Error messages\nexport const STRING_INVALID_FIELD = \"Invalid field\";\nexport const STRING_INVALID_FUNCTION = \"Invalid function\";\nexport const STRING_INVALID_TYPE = \"Invalid type\";\nexport const STRING_RECORD_NOT_FOUND = \"Record not found\";\n\n// Integer constants\nexport const INT_0 = 0;\nexport const INT_1 = 1;\nexport const INT_3 = 3;\nexport const INT_4 = 4;\nexport const INT_8 = 8;\nexport const INT_9 = 9;\nexport const INT_16 = 16;\n","import {randomUUID as uuid} from \"crypto\";\nimport {\n\tINT_0,\n\tSTRING_COMMA,\n\tSTRING_DEL,\n\tSTRING_DOUBLE_PIPE,\n\tSTRING_EMPTY,\n\tSTRING_FUNCTION,\n\tSTRING_INDEXES,\n\tSTRING_INVALID_FIELD,\n\tSTRING_INVALID_FUNCTION,\n\tSTRING_INVALID_TYPE,\n\tSTRING_PIPE,\n\tSTRING_RECORD_NOT_FOUND,\n\tSTRING_RECORDS,\n\tSTRING_REGISTRY,\n\tSTRING_SET,\n\tSTRING_SIZE\n} from \"./constants.js\";\n\n/**\n * Haro is a modern immutable DataStore for collections of records\n * @class\n */\nexport class Haro {\n\t/**\n\t * Creates a new Haro instance\n\t * @param {Object} [config={}] - Configuration object\n\t * @param {string} [config.delimiter=STRING_PIPE] - Delimiter for composite indexes\n\t * @param {string} [config.id=this.uuid()] - Unique identifier for this instance\n\t * @param {Array} [config.index=[]] - Array of field names to index\n\t * @param {string} [config.key=\"id\"] - Primary key field name\n\t * @param {boolean} [config.versioning=false] - Enable versioning of records\n\t * @constructor\n\t */\n\tconstructor ({delimiter = STRING_PIPE, id = this.uuid(), index = [], key = \"id\", versioning = false} = {}) {\n\t\tthis.data = new Map();\n\t\tthis.delimiter = delimiter;\n\t\tthis.id = id;\n\t\tthis.index = Array.isArray(index) ? [...index] : [];\n\t\tthis.indexes = new Map();\n\t\tthis.key = key;\n\t\tthis.versions = new Map();\n\t\tthis.versioning = versioning;\n\n\t\tObject.defineProperty(this, STRING_REGISTRY, {\n\t\t\tenumerable: true,\n\t\t\tget: () => Array.from(this.data.keys())\n\t\t});\n\t\tObject.defineProperty(this, STRING_SIZE, {\n\t\t\tenumerable: true,\n\t\t\tget: () => this.data.size\n\t\t});\n\n\t\treturn this.reindex();\n\t}\n\n\t/**\n\t * Performs batch operations on multiple records\n\t * @param {Array} args - Array of records to process\n\t * @param {string} [type=STRING_SET] - Type of operation (SET or DEL)\n\t * @returns {Array} Array of results from the batch operation\n\t */\n\tbatch (args, type = STRING_SET) {\n\t\tconst fn = type === STRING_DEL ? i => this.del(i, true) : i => this.set(null, i, true, true);\n\n\t\treturn this.onbatch(this.beforeBatch(args, type).map(fn), type);\n\t}\n\n\t/**\n\t * Hook for custom logic before batch operations\n\t * @param {*} arg - Arguments passed to batch operation\n\t * @param {string} [type=STRING_EMPTY] - Type of batch operation\n\t * @returns {*} Modified arguments\n\t */\n\tbeforeBatch (arg, type = STRING_EMPTY) { // eslint-disable-line no-unused-vars\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Hook for custom logic before clear operation\n\t */\n\tbeforeClear () {\n\t\t// Hook for custom logic before clear; override in subclass if needed\n\t}\n\n\t/**\n\t * Hook for custom logic before delete operation\n\t * @param {string} [key=STRING_EMPTY] - Key of record to delete\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @returns {Array} Array containing key and batch flag\n\t */\n\tbeforeDelete (key = STRING_EMPTY, batch = false) {\n\t\treturn [key, batch];\n\t}\n\n\t/**\n\t * Hook for custom logic before set operation\n\t * @param {string} [key=STRING_EMPTY] - Key of record to set\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @returns {Array} Array containing key and batch flag\n\t */\n\tbeforeSet (key = STRING_EMPTY, batch = false) {\n\t\treturn [key, batch];\n\t}\n\n\t/**\n\t * Clears all data from the store\n\t * @returns {Haro} This instance for method chaining\n\t */\n\tclear () {\n\t\tthis.beforeClear();\n\t\tthis.data.clear();\n\t\tthis.indexes.clear();\n\t\tthis.versions.clear();\n\t\tthis.reindex().onclear();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a deep clone of the given argument\n\t * @param {*} arg - Value to clone\n\t * @returns {*} Deep clone of the argument\n\t */\n\tclone (arg) {\n\t\treturn JSON.parse(JSON.stringify(arg));\n\t}\n\n\t/**\n\t * Deletes a record from the store\n\t * @param {string} [key=STRING_EMPTY] - Key of record to delete\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @throws {Error} Throws error if record not found\n\t */\n\tdel (key = STRING_EMPTY, batch = false) {\n\t\tif (!this.data.has(key)) {\n\t\t\tthrow new Error(STRING_RECORD_NOT_FOUND);\n\t\t}\n\t\tconst og = this.get(key, true);\n\t\tthis.beforeDelete(key, batch);\n\t\tthis.delIndex(this.index, this.indexes, this.delimiter, key, og);\n\t\tthis.data.delete(key);\n\t\tthis.ondelete(key, batch);\n\t\tif (this.versioning) {\n\t\t\tthis.versions.delete(key);\n\t\t}\n\t}\n\n\t/**\n\t * Removes entries from indexes for a deleted record\n\t * @param {Array} index - Array of index names\n\t * @param {Map} indexes - Map of indexes\n\t * @param {string} delimiter - Delimiter for composite indexes\n\t * @param {string} key - Key of record being deleted\n\t * @param {Object} data - Data of record being deleted\n\t */\n\tdelIndex (index, indexes, delimiter, key, data) {\n\t\tindex.forEach(i => {\n\t\t\tconst idx = indexes.get(i);\n\t\t\tif (!idx) return;\n\t\t\tconst values = i.includes(delimiter) ?\n\t\t\t\tthis.indexKeys(i, delimiter, data) :\n\t\t\t\tArray.isArray(data[i]) ? data[i] : [data[i]];\n\t\t\tthis.each(values, value => {\n\t\t\t\tif (idx.has(value)) {\n\t\t\t\t\tconst o = idx.get(value);\n\t\t\t\t\to.delete(key);\n\t\t\t\t\tif (o.size === INT_0) {\n\t\t\t\t\t\tidx.delete(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Exports data or indexes from the store\n\t * @param {string} [type=STRING_RECORDS] - Type of data to dump (RECORDS or INDEXES)\n\t * @returns {Array} Array of records or indexes\n\t */\n\tdump (type = STRING_RECORDS) {\n\t\tlet result;\n\n\t\tif (type === STRING_RECORDS) {\n\t\t\tresult = Array.from(this.entries());\n\t\t} else {\n\t\t\tresult = Array.from(this.indexes).map(i => {\n\t\t\t\ti[1] = Array.from(i[1]).map(ii => {\n\t\t\t\t\tii[1] = Array.from(ii[1]);\n\n\t\t\t\t\treturn ii;\n\t\t\t\t});\n\n\t\t\t\treturn i;\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Utility method to iterate over an array\n\t * @param {Array} [arr=[]] - Array to iterate over\n\t * @param {Function} fn - Function to call for each element\n\t * @returns {Array} The original array\n\t */\n\teach (arr = [], fn) {\n\t\tfor (const [idx, value] of arr.entries()) {\n\t\t\tfn(value, idx);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\t/**\n\t * Returns an iterator of [key, value] pairs for each element in the data\n\t * @returns {Iterator} Iterator of entries\n\t */\n\tentries () {\n\t\treturn this.data.entries();\n\t}\n\n\t/**\n\t * Finds records matching the given criteria using indexes\n\t * @param {Object} [where={}] - Object with field-value pairs to match\n\t * @param {boolean} [raw=false] - Whether to return raw data or frozen records\n\t * @returns {Array} Array of matching records\n\t */\n\tfind (where = {}, raw = false) {\n\t\tconst key = Object.keys(where).sort((a, b) => a.localeCompare(b)).join(this.delimiter);\n\t\tconst index = this.indexes.get(key) ?? new Map();\n\t\tlet result = [];\n\t\tif (index.size > 0) {\n\t\t\tconst keys = this.indexKeys(key, this.delimiter, where);\n\t\t\tresult = Array.from(keys.reduce((a, v) => {\n\t\t\t\tif (index.has(v)) {\n\t\t\t\t\tindex.get(v).forEach(k => a.add(k));\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\t\t\t}, new Set())).map(i => this.get(i, raw));\n\t\t}\n\n\t\treturn raw ? result : this.list(...result);\n\t}\n\n\t/**\n\t * Filters records using a predicate function\n\t * @param {Function} fn - Predicate function to test each record\n\t * @param {boolean} [raw=false] - Whether to return raw data or frozen records\n\t * @returns {Array} Array of records that pass the predicate\n\t * @throws {Error} Throws error if fn is not a function\n\t */\n\tfilter (fn, raw = false) {\n\t\tif (typeof fn !== STRING_FUNCTION) {\n\t\t\tthrow new Error(STRING_INVALID_FUNCTION);\n\t\t}\n\t\tconst x = raw ? (k, v) => v : (k, v) => Object.freeze([k, Object.freeze(v)]);\n\t\tconst result = this.reduce((a, v, k, ctx) => {\n\t\t\tif (fn.call(ctx, v)) {\n\t\t\t\ta.push(x(k, v));\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}, []);\n\n\t\treturn raw ? result : Object.freeze(result);\n\t}\n\n\t/**\n\t * Executes a function for each record in the store\n\t * @param {Function} fn - Function to execute for each record\n\t * @param {*} [ctx] - Context to use as 'this' when executing the function\n\t * @returns {Haro} This instance for method chaining\n\t */\n\tforEach (fn, ctx) {\n\t\tthis.data.forEach((value, key) => fn(this.clone(value), this.clone(key)), ctx ?? this.data);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Gets a record by key\n\t * @param {string} key - Key of record to retrieve\n\t * @param {boolean} [raw=false] - Whether to return raw data or frozen record\n\t * @returns {*} The record or null if not found\n\t */\n\tget (key, raw = false) {\n\t\tconst result = this.clone(this.data.get(key) ?? null);\n\n\t\treturn raw ? result : this.list(key, result);\n\t}\n\n\t/**\n\t * Checks if a key exists in the store\n\t * @param {string} key - Key to check\n\t * @returns {boolean} True if key exists, false otherwise\n\t */\n\thas (key) {\n\t\treturn this.data.has(key);\n\t}\n\n\t/**\n\t * Generates index keys for composite indexes\n\t * @param {string} [arg=STRING_EMPTY] - Composite index field names joined by delimiter\n\t * @param {string} [delimiter=STRING_PIPE] - Delimiter used in composite index\n\t * @param {Object} [data={}] - Data object to extract values from\n\t * @returns {Array} Array of index keys\n\t */\n\tindexKeys (arg = STRING_EMPTY, delimiter = STRING_PIPE, data = {}) {\n\t\treturn arg.split(delimiter).reduce((a, li, lidx) => {\n\t\t\tconst result = [];\n\n\t\t\t(Array.isArray(data[li]) ? data[li] : [data[li]]).forEach(lli => lidx === INT_0 ? result.push(lli) : a.forEach(x => result.push(`${x}${delimiter}${lli}`)));\n\n\t\t\treturn result;\n\t\t}, []);\n\t}\n\n\t/**\n\t * Returns an iterator of keys in the store\n\t * @returns {Iterator} Iterator of keys\n\t */\n\tkeys () {\n\t\treturn this.data.keys();\n\t}\n\n\t/**\n\t * Returns a limited number of records with offset\n\t * @param {number} [offset=INT_0] - Number of records to skip\n\t * @param {number} [max=INT_0] - Maximum number of records to return\n\t * @param {boolean} [raw=false] - Whether to return raw data or frozen records\n\t * @returns {Array} Array of records\n\t */\n\tlimit (offset = INT_0, max = INT_0, raw = false) {\n\t\tconst result = this.registry.slice(offset, offset + max).map(i => this.get(i, raw));\n\n\t\treturn raw ? result : this.list(...result);\n\t}\n\n\t/**\n\t * Creates a frozen array from the given arguments\n\t * @param {...*} args - Arguments to freeze into an array\n\t * @returns {Array} Frozen array of frozen arguments\n\t */\n\tlist (...args) {\n\t\treturn Object.freeze(args.map(i => Object.freeze(i)));\n\t}\n\n\t/**\n\t * Maps over all records in the store\n\t * @param {Function} fn - Function to apply to each record\n\t * @param {boolean} [raw=false] - Whether to return raw data or frozen records\n\t * @returns {Array} Array of mapped results\n\t * @throws {Error} Throws error if fn is not a function\n\t */\n\tmap (fn, raw = false) {\n\t\tif (typeof fn !== STRING_FUNCTION) {\n\t\t\tthrow new Error(STRING_INVALID_FUNCTION);\n\t\t}\n\n\t\tconst result = [];\n\n\t\tthis.forEach((value, key) => result.push(fn(value, key)));\n\n\t\treturn raw ? result : this.list(...result);\n\t}\n\n\t/**\n\t * Merges two values together\n\t * @param {*} a - First value\n\t * @param {*} b - Second value\n\t * @param {boolean} [override=false] - Whether to override arrays instead of concatenating\n\t * @returns {*} Merged result\n\t */\n\tmerge (a, b, override = false) {\n\t\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\t\ta = override ? b : a.concat(b);\n\t\t} else if (typeof a === \"object\" && a !== null && typeof b === \"object\" && b !== null) {\n\t\t\tthis.each(Object.keys(b), i => {\n\t\t\t\ta[i] = this.merge(a[i], b[i], override);\n\t\t\t});\n\t\t} else {\n\t\t\ta = b;\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Hook for custom logic after batch operations\n\t * @param {*} arg - Result of batch operation\n\t * @param {string} [type=STRING_EMPTY] - Type of batch operation\n\t * @returns {*} Modified result\n\t */\n\tonbatch (arg, type = STRING_EMPTY) { // eslint-disable-line no-unused-vars\n\t\treturn arg;\n\t}\n\n\t/**\n\t * Hook for custom logic after clear operation\n\t */\n\tonclear () {\n\t\t// Hook for custom logic after clear; override in subclass if needed\n\t}\n\n\t/**\n\t * Hook for custom logic after delete operation\n\t * @param {string} [key=STRING_EMPTY] - Key of deleted record\n\t * @param {boolean} [batch=false] - Whether this was part of a batch operation\n\t * @returns {Array} Array containing key and batch flag\n\t */\n\tondelete (key = STRING_EMPTY, batch = false) {\n\t\treturn [key, batch];\n\t}\n\n\t/**\n\t * Hook for custom logic after override operation\n\t * @param {string} [type=STRING_EMPTY] - Type of override operation\n\t * @returns {string} The type parameter\n\t */\n\tonoverride (type = STRING_EMPTY) {\n\t\treturn type;\n\t}\n\n\t/**\n\t * Hook for custom logic after set operation\n\t * @param {Object} [arg={}] - Record that was set\n\t * @param {boolean} [batch=false] - Whether this was part of a batch operation\n\t * @returns {Array} Array containing record and batch flag\n\t */\n\tonset (arg = {}, batch = false) {\n\t\treturn [arg, batch];\n\t}\n\n\t/**\n\t * Replaces all data or indexes in the store\n\t * @param {Array} data - Data to replace with\n\t * @param {string} [type=STRING_RECORDS] - Type of data (RECORDS or INDEXES)\n\t * @returns {boolean} True if operation succeeded\n\t * @throws {Error} Throws error if type is invalid\n\t */\n\toverride (data, type = STRING_RECORDS) {\n\t\tconst result = true;\n\n\t\tif (type === STRING_INDEXES) {\n\t\t\tthis.indexes = new Map(data.map(i => [i[0], new Map(i[1].map(ii => [ii[0], new Set(ii[1])]))]));\n\t\t} else if (type === STRING_RECORDS) {\n\t\t\tthis.indexes.clear();\n\t\t\tthis.data = new Map(data);\n\t\t} else {\n\t\t\tthrow new Error(STRING_INVALID_TYPE);\n\t\t}\n\n\t\tthis.onoverride(type);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Reduces all records to a single value\n\t * @param {Function} fn - Reducer function\n\t * @param {*} [accumulator] - Initial accumulator value\n\t * @param {boolean} [raw=false] - Whether to work with raw data\n\t * @returns {*} Reduced result\n\t */\n\treduce (fn, accumulator, raw = false) {\n\t\tlet a = accumulator ?? this.data.keys().next().value;\n\n\t\tthis.forEach((v, k) => {\n\t\t\ta = fn(a, v, k, this, raw);\n\t\t}, this);\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Rebuilds indexes for specified fields\n\t * @param {string|Array} [index] - Index field(s) to rebuild, or all if not specified\n\t * @returns {Haro} This instance for method chaining\n\t */\n\treindex (index) {\n\t\tconst indices = index ? [index] : this.index;\n\n\t\tif (index && this.index.includes(index) === false) {\n\t\t\tthis.index.push(index);\n\t\t}\n\n\t\tthis.each(indices, i => this.indexes.set(i, new Map()));\n\t\tthis.forEach((data, key) => this.each(indices, i => this.setIndex(this.index, this.indexes, this.delimiter, key, data, i)));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Searches for records matching a value across indexes\n\t * @param {*} value - Value to search for (string, function, or regex)\n\t * @param {string|Array} [index] - Index(es) to search in, or all if not specified\n\t * @param {boolean} [raw=false] - Whether to return raw data or frozen records\n\t * @returns {Array} Array of matching records\n\t */\n\tsearch (value, index, raw = false) {\n\t\tconst result = new Map(),\n\t\t\tfn = typeof value === STRING_FUNCTION,\n\t\t\trgex = value && typeof value.test === STRING_FUNCTION;\n\n\t\tif (value) {\n\t\t\tthis.each(index ? Array.isArray(index) ? index : [index] : this.index, i => {\n\t\t\t\tlet idx = this.indexes.get(i);\n\n\t\t\t\tif (idx) {\n\t\t\t\t\tidx.forEach((lset, lkey) => {\n\t\t\t\t\t\tswitch (true) {\n\t\t\t\t\t\t\tcase fn && value(lkey, i):\n\t\t\t\t\t\t\tcase rgex && value.test(Array.isArray(lkey) ? lkey.join(STRING_COMMA) : lkey):\n\t\t\t\t\t\t\tcase lkey === value:\n\t\t\t\t\t\t\t\tlset.forEach(key => {\n\t\t\t\t\t\t\t\t\tif (result.has(key) === false && this.data.has(key)) {\n\t\t\t\t\t\t\t\t\t\tresult.set(key, this.get(key, raw));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tvoid 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn raw ? Array.from(result.values()) : this.list(...Array.from(result.values()));\n\t}\n\n\t/**\n\t * Sets a record in the store\n\t * @param {string|null} [key=null] - Key for the record, or null to use record's key field\n\t * @param {Object} [data={}] - Data to set\n\t * @param {boolean} [batch=false] - Whether this is part of a batch operation\n\t * @param {boolean} [override=false] - Whether to override existing data instead of merging\n\t * @returns {Array} Frozen array containing the key and record\n\t */\n\tset (key = null, data = {}, batch = false, override = false) {\n\t\tif (key === null) {\n\t\t\tkey = data[this.key] ?? this.uuid();\n\t\t}\n\t\tlet x = {...data, [this.key]: key};\n\t\tthis.beforeSet(key, x, batch, override);\n\t\tif (!this.data.has(key)) {\n\t\t\tif (this.versioning) {\n\t\t\t\tthis.versions.set(key, new Set());\n\t\t\t}\n\t\t} else {\n\t\t\tconst og = this.get(key, true);\n\t\t\tthis.delIndex(this.index, this.indexes, this.delimiter, key, og);\n\t\t\tif (this.versioning) {\n\t\t\t\tthis.versions.get(key).add(Object.freeze(this.clone(og)));\n\t\t\t}\n\t\t\tif (!override) {\n\t\t\t\tx = this.merge(this.clone(og), x);\n\t\t\t}\n\t\t}\n\t\tthis.data.set(key, x);\n\t\tthis.setIndex(this.index, this.indexes, this.delimiter, key, x, null);\n\t\tconst result = this.get(key);\n\t\tthis.onset(result, batch);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Adds entries to indexes for a record\n\t * @param {Array} index - Array of index names\n\t * @param {Map} indexes - Map of indexes\n\t * @param {string} delimiter - Delimiter for composite indexes\n\t * @param {string} key - Key of record being indexed\n\t * @param {Object} data - Data of record being indexed\n\t * @param {string|null} indice - Specific index to update, or null for all\n\t */\n\tsetIndex (index, indexes, delimiter, key, data, indice) {\n\t\tthis.each(indice === null ? index : [indice], i => {\n\t\t\tlet lindex = indexes.get(i);\n\t\t\tif (!lindex) {\n\t\t\t\tlindex = new Map();\n\t\t\t\tindexes.set(i, lindex);\n\t\t\t}\n\t\t\tif (i.includes(delimiter)) {\n\t\t\t\tthis.each(this.indexKeys(i, delimiter, data), c => {\n\t\t\t\t\tif (!lindex.has(c)) {\n\t\t\t\t\t\tlindex.set(c, new Set());\n\t\t\t\t\t}\n\t\t\t\t\tlindex.get(c).add(key);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.each(Array.isArray(data[i]) ? data[i] : [data[i]], d => {\n\t\t\t\t\tif (!lindex.has(d)) {\n\t\t\t\t\t\tlindex.set(d, new Set());\n\t\t\t\t\t}\n\t\t\t\t\tlindex.get(d).add(key);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Sorts all records using a comparator function\n\t * @param {Function} fn - Comparator function for sorting\n\t * @param {boolean} [frozen=true] - Whether to return frozen records\n\t * @returns {Array} Sorted array of records\n\t */\n\tsort (fn, frozen = true) {\n\t\treturn frozen ? Object.freeze(this.limit(INT_0, this.data.size, true).sort(fn).map(i => Object.freeze(i))) : this.limit(INT_0, this.data.size, true).sort(fn);\n\t}\n\n\t/**\n\t * Sorts records by a specific indexed field\n\t * @param {string} [index=STRING_EMPTY] - Index field to sort by\n\t * @param {boolean} [raw=false] - Whether to return raw data or frozen records\n\t * @returns {Array} Array of records sorted by the index field\n\t * @throws {Error} Throws error if index field is empty\n\t */\n\tsortBy (index = STRING_EMPTY, raw = false) {\n\t\tif (index === STRING_EMPTY) {\n\t\t\tthrow new Error(STRING_INVALID_FIELD);\n\t\t}\n\n\t\tconst result = [],\n\t\t\tkeys = [];\n\n\t\tif (this.indexes.has(index) === false) {\n\t\t\tthis.reindex(index);\n\t\t}\n\n\t\tconst lindex = this.indexes.get(index);\n\n\t\tlindex.forEach((idx, key) => keys.push(key));\n\t\tthis.each(keys.sort(), i => lindex.get(i).forEach(key => result.push(this.get(key, raw))));\n\n\t\treturn raw ? result : this.list(...result);\n\t}\n\n\t/**\n\t * Converts the store data to an array\n\t * @param {boolean} [frozen=true] - Whether to return frozen records\n\t * @returns {Array} Array of all records\n\t */\n\ttoArray (frozen = true) {\n\t\tconst result = Array.from(this.data.values());\n\n\t\tif (frozen) {\n\t\t\tthis.each(result, i => Object.freeze(i));\n\t\t\tObject.freeze(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Generates a UUID\n\t * @returns {string} UUID string\n\t */\n\tuuid () {\n\t\treturn uuid();\n\t}\n\n\t/**\n\t * Returns an iterator of values in the store\n\t * @returns {Iterator} Iterator of values\n\t */\n\tvalues () {\n\t\treturn this.data.values();\n\t}\n\n\t/**\n\t * Filters records using predicate logic with support for AND/OR operations\n\t * @param {Object} [predicate={}] - Object with field-value pairs for filtering\n\t * @param {boolean} [raw=false] - Whether to return raw data or frozen records\n\t * @param {string} [op=STRING_DOUBLE_PIPE] - Operator for array matching ('||' for OR, '&&' for AND)\n\t * @returns {Array} Array of records matching the predicate\n\t */\n\twhere (predicate = {}, raw = false, op = STRING_DOUBLE_PIPE) {\n\t\tconst keys = this.index.filter(i => i in predicate);\n\n\t\tif (keys.length === 0) return [];\n\n\t\t// Supported operators: '||' (OR), '&&' (AND)\n\t\t// Always AND across fields (all keys must match for a record)\n\t\treturn this.filter(a => {\n\t\t\tconst matches = keys.map(i => {\n\t\t\t\tconst pred = predicate[i];\n\t\t\t\tconst val = a[i];\n\t\t\t\tif (Array.isArray(pred)) {\n\t\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\t\tif (op === \"&&\") {\n\t\t\t\t\t\t\treturn pred.every(p => val.includes(p));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn pred.some(p => val.includes(p));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (op === \"&&\") {\n\t\t\t\t\t\treturn pred.every(p => val === p);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn pred.some(p => val === p);\n\t\t\t\t\t}\n\t\t\t\t} else if (pred instanceof RegExp) {\n\t\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\t\tif (op === \"&&\") {\n\t\t\t\t\t\t\treturn val.every(v => pred.test(v));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn val.some(v => pred.test(v));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn pred.test(val);\n\t\t\t\t\t}\n\t\t\t\t} else if (Array.isArray(val)) {\n\t\t\t\t\treturn val.includes(pred);\n\t\t\t\t} else {\n\t\t\t\t\treturn val === pred;\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst isMatch = matches.every(Boolean);\n\n\t\t\treturn isMatch;\n\t\t}, raw);\n\t}\n\n}\n\n/**\n * Factory function to create a new Haro instance\n * @param {Array|null} [data=null] - Initial data to populate the store\n * @param {Object} [config={}] - Configuration object passed to Haro constructor\n * @returns {Haro} New Haro instance\n */\nexport function haro (data = null, config = {}) {\n\tconst obj = new Haro(config);\n\n\tif (Array.isArray(data)) {\n\t\tobj.batch(data, STRING_SET);\n\t}\n\n\treturn obj;\n}\n"],"names":["g","f","exports","module","require","define","amd","globalThis","self","lru","crypto","this","STRING_EMPTY","STRING_FUNCTION","STRING_RECORDS","STRING_INVALID_FUNCTION","Haro","constructor","delimiter","id","uuid","index","key","versioning","data","Map","Array","isArray","indexes","versions","Object","defineProperty","enumerable","get","from","keys","size","reindex","batch","args","type","fn","i","del","set","onbatch","beforeBatch","map","arg","beforeClear","beforeDelete","beforeSet","clear","onclear","clone","JSON","parse","stringify","has","Error","og","delIndex","delete","ondelete","forEach","idx","values","includes","indexKeys","each","value","o","dump","result","entries","ii","arr","find","where","raw","sort","a","b","localeCompare","join","reduce","v","k","add","Set","list","filter","x","freeze","ctx","call","push","split","li","lidx","lli","limit","offset","max","registry","slice","merge","override","concat","onoverride","onset","accumulator","next","indices","setIndex","search","rgex","test","lset","lkey","indice","lindex","c","d","frozen","sortBy","toArray","predicate","op","length","pred","val","every","p","some","RegExp","Boolean","haro","config","obj"],"mappings":"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"}