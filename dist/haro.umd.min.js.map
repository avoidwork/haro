{"version":3,"file":"haro.umd.min.js","sources":["../src/errors.js","../src/data-types.js","../src/field-constraint.js","../src/schema.js","../src/config-validator.js","../src/constraints.js","../src/constants.js","../src/record.js","../src/index-manager.js","../src/version-manager.js","../src/transaction-operation.js","../src/transaction-individual.js","../src/lock-manager.js","../src/transaction-statistics.js","../src/key-relationship-analyzer.js","../src/deadlock-detector.js","../src/isolation-validator.js","../src/transaction-manager.js","../src/query-optimizer.js","../src/immutable-store.js","../src/data-stream.js","../src/storage-manager.js","../src/crud-manager.js","../src/query-manager.js","../src/batch-manager.js","../src/stream-manager.js","../src/statistics-manager.js","../src/lifecycle-manager.js","../src/haro.js"],"sourcesContent":["/**\n * Base error class for all Haro errors\n */\nexport class HaroError extends Error {\n\t/**\n\t * @param {string} message - Error message\n\t * @param {string} [code] - Error code for programmatic handling\n\t * @param {*} [context] - Additional context about the error\n\t */\n\tconstructor (message, code, context) {\n\t\tsuper(message);\n\t\tthis.name = this.constructor.name;\n\t\tthis.code = code;\n\t\tthis.context = context;\n\t\tthis.timestamp = new Date().toISOString();\n\n\t\t// Ensure proper stack trace\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, this.constructor);\n\t\t}\n\t}\n\n\t/**\n\t * Convert error to JSON for serialization\n\t * @returns {Object} Serializable error object\n\t */\n\ttoJSON () {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tmessage: this.message,\n\t\t\tcode: this.code,\n\t\t\tcontext: this.context,\n\t\t\ttimestamp: this.timestamp,\n\t\t\tstack: this.stack\n\t\t};\n\t}\n}\n\n/**\n * Validation errors for invalid data or configuration\n */\nexport class ValidationError extends HaroError {\n\tconstructor (message, field, value) {\n\t\tsuper(message, \"VALIDATION_ERROR\", { field, value });\n\t}\n}\n\n/**\n * Record not found errors\n */\nexport class RecordNotFoundError extends HaroError {\n\tconstructor (key, storeName) {\n\t\tsuper(`Record with key '${key}' not found${storeName ? ` in store '${storeName}'` : \"\"}`, \"RECORD_NOT_FOUND\", { key, storeName });\n\t}\n}\n\n/**\n * Index-related errors\n */\nexport class IndexError extends HaroError {\n\tconstructor (message, indexName, operation) {\n\t\tsuper(message, \"INDEX_ERROR\", { indexName, operation });\n\t}\n}\n\n/**\n * Configuration errors\n */\nexport class ConfigurationError extends HaroError {\n\tconstructor (message, configKey, configValue) {\n\t\tsuper(message, \"CONFIGURATION_ERROR\", { configKey, configValue });\n\t}\n}\n\n/**\n * Query errors for invalid queries or operations\n */\nexport class QueryError extends HaroError {\n\tconstructor (message, query, operation) {\n\t\tsuper(message, \"QUERY_ERROR\", { query, operation });\n\t}\n}\n\n/**\n * Transaction errors\n */\nexport class TransactionError extends HaroError {\n\tconstructor (message, transactionId, operation) {\n\t\tsuper(message, \"TRANSACTION_ERROR\", { transactionId, operation });\n\t}\n}\n\n/**\n * Version management errors\n */\nexport class VersionError extends HaroError {\n\tconstructor (message, key, version) {\n\t\tsuper(message, \"VERSION_ERROR\", { key, version });\n\t}\n}\n\n/**\n * Type constraint errors\n */\nexport class TypeConstraintError extends HaroError {\n\tconstructor (message, expected, actual, field) {\n\t\tsuper(message, \"TYPE_CONSTRAINT_ERROR\", { expected, actual, field });\n\t}\n}\n\n/**\n * Concurrency errors for multi-threaded access\n */\nexport class ConcurrencyError extends HaroError {\n\tconstructor (message, resource, operation) {\n\t\tsuper(message, \"CONCURRENCY_ERROR\", { resource, operation });\n\t}\n}\n\n/**\n * Error recovery utilities\n */\nexport class ErrorRecovery {\n\t/**\n\t * Determine if an error is recoverable\n\t * @param {Error} error - Error to analyze\n\t * @returns {boolean} True if error is recoverable\n\t */\n\tstatic isRecoverable (error) {\n\t\tif (!(error instanceof HaroError)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst recoverableCodes = [\n\t\t\t\"RECORD_NOT_FOUND\",\n\t\t\t\"VALIDATION_ERROR\",\n\t\t\t\"QUERY_ERROR\",\n\t\t\t\"TYPE_CONSTRAINT_ERROR\"\n\t\t];\n\n\t\treturn recoverableCodes.includes(error.code);\n\t}\n\n\t/**\n\t * Get suggested recovery actions for an error\n\t * @param {HaroError} error - Error to get recovery actions for\n\t * @returns {string[]} Array of suggested recovery actions\n\t */\n\tstatic getRecoveryActions (error) {\n\t\tif (!(error instanceof HaroError)) {\n\t\t\treturn [\"Check error details and retry\"];\n\t\t}\n\n\t\tswitch (error.code) {\n\t\t\tcase \"RECORD_NOT_FOUND\":\n\t\t\t\treturn [\n\t\t\t\t\t\"Verify the record key is correct\",\n\t\t\t\t\t\"Check if record was deleted\",\n\t\t\t\t\t\"Use has() method to check existence before get()\"\n\t\t\t\t];\n\n\t\t\tcase \"VALIDATION_ERROR\":\n\t\t\t\treturn [\n\t\t\t\t\t\"Check data types match expected schema\",\n\t\t\t\t\t\"Verify required fields are present\",\n\t\t\t\t\t\"Validate field constraints\"\n\t\t\t\t];\n\n\t\t\tcase \"INDEX_ERROR\":\n\t\t\t\treturn [\n\t\t\t\t\t\"Verify index exists before querying\",\n\t\t\t\t\t\"Check index configuration\",\n\t\t\t\t\t\"Try reindexing the affected field\"\n\t\t\t\t];\n\n\t\t\tcase \"CONFIGURATION_ERROR\":\n\t\t\t\treturn [\n\t\t\t\t\t\"Review configuration parameters\",\n\t\t\t\t\t\"Check for typos in configuration keys\",\n\t\t\t\t\t\"Refer to documentation for valid options\"\n\t\t\t\t];\n\n\t\t\tcase \"QUERY_ERROR\":\n\t\t\t\treturn [\n\t\t\t\t\t\"Verify query syntax is correct\",\n\t\t\t\t\t\"Check if indexed fields are being used\",\n\t\t\t\t\t\"Simplify complex queries\"\n\t\t\t\t];\n\n\t\t\tcase \"TRANSACTION_ERROR\":\n\t\t\t\treturn [\n\t\t\t\t\t\"Retry the transaction\",\n\t\t\t\t\t\"Check for concurrent modifications\",\n\t\t\t\t\t\"Reduce transaction scope\"\n\t\t\t\t];\n\n\t\t\tcase \"TYPE_CONSTRAINT_ERROR\":\n\t\t\t\treturn [\n\t\t\t\t\t\"Check data types match schema\",\n\t\t\t\t\t\"Convert data to expected type\",\n\t\t\t\t\t\"Update type constraints if needed\"\n\t\t\t\t];\n\n\t\t\tdefault:\n\t\t\t\treturn [\"Check error details and retry\"];\n\t\t}\n\t}\n\n\t/**\n\t * Create a recovery strategy for an error\n\t * @param {HaroError} error - Error to create strategy for\n\t * @returns {Object} Recovery strategy object\n\t */\n\tstatic createRecoveryStrategy (error) {\n\t\treturn {\n\t\t\terror,\n\t\t\tisRecoverable: this.isRecoverable(error),\n\t\t\tactions: this.getRecoveryActions(error),\n\t\t\tretryable: [\"CONCURRENCY_ERROR\", \"TRANSACTION_ERROR\"].includes(error.code),\n\t\t\tbackoffMs: error.code === \"CONCURRENCY_ERROR\" ? 100 : 0\n\t\t};\n\t}\n}\n","/**\n * Data type definitions and type detection utilities\n */\n\n/**\n * Type definitions for validation\n */\nexport const DataTypes = {\n\tSTRING: \"string\",\n\tNUMBER: \"number\",\n\tBOOLEAN: \"boolean\",\n\tOBJECT: \"object\",\n\tARRAY: \"array\",\n\tDATE: \"date\",\n\tUUID: \"uuid\",\n\tEMAIL: \"email\",\n\tURL: \"url\",\n\tANY: \"any\"\n};\n\n/**\n * Type detection utilities\n */\nexport class TypeDetector {\n\t/**\n\t * Get the type of a value\n\t * @param {*} value - Value to check\n\t * @returns {string} Type string\n\t */\n\tstatic getValueType (value) {\n\t\tif (value === null) return \"null\";\n\t\tif (Array.isArray(value)) return DataTypes.ARRAY;\n\t\tif (value instanceof Date) return DataTypes.DATE;\n\n\t\tconst basicType = typeof value;\n\n\t\t// Special type detection\n\t\tif (basicType === \"string\") {\n\t\t\tif (TypeDetector.isUUID(value)) return DataTypes.UUID;\n\t\t\tif (TypeDetector.isEmail(value)) return DataTypes.EMAIL;\n\t\t\tif (TypeDetector.isURL(value)) return DataTypes.URL;\n\t\t}\n\n\t\treturn basicType;\n\t}\n\n\t/**\n\t * Check if actual type matches expected type\n\t * @param {string} actualType - Actual type\n\t * @param {string} expectedType - Expected type\n\t * @returns {boolean} True if types match\n\t */\n\tstatic isTypeMatch (actualType, expectedType) {\n\t\tif (actualType === expectedType) return true;\n\n\t\t// Special cases\n\t\tif (expectedType === DataTypes.STRING) {\n\t\t\treturn [\"string\", DataTypes.UUID, DataTypes.EMAIL, DataTypes.URL].includes(actualType);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if string is a RFC 4122 compliant UUID (versions 1-5)\n\t * @param {string} value - String to check\n\t * @returns {boolean} True if valid RFC 4122 UUID format (versions 1, 2, 3, 4, or 5)\n\t */\n\tstatic isUUID (value) {\n\t\tconst uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n\t\treturn uuidRegex.test(value);\n\t}\n\n\t/**\n\t * Check if string is an email\n\t * @param {string} value - String to check\n\t * @returns {boolean} True if email format\n\t */\n\tstatic isEmail (value) {\n\t\t// WHATWG HTML5 compliant email validation pattern\n\t\tconst emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\n\t\treturn emailRegex.test(value);\n\t}\n\n\t/**\n\t * Check if string is a URL\n\t * @param {string} value - String to check\n\t * @returns {boolean} True if URL format\n\t */\n\tstatic isURL (value) {\n\t\ttry {\n\t\t\tconst url = new URL(value);\n\n\t\t\treturn Boolean(url);\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n","import { ValidationError, TypeConstraintError } from \"./errors.js\";\nimport { DataTypes, TypeDetector } from \"./data-types.js\";\n\n/**\n * Field constraint definitions for individual field validation\n */\nexport class FieldConstraint {\n\t/**\n\t * @param {Object} options - Constraint options\n\t * @param {string} options.type - Data type requirement\n\t * @param {boolean} [options.required=false] - Whether field is required\n\t * @param {*} [options.default] - Default value if not provided\n\t * @param {Function} [options.validator] - Custom validation function\n\t * @param {*} [options.min] - Minimum value (for numbers/strings/arrays)\n\t * @param {*} [options.max] - Maximum value (for numbers/strings/arrays)\n\t * @param {Array} [options.enum] - Allowed values\n\t * @param {RegExp} [options.pattern] - Pattern for string validation\n\t */\n\tconstructor ({\n\t\ttype = DataTypes.ANY,\n\t\trequired = false,\n\t\tdefault: defaultValue,\n\t\tvalidator,\n\t\tmin,\n\t\tmax,\n\t\tenum: enumValues,\n\t\tpattern\n\t} = {}) {\n\t\tthis.type = type;\n\t\tthis.required = required;\n\t\tthis.default = defaultValue;\n\t\tthis.validator = validator;\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t\tthis.enum = enumValues;\n\t\tthis.pattern = pattern;\n\t}\n\n\t/**\n\t * Validate a value against this constraint\n\t * @param {*} value - Value to validate\n\t * @param {string} fieldName - Name of the field being validated\n\t * @returns {*} Validated/normalized value\n\t * @throws {ValidationError} If validation fails\n\t */\n\tvalidate (value, fieldName = \"field\") {\n\t\t// Handle undefined values\n\t\tif (value === undefined || value === null) {\n\t\t\tif (this.required) {\n\t\t\t\tthrow new ValidationError(`Field '${fieldName}' is required`, fieldName, value);\n\t\t\t}\n\n\t\t\treturn this.default !== undefined ? this.default : value;\n\t\t}\n\n\t\t// Type validation\n\t\tconst actualType = TypeDetector.getValueType(value);\n\t\tif (this.type !== DataTypes.ANY && !TypeDetector.isTypeMatch(actualType, this.type)) {\n\t\t\tthrow new TypeConstraintError(\n\t\t\t\t`Field '${fieldName}' expected type '${this.type}' but got '${actualType}'`,\n\t\t\t\tthis.type,\n\t\t\t\tactualType,\n\t\t\t\tfieldName\n\t\t\t);\n\t\t}\n\n\t\t// Range validation\n\t\tif (this.min !== undefined && value < this.min) {\n\t\t\tthrow new ValidationError(`Field '${fieldName}' value ${value} is below minimum ${this.min}`, fieldName, value);\n\t\t}\n\t\tif (this.max !== undefined && value > this.max) {\n\t\t\tthrow new ValidationError(`Field '${fieldName}' value ${value} exceeds maximum ${this.max}`, fieldName, value);\n\t\t}\n\n\t\t// Length validation for strings and arrays\n\t\tif ((typeof value === \"string\" || Array.isArray(value)) && value.length !== undefined) {\n\t\t\tif (this.min !== undefined && value.length < this.min) {\n\t\t\t\tthrow new ValidationError(`Field '${fieldName}' length ${value.length} is below minimum ${this.min}`, fieldName, value);\n\t\t\t}\n\t\t\tif (this.max !== undefined && value.length > this.max) {\n\t\t\t\tthrow new ValidationError(`Field '${fieldName}' length ${value.length} exceeds maximum ${this.max}`, fieldName, value);\n\t\t\t}\n\t\t}\n\n\t\t// Enum validation\n\t\tif (this.enum && !this.enum.includes(value)) {\n\t\t\tthrow new ValidationError(`Field '${fieldName}' value '${value}' is not in allowed values: ${this.enum.join(\", \")}`, fieldName, value);\n\t\t}\n\n\t\t// Pattern validation\n\t\tif (this.pattern && typeof value === \"string\" && !this.pattern.test(value)) {\n\t\t\tthrow new ValidationError(`Field '${fieldName}' value '${value}' does not match required pattern`, fieldName, value);\n\t\t}\n\n\t\t// Custom validation\n\t\tif (this.validator && typeof this.validator === \"function\") {\n\t\t\tconst customResult = this.validator(value, fieldName);\n\t\t\tif (customResult !== true && customResult !== undefined) {\n\t\t\t\tconst message = typeof customResult === \"string\" ? customResult : `Custom validation failed for field '${fieldName}'`;\n\t\t\t\tthrow new ValidationError(message, fieldName, value);\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t}\n}\n","import { ValidationError } from \"./errors.js\";\n\n/**\n * Schema definition for record validation\n */\nexport class Schema {\n\t/**\n\t * @param {Object<string, FieldConstraint>} fields - Field constraints\n\t * @param {Object} [options={}] - Schema options\n\t * @param {boolean} [options.strict=false] - Whether to allow additional fields\n\t * @param {boolean} [options.stripUnknown=false] - Whether to remove unknown fields\n\t */\n\tconstructor (fields = {}, { strict = false, stripUnknown = false } = {}) {\n\t\tthis.fields = fields;\n\t\tthis.strict = strict;\n\t\tthis.stripUnknown = stripUnknown;\n\t}\n\n\t/**\n\t * Validate a record against this schema\n\t * @param {Object} record - Record to validate\n\t * @returns {Object} Validated/normalized record\n\t * @throws {ValidationError} If validation fails\n\t */\n\tvalidate (record) {\n\t\tif (!record || typeof record !== \"object\" || Array.isArray(record)) {\n\t\t\tthrow new ValidationError(\"Record must be an object\", \"record\", record);\n\t\t}\n\n\t\tconst validated = {};\n\t\tconst fieldNames = Object.keys(this.fields);\n\t\tconst recordKeys = Object.keys(record);\n\n\t\t// Validate known fields\n\t\tfor (const fieldName of fieldNames) {\n\t\t\tconst constraint = this.fields[fieldName];\n\t\t\tconst value = record[fieldName];\n\t\t\tvalidated[fieldName] = constraint.validate(value, fieldName);\n\t\t}\n\n\t\t// Handle unknown fields\n\t\tconst unknownFields = recordKeys.filter(key => !fieldNames.includes(key));\n\t\tif (unknownFields.length > 0) {\n\t\t\tif (this.strict) {\n\t\t\t\tthrow new ValidationError(`Unknown fields not allowed: ${unknownFields.join(\", \")}`, \"record\", record);\n\t\t\t} else if (!this.stripUnknown) {\n\t\t\t\t// Copy unknown fields as-is\n\t\t\t\tfor (const fieldName of unknownFields) {\n\t\t\t\t\tvalidated[fieldName] = record[fieldName];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn validated;\n\t}\n\n\t/**\n\t * Add a field constraint to the schema\n\t * @param {string} fieldName - Name of the field\n\t * @param {FieldConstraint} constraint - Field constraint\n\t * @returns {Schema} This schema for chaining\n\t */\n\taddField (fieldName, constraint) {\n\t\tthis.fields[fieldName] = constraint;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove a field constraint from the schema\n\t * @param {string} fieldName - Name of the field\n\t * @returns {Schema} This schema for chaining\n\t */\n\tremoveField (fieldName) {\n\t\tdelete this.fields[fieldName];\n\n\t\treturn this;\n\t}\n}\n","import { ConfigurationError } from \"./errors.js\";\nimport { Schema } from \"./schema.js\";\n\n/**\n * Configuration validator for Haro options\n */\nexport class ConfigValidator {\n\t/**\n\t * Validate Haro configuration\n\t * @param {Object} config - Configuration to validate\n\t * @returns {Object} Validated configuration\n\t * @throws {ConfigurationError} If configuration is invalid\n\t */\n\tstatic validate (config = {}) {\n\t\tconst validated = { ...config };\n\n\t\t// Validate delimiter\n\t\tif (validated.delimiter !== undefined) {\n\t\t\tif (typeof validated.delimiter !== \"string\" || validated.delimiter.length === 0) {\n\t\t\t\tthrow new ConfigurationError(\"Delimiter must be a non-empty string\", \"delimiter\", validated.delimiter);\n\t\t\t}\n\t\t}\n\n\t\t// Validate id\n\t\tif (validated.id !== undefined && typeof validated.id !== \"string\") {\n\t\t\tthrow new ConfigurationError(\"ID must be a string\", \"id\", validated.id);\n\t\t}\n\n\t\t// Validate immutable\n\t\tif (validated.immutable !== undefined && typeof validated.immutable !== \"boolean\") {\n\t\t\tthrow new ConfigurationError(\"Immutable must be a boolean\", \"immutable\", validated.immutable);\n\t\t}\n\n\t\t// Validate index\n\t\tif (validated.index !== undefined) {\n\t\t\tif (!Array.isArray(validated.index)) {\n\t\t\t\tthrow new ConfigurationError(\"Index must be an array\", \"index\", validated.index);\n\t\t\t}\n\t\t\tfor (const indexField of validated.index) {\n\t\t\t\tif (typeof indexField !== \"string\") {\n\t\t\t\t\tthrow new ConfigurationError(\"Index field names must be strings\", \"index\", indexField);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Validate key\n\t\tif (validated.key !== undefined && typeof validated.key !== \"string\") {\n\t\t\tthrow new ConfigurationError(\"Key field must be a string\", \"key\", validated.key);\n\t\t}\n\n\t\t// Validate versioning\n\t\tif (validated.versioning !== undefined && typeof validated.versioning !== \"boolean\") {\n\t\t\tthrow new ConfigurationError(\"Versioning must be a boolean\", \"versioning\", validated.versioning);\n\t\t}\n\n\t\t// Validate schema\n\t\tif (validated.schema !== undefined && !(validated.schema instanceof Schema)) {\n\t\t\tthrow new ConfigurationError(\"Schema must be an instance of Schema class\", \"schema\", validated.schema);\n\t\t}\n\n\t\treturn validated;\n\t}\n}\n","import { FieldConstraint } from \"./field-constraint.js\";\nimport { DataTypes } from \"./data-types.js\";\n\n/**\n * Utility functions for creating common field constraints\n */\nexport const Constraints = {\n\t/**\n\t * Create a required string field\n\t * @param {Object} [options={}] - Additional constraint options\n\t * @returns {FieldConstraint} String constraint\n\t */\n\trequiredString (options = {}) {\n\t\treturn new FieldConstraint({ type: DataTypes.STRING, required: true, ...options });\n\t},\n\n\t/**\n\t * Create an optional string field\n\t * @param {Object} [options={}] - Additional constraint options\n\t * @returns {FieldConstraint} String constraint\n\t */\n\toptionalString (options = {}) {\n\t\treturn new FieldConstraint({ type: DataTypes.STRING, required: false, ...options });\n\t},\n\n\t/**\n\t * Create a required number field\n\t * @param {Object} [options={}] - Additional constraint options\n\t * @returns {FieldConstraint} Number constraint\n\t */\n\trequiredNumber (options = {}) {\n\t\treturn new FieldConstraint({ type: DataTypes.NUMBER, required: true, ...options });\n\t},\n\n\t/**\n\t * Create an optional number field\n\t * @param {Object} [options={}] - Additional constraint options\n\t * @returns {FieldConstraint} Number constraint\n\t */\n\toptionalNumber (options = {}) {\n\t\treturn new FieldConstraint({ type: DataTypes.NUMBER, required: false, ...options });\n\t},\n\n\t/**\n\t * Create a UUID field\n\t * @param {boolean} [required=true] - Whether field is required\n\t * @returns {FieldConstraint} UUID constraint\n\t */\n\tuuid (required = true) {\n\t\treturn new FieldConstraint({ type: DataTypes.UUID, required });\n\t},\n\n\t/**\n\t * Create an email field\n\t * @param {boolean} [required=true] - Whether field is required\n\t * @returns {FieldConstraint} Email constraint\n\t */\n\temail (required = true) {\n\t\treturn new FieldConstraint({ type: DataTypes.EMAIL, required });\n\t},\n\n\t/**\n\t * Create an enum field\n\t * @param {Array} values - Allowed values\n\t * @param {boolean} [required=true] - Whether field is required\n\t * @returns {FieldConstraint} Enum constraint\n\t */\n\tenum (values, required = true) {\n\t\treturn new FieldConstraint({ enum: values, required });\n\t},\n\n\t/**\n\t * Create a date field\n\t * @param {boolean} [required=true] - Whether field is required\n\t * @returns {FieldConstraint} Date constraint\n\t */\n\tdate (required = true) {\n\t\treturn new FieldConstraint({ type: DataTypes.DATE, required });\n\t}\n};\n","// Common values\nexport const INT_0 = 0;\nexport const STRING_EMPTY = \"\";\nexport const STRING_PIPE = \"|\";\nexport const STRING_COMMA = \",\";\nexport const STRING_ID = \"id\";\n\n// Data types\nexport const STRING_STRING = \"string\";\nexport const STRING_NUMBER = \"number\";\nexport const STRING_BOOLEAN = \"boolean\";\nexport const STRING_OBJECT = \"object\";\nexport const STRING_FUNCTION = \"function\";\n\n// Operations\nexport const STRING_SET = \"set\";\nexport const STRING_DEL = \"del\";\nexport const STRING_BATCH = \"batch\";\nexport const STRING_GET = \"get\";\nexport const STRING_FIND = \"find\";\nexport const STRING_DELETE = \"delete\";\n\n// Data structures\nexport const STRING_RECORDS = \"records\";\nexport const STRING_INDEXES = \"indexes\";\nexport const STRING_VERSIONS = \"versions\";\nexport const STRING_REGISTRY = \"registry\";\nexport const STRING_SIZE = \"size\";\n\n// Logical operators\nexport const STRING_DOUBLE_PIPE = \"||\";\nexport const STRING_DOUBLE_AND = \"&&\";\n\n// Error messages\nexport const STRING_RECORD_NOT_FOUND = \"Record not found\";\nexport const STRING_INVALID_FUNCTION = \"Invalid function\";\nexport const STRING_INVALID_FIELD = \"Invalid field\";\nexport const STRING_INVALID_TYPE = \"Invalid type\";\nexport const STRING_INVALID_INDEX = \"Invalid index\";\nexport const STRING_INVALID_OPERATION = \"Invalid operation\";\n\n// Configuration keys\nexport const CONFIG_DELIMITER = \"delimiter\";\nexport const CONFIG_ID = \"id\";\nexport const CONFIG_IMMUTABLE = \"immutable\";\nexport const CONFIG_INDEX = \"index\";\nexport const CONFIG_KEY = \"key\";\nexport const CONFIG_VERSIONING = \"versioning\";\nexport const CONFIG_SCHEMA = \"schema\";\nexport const CONFIG_RETENTION_POLICY = \"retentionPolicy\";\nexport const CONFIG_ENABLE_TRANSACTIONS = \"enableTransactions\";\nexport const CONFIG_ENABLE_OPTIMIZATION = \"enableOptimization\";\n\n// Default values\nexport const DEFAULT_DELIMITER = STRING_PIPE;\nexport const DEFAULT_KEY = STRING_ID;\nexport const DEFAULT_IMMUTABLE = false;\nexport const DEFAULT_VERSIONING = false;\nexport const DEFAULT_INDEX = [];\nexport const DEFAULT_ENABLE_TRANSACTIONS = false;\nexport const DEFAULT_ENABLE_OPTIMIZATION = true;\n\n// Performance thresholds\nexport const PERFORMANCE_INDEX_THRESHOLD = 1000;\nexport const PERFORMANCE_CACHE_SIZE = 100;\nexport const PERFORMANCE_BATCH_SIZE = 1000;\nexport const PERFORMANCE_STREAM_BUFFER_SIZE = 10000;\n\n// Memory limits\nexport const MEMORY_VERSION_LIMIT = 10 * 1024 * 1024; // 10MB\nexport const MEMORY_CACHE_LIMIT = 50 * 1024 * 1024; // 50MB\nexport const MEMORY_INDEX_LIMIT = 100 * 1024 * 1024; // 100MB\n\n// Time constants\nexport const TIME_TRANSACTION_TIMEOUT = 60 * 1000; // 60 seconds\nexport const TIME_LOCK_TIMEOUT = 30 * 1000; // 30 seconds\nexport const TIME_VERSION_MAX_AGE = 30 * 24 * 60 * 60 * 1000; // 30 days\nexport const TIME_CACHE_MAX_AGE = 5 * 60 * 1000; // 5 minutes\n\n// Query optimization constants\nexport const QUERY_FULL_SCAN_THRESHOLD = 10000;\nexport const QUERY_INDEX_SELECTIVITY_THRESHOLD = 0.1;\nexport const QUERY_PLAN_CACHE_SIZE = 1000;\n\n// Validation patterns\nexport const PATTERN_UUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\nexport const PATTERN_EMAIL = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\nexport const PATTERN_URL = /^https?:\\/\\/.+/;\n\n// Error codes\nexport const ERROR_VALIDATION = \"VALIDATION_ERROR\";\nexport const ERROR_RECORD_NOT_FOUND = \"RECORD_NOT_FOUND\";\nexport const ERROR_INDEX = \"INDEX_ERROR\";\nexport const ERROR_CONFIGURATION = \"CONFIGURATION_ERROR\";\nexport const ERROR_QUERY = \"QUERY_ERROR\";\nexport const ERROR_TRANSACTION = \"TRANSACTION_ERROR\";\nexport const ERROR_VERSION = \"VERSION_ERROR\";\nexport const ERROR_TYPE_CONSTRAINT = \"TYPE_CONSTRAINT_ERROR\";\nexport const ERROR_CONCURRENCY = \"CONCURRENCY_ERROR\";\n\n// Index types\nexport const INDEX_TYPE_SINGLE = \"single\";\nexport const INDEX_TYPE_COMPOSITE = \"composite\";\nexport const INDEX_TYPE_ARRAY = \"array\";\nexport const INDEX_TYPE_PARTIAL = \"partial\";\n\n// Transaction states\nexport const TRANSACTION_STATE_PENDING = \"pending\";\nexport const TRANSACTION_STATE_ACTIVE = \"active\";\nexport const TRANSACTION_STATE_COMMITTED = \"committed\";\nexport const TRANSACTION_STATE_ABORTED = \"aborted\";\n\n// Lock types\nexport const LOCK_TYPE_SHARED = \"shared\";\nexport const LOCK_TYPE_EXCLUSIVE = \"exclusive\";\n\n// Isolation levels\nexport const ISOLATION_READ_UNCOMMITTED = 0;\nexport const ISOLATION_READ_COMMITTED = 1;\nexport const ISOLATION_REPEATABLE_READ = 2;\nexport const ISOLATION_SERIALIZABLE = 3;\n\n// Operation types for transaction log\nexport const OPERATION_TYPE_SET = \"set\";\nexport const OPERATION_TYPE_DELETE = \"delete\";\nexport const OPERATION_TYPE_BATCH = \"batch\";\n\n// Query types\nexport const QUERY_TYPE_FIND = \"find\";\nexport const QUERY_TYPE_FILTER = \"filter\";\nexport const QUERY_TYPE_SEARCH = \"search\";\nexport const QUERY_TYPE_WHERE = \"where\";\nexport const QUERY_TYPE_SORT = \"sort\";\nexport const QUERY_TYPE_LIMIT = \"limit\";\nexport const QUERY_TYPE_AGGREGATE = \"aggregate\";\n\n// Retention policy types\nexport const RETENTION_POLICY_COUNT = \"count\";\nexport const RETENTION_POLICY_TIME = \"time\";\nexport const RETENTION_POLICY_SIZE = \"size\";\nexport const RETENTION_POLICY_NONE = \"none\";\n\n// Data types for validation\nexport const DATA_TYPE_STRING = \"string\";\nexport const DATA_TYPE_NUMBER = \"number\";\nexport const DATA_TYPE_BOOLEAN = \"boolean\";\nexport const DATA_TYPE_OBJECT = \"object\";\nexport const DATA_TYPE_ARRAY = \"array\";\nexport const DATA_TYPE_DATE = \"date\";\nexport const DATA_TYPE_UUID = \"uuid\";\nexport const DATA_TYPE_EMAIL = \"email\";\nexport const DATA_TYPE_URL = \"url\";\nexport const DATA_TYPE_ANY = \"any\";\n\n// Cost factors for query optimization\nexport const COST_INDEX_LOOKUP = 1;\nexport const COST_FULL_SCAN = 100;\nexport const COST_FILTER_EVALUATION = 10;\nexport const COST_SORT_OPERATION = 50;\nexport const COST_MEMORY_ACCESS = 1;\nexport const COST_COMPARISON = 2;\nexport const COST_REGEX_MATCH = 20;\n\n// Object wrappers for backward compatibility\nexport const TransactionStates = {\n\tPENDING: TRANSACTION_STATE_PENDING,\n\tACTIVE: TRANSACTION_STATE_ACTIVE,\n\tCOMMITTED: TRANSACTION_STATE_COMMITTED,\n\tABORTED: TRANSACTION_STATE_ABORTED\n};\n\nexport const OperationTypes = {\n\tSET: OPERATION_TYPE_SET,\n\tDELETE: OPERATION_TYPE_DELETE,\n\tBATCH: OPERATION_TYPE_BATCH\n};\n\nexport const IsolationLevels = {\n\tREAD_UNCOMMITTED: ISOLATION_READ_UNCOMMITTED,\n\tREAD_COMMITTED: ISOLATION_READ_COMMITTED,\n\tREPEATABLE_READ: ISOLATION_REPEATABLE_READ,\n\tSERIALIZABLE: ISOLATION_SERIALIZABLE\n};\n\nexport const LockTypes = {\n\tSHARED: LOCK_TYPE_SHARED,\n\tEXCLUSIVE: LOCK_TYPE_EXCLUSIVE\n};\n","/**\n * Standardized record wrapper that provides consistent interface\n */\nexport class Record {\n\t/**\n\t * @param {string} key - Record key\n\t * @param {Object} data - Record data\n\t * @param {Object} [metadata={}] - Additional metadata\n\t * @param {boolean} [freeze=false] - Whether to freeze the record instance\n\t */\n\tconstructor (key, data, metadata = {}, freeze = false) {\n\t\tthis._key = key;\n\t\tthis._data = data;\n\t\tthis._metadata = metadata;\n\t\tthis._frozen = freeze;\n\n\t\t// OPTIMIZATION: Only freeze if explicitly requested\n\t\tif (freeze) {\n\t\t\tObject.freeze(this._data);\n\t\t\tObject.freeze(this._metadata);\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the record key\n\t * @returns {string} Record key\n\t */\n\tget key () {\n\t\treturn this._key;\n\t}\n\n\t/**\n\t * Get the record data\n\t * @returns {Object} Record data\n\t */\n\tget data () {\n\t\t// OPTIMIZATION: Return direct reference for performance\n\t\treturn this._data;\n\t}\n\n\t/**\n\t * Get record metadata\n\t * @returns {Object} Metadata object\n\t */\n\tget metadata () {\n\t\t// OPTIMIZATION: Return direct reference for performance\n\t\treturn this._metadata;\n\t}\n\n\t/**\n\t * Get a specific field value\n\t * @param {string} fieldName - Name of the field\n\t * @returns {*} Field value\n\t */\n\tget (fieldName) {\n\t\treturn this._data[fieldName];\n\t}\n\n\t/**\n\t * Check if record has a specific field\n\t * @param {string} fieldName - Name of the field\n\t * @returns {boolean} True if field exists\n\t */\n\thas (fieldName) {\n\t\treturn fieldName in this._data;\n\t}\n\n\t/**\n\t * Get all field names\n\t * @returns {string[]} Array of field names\n\t */\n\tgetFields () {\n\t\treturn Object.keys(this._data);\n\t}\n\n\t/**\n\t * Create a new record with updated data (immutable update)\n\t * @param {Object} updates - Data updates to apply\n\t * @param {Object} [metadataUpdates={}] - Metadata updates\n\t * @returns {Record} New record instance with updates\n\t */\n\tupdate (updates, metadataUpdates = {}) {\n\t\tconst newData = { ...this._data, ...updates };\n\t\tconst newMetadata = {\n\t\t\t...this._metadata,\n\t\t\t...metadataUpdates,\n\t\t\tupdatedAt: new Date().toISOString(),\n\t\t\tversion: this._metadata.version + 1\n\t\t};\n\n\t\t// Detect if original was frozen to maintain same freeze state\n\t\tconst shouldFreeze = Object.isFrozen(this);\n\n\t\treturn new Record(this._key, newData, newMetadata, shouldFreeze);\n\t}\n\n\t/**\n\t * Convert record to plain object\n\t * @param {boolean} [includeMetadata=false] - Whether to include metadata\n\t * @returns {Object} Plain object representation\n\t */\n\ttoObject (includeMetadata = false) {\n\t\tconst result = { ...this._data };\n\n\t\tif (includeMetadata) {\n\t\t\tresult._metadata = this._metadata;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Convert record to JSON string\n\t * @param {boolean} [includeMetadata=false] - Whether to include metadata\n\t * @returns {string} JSON string representation\n\t */\n\ttoJSON (includeMetadata = false) {\n\t\treturn JSON.stringify(this.toObject(includeMetadata));\n\t}\n\n\t/**\n\t * Compare this record with another record\n\t * @param {Record} other - Other record to compare\n\t * @returns {boolean} True if records are equal\n\t */\n\tequals (other) {\n\t\tif (!(other instanceof Record)) return false;\n\t\tif (this._key !== other._key) return false;\n\n\t\treturn JSON.stringify(this._data) === JSON.stringify(other._data);\n\t}\n\n\t/**\n\t * Create a deep clone of this record\n\t * @returns {Record} Cloned record\n\t */\n\tclone () {\n\t\tconst clonedData = structuredClone(this._data);\n\t\tconst clonedMetadata = structuredClone(this._metadata);\n\n\t\t// Detect if original was frozen to maintain same freeze state\n\t\tconst shouldFreeze = Object.isFrozen(this);\n\n\t\tconst cloned = Object.create(Record.prototype);\n\t\tcloned._key = this._key;\n\t\tcloned._data = clonedData;\n\t\tcloned._metadata = clonedMetadata;\n\n\t\tif (shouldFreeze) {\n\t\t\tObject.freeze(cloned._data);\n\t\t\tObject.freeze(cloned._metadata);\n\t\t\tObject.freeze(cloned);\n\t\t}\n\n\t\treturn cloned;\n\t}\n\n\t/**\n\t * Get the size of the record data (for memory analysis)\n\t * @returns {number} Estimated size in bytes\n\t */\n\tgetSize () {\n\t\treturn JSON.stringify(this._data).length * 2; // Rough estimate (UTF-16)\n\t}\n\n\t/**\n\t * Check if record matches a predicate\n\t * @param {Function|Object} predicate - Function or object to match against\n\t * @returns {boolean} True if record matches\n\t */\n\tmatches (predicate) {\n\t\tif (typeof predicate === \"function\") {\n\t\t\treturn predicate(this._data, this._key, this);\n\t\t}\n\n\t\tif (typeof predicate === \"object\" && predicate !== null) {\n\t\t\treturn Object.entries(predicate).every(([field, value]) => {\n\t\t\t\tconst recordValue = this._data[field];\n\n\t\t\t\tif (value instanceof RegExp) {\n\t\t\t\t\treturn value.test(recordValue);\n\t\t\t\t}\n\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\treturn Array.isArray(recordValue) ?\n\t\t\t\t\t\tvalue.some(v => recordValue.includes(v)) :\n\t\t\t\t\t\tvalue.includes(recordValue);\n\t\t\t\t}\n\n\t\t\t\treturn recordValue === value;\n\t\t\t});\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Get a string representation of the record\n\t * @returns {string} String representation\n\t */\n\ttoString () {\n\t\treturn `Record(${this._key}: ${JSON.stringify(this._data)})`;\n\t}\n\n\t/**\n\t * Symbol for iteration (makes record iterable)\n\t * @returns {Iterator} Iterator over [fieldName, value] pairs\n\t */\n\t* [Symbol.iterator] () {\n\t\tfor (const [field, value] of Object.entries(this._data)) {\n\t\t\tyield [field, value];\n\t\t}\n\t}\n}\n\n/**\n * Collection of records with utilities for batch operations\n */\nexport class RecordCollection {\n\t/**\n\t * @param {Record[]} [records=[]] - Initial records\n\t * @param {boolean} [freeze=true] - Whether to freeze the collection instance\n\t */\n\tconstructor (records = [], freeze = true) {\n\t\t// Optimized: avoid unnecessary array copying for performance\n\t\t// Collections are expected to be short-lived in most cases\n\t\tthis._records = records;\n\n\t\t// Freeze the collection if requested\n\t\tif (freeze) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the number of records\n\t * @returns {number} Number of records\n\t */\n\tget length () {\n\t\treturn this._records.length;\n\t}\n\n\t/**\n\t * Get record at specific index\n\t * @param {number} index - Index to retrieve\n\t * @returns {Record|undefined} Record at index\n\t */\n\tat (index) {\n\t\treturn this._records[index];\n\t}\n\n\t/**\n\t * Get first record\n\t * @returns {Record|undefined} First record\n\t */\n\tfirst () {\n\t\treturn this._records[0];\n\t}\n\n\t/**\n\t * Get last record\n\t * @returns {Record|undefined} Last record\n\t */\n\tlast () {\n\t\treturn this._records[this._records.length - 1];\n\t}\n\n\t/**\n\t * Filter records by predicate\n\t * @param {Function} predicate - Filter function\n\t * @returns {RecordCollection} New collection with filtered records\n\t */\n\tfilter (predicate) {\n\t\tconst shouldFreeze = Object.isFrozen(this);\n\n\t\treturn new RecordCollection(this._records.filter(predicate), shouldFreeze);\n\t}\n\n\t/**\n\t * Map records to new values\n\t * @param {Function} mapper - Mapping function\n\t * @returns {Array} Array of mapped values\n\t */\n\tmap (mapper) {\n\t\treturn this._records.map(mapper);\n\t}\n\n\t/**\n\t * Find first record matching predicate\n\t * @param {Function} predicate - Search predicate\n\t * @returns {Record|undefined} First matching record\n\t */\n\tfind (predicate) {\n\t\treturn this._records.find(predicate);\n\t}\n\n\t/**\n\t * Check if any record matches predicate\n\t * @param {Function} predicate - Test predicate\n\t * @returns {boolean} True if any record matches\n\t */\n\tsome (predicate) {\n\t\treturn this._records.some(predicate);\n\t}\n\n\t/**\n\t * Check if all records match predicate\n\t * @param {Function} predicate - Test predicate\n\t * @returns {boolean} True if all records match\n\t */\n\tevery (predicate) {\n\t\treturn this._records.every(predicate);\n\t}\n\n\t/**\n\t * Sort records by comparator\n\t * @param {Function} comparator - Sort function\n\t * @returns {RecordCollection} New sorted collection\n\t */\n\tsort (comparator) {\n\t\tconst shouldFreeze = Object.isFrozen(this);\n\n\t\treturn new RecordCollection([...this._records].sort(comparator), shouldFreeze);\n\t}\n\n\t/**\n\t * Get a slice of records\n\t * @param {number} [start=0] - Start index\n\t * @param {number} [end] - End index\n\t * @returns {RecordCollection} New collection with sliced records\n\t */\n\tslice (start = 0, end) {\n\t\tconst shouldFreeze = Object.isFrozen(this);\n\n\t\treturn new RecordCollection(this._records.slice(start, end), shouldFreeze);\n\t}\n\n\t/**\n\t * Reduce records to a single value\n\t * @param {Function} reducer - Reducer function\n\t * @param {*} [initialValue] - Initial value\n\t * @returns {*} Reduced value\n\t */\n\treduce (reducer, initialValue) {\n\t\treturn this._records.reduce(reducer, initialValue);\n\t}\n\n\t/**\n\t * Convert to array of records\n\t * @returns {Record[]} Array of records\n\t */\n\ttoArray () {\n\t\treturn [...this._records];\n\t}\n\n\t/**\n\t * Convert to array of plain objects\n\t * @param {boolean} [includeMetadata=false] - Whether to include metadata\n\t * @returns {Object[]} Array of plain objects\n\t */\n\ttoObjects (includeMetadata = false) {\n\t\treturn this._records.map(record => record.toObject(includeMetadata));\n\t}\n\n\t/**\n\t * Get an iterable of [index, record] pairs for the records array\n\t * @returns {IterableIterator<[number, Record]>} Iterator of [index, record] pairs\n\t */\n\tentries () {\n\t\treturn this._records.entries();\n\t}\n\n\t/**\n\t * Get an iterable of records in the collection\n\t * @returns {IterableIterator<Record>} Iterator of records\n\t */\n\tvalues () {\n\t\treturn this._records.values();\n\t}\n\n\t/**\n\t * Group records by field value\n\t * @param {string|Function} keySelector - Field name or function to get grouping key\n\t * @returns {Map<string, RecordCollection>} Map of grouped records\n\t */\n\tgroupBy (keySelector) {\n\t\tconst groups = new Map();\n\t\tconst getKey = typeof keySelector === \"function\" ?\n\t\t\tkeySelector :\n\t\t\trecord => record.get(keySelector);\n\n\t\tfor (const record of this._records) {\n\t\t\tconst key = getKey(record);\n\t\t\tif (!groups.has(key)) {\n\t\t\t\tgroups.set(key, []);\n\t\t\t}\n\t\t\tgroups.get(key).push(record);\n\t\t}\n\n\t\t// Convert arrays to RecordCollections\n\t\tconst shouldFreeze = Object.isFrozen(this);\n\t\tfor (const [key, records] of groups) {\n\t\t\tgroups.set(key, new RecordCollection(records, shouldFreeze));\n\t\t}\n\n\t\treturn groups;\n\t}\n\n\t/**\n\t * Get unique records (by key)\n\t * @returns {RecordCollection} Collection with unique records\n\t */\n\tunique () {\n\t\tconst seen = new Set();\n\t\tconst unique = [];\n\n\t\tfor (const record of this._records) {\n\t\t\tif (!seen.has(record.key)) {\n\t\t\t\tseen.add(record.key);\n\t\t\t\tunique.push(record);\n\t\t\t}\n\t\t}\n\n\t\tconst shouldFreeze = Object.isFrozen(this);\n\n\t\treturn new RecordCollection(unique, shouldFreeze);\n\t}\n\n\t/**\n\t * Iterate over records\n\t * @param {Function} callback - Callback function\n\t * @returns {void}\n\t */\n\tforEach (callback) {\n\t\tthis._records.forEach(callback);\n\t}\n\n\t/**\n\t * Symbol for iteration (makes collection iterable)\n\t * @returns {Iterator} Iterator over records\n\t */\n\t* [Symbol.iterator] () {\n\t\tfor (const record of this._records) {\n\t\t\tyield record;\n\t\t}\n\t}\n\n\t/**\n\t * Get string representation\n\t * @returns {string} String representation\n\t */\n\ttoString () {\n\t\treturn `RecordCollection(${this._records.length} records)`;\n\t}\n}\n\n/**\n * Factory functions for creating records and collections\n */\nexport const RecordFactory = {\n\t/**\n\t * Create a record from raw data\n\t * @param {string} key - Record key\n\t * @param {Object} data - Record data\n\t * @param {Object} [metadata={}] - Additional metadata\n\t * @param {boolean} [freeze=false] - Whether to freeze the record instance\n\t * @returns {Record} New record instance\n\t */\n\tcreate (key, data, metadata = {}, freeze = false) {\n\t\treturn new Record(key, data, metadata, freeze);\n\t},\n\n\n\t/**\n\t * Create a record from a plain object (key extracted from data)\n\t * @param {Object} data - Data object containing key field\n\t * @param {string} [keyField='id'] - Name of the key field\n\t * @param {Object} [metadata={}] - Additional metadata\n\t * @param {boolean} [freeze=false] - Whether to freeze the record instance\n\t * @returns {Record} New record instance\n\t */\n\tfromObject (data, keyField = \"id\", metadata = {}, freeze = false) {\n\t\tconst key = data[keyField];\n\t\tif (!key) {\n\t\t\tthrow new Error(`Key field '${keyField}' not found in data`);\n\t\t}\n\n\t\treturn new Record(key, data, metadata, freeze);\n\t},\n\n\t/**\n\t * Create a collection from an array of records or data objects\n\t * @param {Array<Record|Object>} items - Items to create collection from\n\t * @param {string} [keyField='id'] - Key field name for objects\n\t * @param {boolean} [freeze=true] - Whether to freeze the collection instance\n\t * @returns {RecordCollection} New record collection\n\t */\n\tcreateCollection (items, keyField = \"id\", freeze = true) {\n\t\tconst records = items.map(item => {\n\t\t\tif (item instanceof Record) {\n\t\t\t\treturn item;\n\t\t\t}\n\n\t\t\treturn this.fromObject(item, keyField);\n\t\t});\n\n\t\treturn new RecordCollection(records, freeze);\n\t},\n\n\t/**\n\t * Create an empty collection\n\t * @param {boolean} [freeze=true] - Whether to freeze the collection instance\n\t * @returns {RecordCollection} Empty record collection\n\t */\n\temptyCollection (freeze = true) {\n\t\treturn new RecordCollection([], freeze);\n\t}\n};\n","import { IndexError } from \"./errors.js\";\n\n/**\n * Types of indexes supported\n */\nexport const IndexTypes = {\n\tSINGLE: \"single\",\n\tCOMPOSITE: \"composite\",\n\tARRAY: \"array\",\n\tPARTIAL: \"partial\"\n};\n\n/**\n * Index definition with metadata\n */\nexport class IndexDefinition {\n\t/**\n\t * @param {string} name - Index name\n\t * @param {string[]} fields - Field names to index\n\t * @param {Object} [options={}] - Index options\n\t * @param {string} [options.type=IndexTypes.SINGLE] - Index type\n\t * @param {boolean} [options.unique=false] - Whether values should be unique\n\t * @param {Function} [options.filter] - Filter function for partial indexes\n\t * @param {Function} [options.transform] - Transform function for index values\n\t * @param {string} [options.delimiter='|'] - Delimiter for composite indexes\n\t */\n\tconstructor (name, fields, {\n\t\ttype = IndexTypes.SINGLE,\n\t\tunique = false,\n\t\tfilter,\n\t\ttransform,\n\t\tdelimiter = \"|\"\n\t} = {}) {\n\t\tthis.name = name;\n\t\tthis.fields = Array.isArray(fields) ? fields : [fields];\n\t\tthis.type = this._determineType(this.fields, type);\n\t\tthis.unique = unique;\n\t\tthis.filter = filter;\n\t\tthis.transform = transform;\n\t\tthis.delimiter = delimiter;\n\t\tthis.createdAt = new Date();\n\t\tthis.stats = {\n\t\t\ttotalKeys: 0,\n\t\t\ttotalEntries: 0,\n\t\t\tmemoryUsage: 0,\n\t\t\tlastUpdated: new Date()\n\t\t};\n\t}\n\n\t/**\n\t * Determine index type based on fields\n\t * @param {string[]} fields - Field names\n\t * @param {string} suggestedType - Suggested type\n\t * @returns {string} Determined index type\n\t * @private\n\t */\n\t_determineType (fields, suggestedType) {\n\t\tif (suggestedType === IndexTypes.PARTIAL) {\n\t\t\treturn IndexTypes.PARTIAL;\n\t\t}\n\n\t\tif (fields.length > 1) {\n\t\t\treturn IndexTypes.COMPOSITE;\n\t\t}\n\n\t\treturn IndexTypes.SINGLE;\n\t}\n\n\t/**\n\t * Generate index keys for a record\n\t * @param {Object} record - Record data\n\t * @returns {string[]} Array of index keys\n\t */\n\tgenerateKeys (record) {\n\t\t// Apply filter for partial indexes\n\t\tif (this.filter && !this.filter(record)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst keys = this._extractKeys(record);\n\n\t\t// Apply transform if specified\n\t\tif (this.transform) {\n\t\t\treturn keys.map(key => this.transform(key, record));\n\t\t}\n\n\t\treturn keys;\n\t}\n\n\t/**\n\t * Get field value from record (supports nested fields)\n\t * @param {Object} record - Record object\n\t * @param {string} field - Field path (e.g., \"profile.professional.department\")\n\t * @returns {*} Field value\n\t * @private\n\t */\n\t_getFieldValue (record, field) {\n\t\tconst parts = field.split(\".\");\n\t\tlet value = record;\n\n\t\tfor (const part of parts) {\n\t\t\tif (value && typeof value === \"object\") {\n\t\t\t\tvalue = value[part];\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * Extract raw keys from record\n\t * @param {Object} record - Record data\n\t * @returns {string[]} Array of raw keys\n\t * @private\n\t */\n\t_extractKeys (record) {\n\t\tif (this.type === IndexTypes.COMPOSITE) {\n\t\t\treturn this._generateCompositeKeys(record);\n\t\t}\n\n\t\tconst field = this.fields[0];\n\t\tconst value = this._getFieldValue(record, field);\n\n\t\tif (value === undefined || value === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Handle array fields\n\t\tif (Array.isArray(value)) {\n\t\t\treturn value.map(v => String(v));\n\t\t}\n\n\t\treturn [String(value)];\n\t}\n\n\t/**\n\t * Generate composite keys\n\t * @param {Object} record - Record data\n\t * @returns {string[]} Array of composite keys\n\t * @private\n\t */\n\t_generateCompositeKeys (record) {\n\t\tlet keys = [\"\"];\n\n\t\tfor (const field of this.fields.sort()) {\n\t\t\tconst value = this._getFieldValue(record, field);\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\treturn []; // Skip records with missing composite fields\n\t\t\t}\n\n\t\t\tconst values = Array.isArray(value) ? value : [value];\n\t\t\tconst newKeys = [];\n\n\t\t\tfor (const existingKey of keys) {\n\t\t\t\tfor (const val of values) {\n\t\t\t\t\tconst newKey = existingKey === \"\" ?\n\t\t\t\t\t\tString(val) :\n\t\t\t\t\t\t`${existingKey}${this.delimiter}${String(val)}`;\n\t\t\t\t\tnewKeys.push(newKey);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tkeys = newKeys;\n\t\t}\n\n\t\treturn keys;\n\t}\n\n\t/**\n\t * Update statistics\n\t * @param {number} keyCount - Number of keys\n\t * @param {number} entryCount - Number of entries\n\t * @param {number} memoryDelta - Memory change in bytes\n\t */\n\tupdateStats (keyCount, entryCount, memoryDelta) {\n\t\tthis.stats.totalKeys = keyCount;\n\t\tthis.stats.totalEntries = entryCount;\n\t\tthis.stats.memoryUsage += memoryDelta;\n\t\tthis.stats.lastUpdated = new Date();\n\t}\n}\n\n/**\n * Memory-efficient index storage with reference counting\n */\nexport class IndexStorage {\n\tconstructor () {\n\t\t// Map<indexKey, Set<recordKey>>\n\t\tthis._storage = new Map();\n\t\t// Track reference counts for memory management\n\t\tthis._refCounts = new Map();\n\t}\n\n\t/**\n\t * Add a record to index\n\t * @param {string} indexKey - Index key\n\t * @param {string} recordKey - Record key\n\t */\n\tadd (indexKey, recordKey) {\n\t\tif (!this._storage.has(indexKey)) {\n\t\t\tthis._storage.set(indexKey, new Set());\n\t\t\tthis._refCounts.set(indexKey, 0);\n\t\t}\n\n\t\tconst recordSet = this._storage.get(indexKey);\n\t\tif (!recordSet.has(recordKey)) {\n\t\t\trecordSet.add(recordKey);\n\t\t\tthis._refCounts.set(indexKey, this._refCounts.get(indexKey) + 1);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a record from index\n\t * @param {string} indexKey - Index key\n\t * @param {string} recordKey - Record key\n\t * @returns {boolean} True if record was removed\n\t */\n\tremove (indexKey, recordKey) {\n\t\tconst recordSet = this._storage.get(indexKey);\n\t\tif (!recordSet) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst removed = recordSet.delete(recordKey);\n\t\tif (removed) {\n\t\t\tconst newCount = this._refCounts.get(indexKey) - 1;\n\t\t\tif (newCount === 0) {\n\t\t\t\t// Clean up empty index keys\n\t\t\t\tthis._storage.delete(indexKey);\n\t\t\t\tthis._refCounts.delete(indexKey);\n\t\t\t} else {\n\t\t\t\tthis._refCounts.set(indexKey, newCount);\n\t\t\t}\n\t\t}\n\n\t\treturn removed;\n\t}\n\n\t/**\n\t * Get records for index key\n\t * @param {string} indexKey - Index key\n\t * @returns {Set<string>} Set of record keys\n\t */\n\tget (indexKey) {\n\t\treturn this._storage.get(indexKey) || new Set();\n\t}\n\n\t/**\n\t * Check if index key exists\n\t * @param {string} indexKey - Index key\n\t * @returns {boolean} True if key exists\n\t */\n\thas (indexKey) {\n\t\treturn this._storage.has(indexKey);\n\t}\n\n\t/**\n\t * Get all index keys\n\t * @returns {string[]} Array of index keys\n\t */\n\tkeys () {\n\t\treturn Array.from(this._storage.keys());\n\t}\n\n\t/**\n\t * Get index statistics\n\t * @returns {Object} Statistics object\n\t */\n\tgetStats () {\n\t\tlet totalEntries = 0;\n\t\tfor (const recordSet of this._storage.values()) {\n\t\t\ttotalEntries += recordSet.size;\n\t\t}\n\n\t\treturn {\n\t\t\ttotalKeys: this._storage.size,\n\t\t\ttotalEntries,\n\t\t\tmemoryUsage: this._estimateMemoryUsage()\n\t\t};\n\t}\n\n\t/**\n\t * Clear all index data\n\t */\n\tclear () {\n\t\tthis._storage.clear();\n\t\tthis._refCounts.clear();\n\t}\n\n\t/**\n\t * Estimate memory usage in bytes\n\t * @returns {number} Estimated memory usage\n\t * @private\n\t */\n\t_estimateMemoryUsage () {\n\t\tlet size = 0;\n\n\t\tfor (const [key, recordSet] of this._storage) {\n\t\t\t// Estimate key size (string)\n\t\t\tsize += key.length * 2;\n\n\t\t\t// Estimate Set overhead + record keys\n\t\t\tsize += 64; // Set object overhead\n\t\t\tfor (const recordKey of recordSet) {\n\t\t\t\tsize += recordKey.length * 2;\n\t\t\t}\n\t\t}\n\n\t\treturn size;\n\t}\n}\n\n/**\n * Index manager that handles multiple indexes efficiently\n */\nexport class IndexManager {\n\t/**\n\t * @param {string} [delimiter='|'] - Default delimiter for composite indexes\n\t */\n\tconstructor (delimiter = \"|\") {\n\t\tthis.delimiter = delimiter;\n\t\t// Map<indexName, IndexDefinition>\n\t\tthis._definitions = new Map();\n\t\t// Map<indexName, IndexStorage>\n\t\tthis._indexes = new Map();\n\t\t// Performance tracking\n\t\tthis._stats = {\n\t\t\ttotalOperations: 0,\n\t\t\ttotalTime: 0,\n\t\t\tlastOptimized: new Date()\n\t\t};\n\t}\n\n\t/**\n\t * Create a new index\n\t * @param {string} name - Index name\n\t * @param {string|string[]} fields - Field name(s) to index\n\t * @param {Object} [options={}] - Index options\n\t * @returns {IndexManager} This instance for chaining\n\t * @throws {IndexError} If index already exists or configuration is invalid\n\t */\n\tcreateIndex (name, fields, options = {}) {\n\t\tif (this._definitions.has(name)) {\n\t\t\tthrow new IndexError(`Index '${name}' already exists`, name, \"create\");\n\t\t}\n\n\t\tconst definition = new IndexDefinition(name, fields, {\n\t\t\tdelimiter: this.delimiter,\n\t\t\t...options\n\t\t});\n\n\t\tthis._definitions.set(name, definition);\n\t\tthis._indexes.set(name, new IndexStorage());\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Drop an index\n\t * @param {string} name - Index name\n\t * @returns {IndexManager} This instance for chaining\n\t * @throws {IndexError} If index doesn't exist\n\t */\n\tdropIndex (name) {\n\t\tif (!this._definitions.has(name)) {\n\t\t\tthrow new IndexError(`Index '${name}' does not exist`, name, \"drop\");\n\t\t}\n\n\t\tthis._definitions.delete(name);\n\t\tthis._indexes.delete(name);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Check if index exists\n\t * @param {string} name - Index name\n\t * @returns {boolean} True if index exists\n\t */\n\thasIndex (name) {\n\t\treturn this._definitions.has(name);\n\t}\n\n\t/**\n\t * Get index definition\n\t * @param {string} name - Index name\n\t * @returns {IndexDefinition|undefined} Index definition\n\t */\n\tgetIndexDefinition (name) {\n\t\treturn this._definitions.get(name);\n\t}\n\n\t/**\n\t * List all indexes\n\t * @returns {string[]} Array of index names\n\t */\n\tlistIndexes () {\n\t\treturn Array.from(this._definitions.keys());\n\t}\n\n\t/**\n\t * Add a record to all applicable indexes\n\t * @param {string} recordKey - Record key\n\t * @param {Object} recordData - Record data\n\t * @throws {IndexError} If unique constraint is violated\n\t */\n\taddRecord (recordKey, recordData) {\n\t\tconst startTime = Date.now();\n\n\t\tfor (const [indexName, definition] of this._definitions) {\n\t\t\tconst storage = this._indexes.get(indexName);\n\t\t\tconst indexKeys = definition.generateKeys(recordData);\n\n\t\t\tfor (const indexKey of indexKeys) {\n\t\t\t\t// Check unique constraint\n\t\t\t\tif (definition.unique && storage.has(indexKey)) {\n\t\t\t\t\tconst existingRecords = storage.get(indexKey);\n\t\t\t\t\tif (existingRecords.size > 0 && !existingRecords.has(recordKey)) {\n\t\t\t\t\t\tthrow new IndexError(\n\t\t\t\t\t\t\t`Unique constraint violation on index '${indexName}' for value '${indexKey}'`,\n\t\t\t\t\t\t\tindexName,\n\t\t\t\t\t\t\t\"add\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstorage.add(indexKey, recordKey);\n\t\t\t}\n\n\t\t\t// Update statistics\n\t\t\tconst stats = storage.getStats();\n\t\t\tdefinition.updateStats(stats.totalKeys, stats.totalEntries, 0);\n\t\t}\n\n\t\tthis._updatePerformanceStats(Date.now() - startTime);\n\t}\n\n\t/**\n\t * Remove a record from all indexes\n\t * @param {string} recordKey - Record key\n\t * @param {Object} recordData - Record data\n\t */\n\tremoveRecord (recordKey, recordData) {\n\t\tconst startTime = Date.now();\n\n\t\tfor (const [indexName, definition] of this._definitions) {\n\t\t\tconst storage = this._indexes.get(indexName);\n\t\t\tconst indexKeys = definition.generateKeys(recordData);\n\n\t\t\tfor (const indexKey of indexKeys) {\n\t\t\t\tstorage.remove(indexKey, recordKey);\n\t\t\t}\n\n\t\t\t// Update statistics\n\t\t\tconst stats = storage.getStats();\n\t\t\tdefinition.updateStats(stats.totalKeys, stats.totalEntries, 0);\n\t\t}\n\n\t\tthis._updatePerformanceStats(Date.now() - startTime);\n\t}\n\n\t/**\n\t * Update a record in indexes (remove old, add new)\n\t * @param {string} recordKey - Record key\n\t * @param {Object} oldData - Old record data\n\t * @param {Object} newData - New record data\n\t */\n\tupdateRecord (recordKey, oldData, newData) {\n\t\tthis.removeRecord(recordKey, oldData);\n\t\tthis.addRecord(recordKey, newData);\n\t}\n\n\t/**\n\t * Find records using index\n\t * @param {string} indexName - Index name\n\t * @param {string} indexKey - Index key to search for\n\t * @returns {Set<string>} Set of record keys\n\t * @throws {IndexError} If index doesn't exist\n\t */\n\tfindByIndex (indexName, indexKey) {\n\t\tconst storage = this._indexes.get(indexName);\n\t\tif (!storage) {\n\t\t\tthrow new IndexError(`Index '${indexName}' does not exist`, indexName, \"query\");\n\t\t}\n\n\t\treturn new Set(storage.get(indexKey));\n\t}\n\n\t/**\n\t * Find records using multiple criteria (intersection)\n\t * @param {Object} criteria - Object with index names as keys and search values as values\n\t * @returns {Set<string>} Set of record keys that match all criteria\n\t */\n\tfindByCriteria (criteria) {\n\t\tconst indexNames = Object.keys(criteria);\n\t\tif (indexNames.length === 0) {\n\t\t\treturn new Set();\n\t\t}\n\n\t\tlet result = null;\n\n\t\tfor (const indexName of indexNames) {\n\t\t\tconst indexKey = String(criteria[indexName]);\n\t\t\tconst records = this.findByIndex(indexName, indexKey);\n\n\t\t\tif (result === null) {\n\t\t\t\tresult = records;\n\t\t\t} else {\n\t\t\t\t// Intersection\n\t\t\t\tresult = new Set([...result].filter(key => records.has(key)));\n\t\t\t}\n\n\t\t\t// Early termination if no matches\n\t\t\tif (result.size === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Get optimal index for query fields\n\t * @param {string[]} fields - Fields being queried\n\t * @returns {string|null} Best index name or null if no suitable index\n\t */\n\tgetOptimalIndex (fields) {\n\t\tconst sortedFields = [...fields].sort();\n\n\t\t// Look for exact match first\n\t\tfor (const [name, definition] of this._definitions) {\n\t\t\tconst indexFields = [...definition.fields].sort();\n\t\t\tif (JSON.stringify(indexFields) === JSON.stringify(sortedFields)) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\n\t\t// Look for index that covers all fields\n\t\tfor (const [name, definition] of this._definitions) {\n\t\t\tif (fields.every(field => definition.fields.includes(field))) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\n\t\t// Look for index that covers some fields (prefer single field indexes)\n\t\tconst candidates = [];\n\t\tfor (const [name, definition] of this._definitions) {\n\t\t\tconst coverage = fields.filter(field => definition.fields.includes(field)).length;\n\t\t\tif (coverage > 0) {\n\t\t\t\tcandidates.push({ name, coverage, fields: definition.fields.length });\n\t\t\t}\n\t\t}\n\n\t\tif (candidates.length > 0) {\n\t\t\t// Sort by coverage (descending) then by field count (ascending)\n\t\t\tcandidates.sort((a, b) => {\n\t\t\t\tif (a.coverage !== b.coverage) {\n\t\t\t\t\treturn b.coverage - a.coverage;\n\t\t\t\t}\n\n\t\t\t\treturn a.fields - b.fields;\n\t\t\t});\n\n\t\t\treturn candidates[0].name;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Rebuild all indexes from scratch\n\t * @param {Iterable<[string, Object]>} records - All records to reindex (entries format)\n\t */\n\trebuild (records) {\n\t\t// Clear all indexes\n\t\tfor (const storage of this._indexes.values()) {\n\t\t\tstorage.clear();\n\t\t}\n\n\t\t// Rebuild from records\n\t\tfor (const [recordKey, recordData] of records) {\n\t\t\tthis.addRecord(recordKey, recordData);\n\t\t}\n\n\t\tthis._stats.lastOptimized = new Date();\n\t}\n\n\t/**\n\t * Rebuild indexes for a specific field\n\t * @param {string} field - Field to reindex\n\t * @param {Iterable<[string, Object]>} records - All records to reindex (entries format)\n\t */\n\trebuildField (field, records) {\n\t\tconst indexNames = this.listIndexes();\n\n\t\t// Find indexes that involve the specified field\n\t\tconst indexesToRebuild = indexNames.filter(indexName => {\n\t\t\tconst indexDef = this.getIndexDefinition(indexName);\n\n\t\t\treturn indexDef && indexDef.fields.includes(field);\n\t\t});\n\n\t\t// If we have indexes to rebuild\n\t\tif (indexesToRebuild.length > 0) {\n\t\t\t// Store definitions before dropping\n\t\t\tconst indexDefinitions = indexesToRebuild.map(indexName => {\n\t\t\t\tconst indexDef = this.getIndexDefinition(indexName);\n\n\t\t\t\treturn {\n\t\t\t\t\tname: indexName,\n\t\t\t\t\tfields: indexDef.fields,\n\t\t\t\t\toptions: {\n\t\t\t\t\t\ttype: indexDef.type,\n\t\t\t\t\t\tunique: indexDef.unique,\n\t\t\t\t\t\tfilter: indexDef.filter,\n\t\t\t\t\t\ttransform: indexDef.transform,\n\t\t\t\t\t\tdelimiter: indexDef.delimiter\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\n\t\t\t// Drop all indexes that need rebuilding\n\t\t\tfor (const indexName of indexesToRebuild) {\n\t\t\t\tthis.dropIndex(indexName);\n\t\t\t}\n\n\t\t\t// Recreate all dropped indexes\n\t\t\tfor (const indexDef of indexDefinitions) {\n\t\t\t\tthis.createIndex(indexDef.name, indexDef.fields, indexDef.options);\n\t\t\t}\n\n\t\t\t// Re-add all records once (this will populate all recreated indexes)\n\t\t\tfor (const [recordKey, recordData] of records) {\n\t\t\t\tthis.addRecord(recordKey, recordData);\n\t\t\t}\n\t\t}\n\n\t\tthis._stats.lastOptimized = new Date();\n\t}\n\n\t/**\n\t * Get comprehensive statistics\n\t * @returns {Object} Statistics object\n\t */\n\tgetStats () {\n\t\tconst indexStats = {};\n\t\tlet totalMemory = 0;\n\n\t\tfor (const [name, definition] of this._definitions) {\n\t\t\tconst storage = this._indexes.get(name);\n\t\t\tconst stats = storage.getStats();\n\t\t\tindexStats[name] = {\n\t\t\t\t...definition.stats,\n\t\t\t\t...stats,\n\t\t\t\ttype: definition.type,\n\t\t\t\tfields: definition.fields\n\t\t\t};\n\t\t\ttotalMemory += stats.memoryUsage;\n\t\t}\n\n\t\treturn {\n\t\t\tindexes: indexStats,\n\t\t\ttotalIndexes: this._definitions.size,\n\t\t\ttotalMemoryUsage: totalMemory,\n\t\t\tperformance: {\n\t\t\t\t...this._stats,\n\t\t\t\taverageOperationTime: this._stats.totalOperations > 0 ?\n\t\t\t\t\tthis._stats.totalTime / this._stats.totalOperations :\n\t\t\t\t\t0\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Clear all indexes\n\t */\n\tclear () {\n\t\tfor (const storage of this._indexes.values()) {\n\t\t\tstorage.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Export complete IndexManager state for persistence\n\t * @returns {Object} Complete state object with _definitions, _indexes, _stats\n\t */\n\texportState () {\n\t\t// Serialize definitions\n\t\tconst definitions = {};\n\t\tfor (const [name, definition] of this._definitions) {\n\t\t\tdefinitions[name] = {\n\t\t\t\tname: definition.name,\n\t\t\t\tfields: definition.fields,\n\t\t\t\ttype: definition.type,\n\t\t\t\tunique: definition.unique,\n\t\t\t\tdelimiter: definition.delimiter,\n\t\t\t\tcreatedAt: definition.createdAt,\n\t\t\t\tstats: definition.stats,\n\t\t\t\t// Note: filter and transform functions cannot be serialized\n\t\t\t\tfilter: null,\n\t\t\t\ttransform: null\n\t\t\t};\n\t\t}\n\n\t\t// Serialize index storage data\n\t\tconst indexes = {};\n\t\tfor (const [name, storage] of this._indexes) {\n\t\t\tconst storageData = {};\n\t\t\tfor (const indexKey of storage.keys()) {\n\t\t\t\tconst recordKeys = storage.get(indexKey);\n\t\t\t\tstorageData[indexKey] = Array.from(recordKeys);\n\t\t\t}\n\t\t\tindexes[name] = storageData;\n\t\t}\n\n\t\treturn {\n\t\t\t_definitions: definitions,\n\t\t\t_indexes: indexes,\n\t\t\t_stats: { ...this._stats }\n\t\t};\n\t}\n\n\t/**\n\t * Import complete IndexManager state from persistence\n\t * @param {Object} state - State object with _definitions, _indexes, _stats\n\t * @returns {boolean} Success status\n\t */\n\timportState (state) {\n\t\ttry {\n\t\t\t// Clear current state\n\t\t\tthis._definitions.clear();\n\t\t\tthis._indexes.clear();\n\n\t\t\t// Restore definitions\n\t\t\tfor (const [name, defData] of Object.entries(state._definitions)) {\n\t\t\t\tconst definition = new IndexDefinition(defData.name, defData.fields, {\n\t\t\t\t\ttype: defData.type,\n\t\t\t\t\tunique: defData.unique,\n\t\t\t\t\tdelimiter: defData.delimiter\n\t\t\t\t});\n\n\t\t\t\t// Restore timestamps and stats\n\t\t\t\tdefinition.createdAt = new Date(defData.createdAt);\n\t\t\t\tdefinition.stats = { ...defData.stats };\n\t\t\t\tif (definition.stats.lastUpdated) {\n\t\t\t\t\tdefinition.stats.lastUpdated = new Date(definition.stats.lastUpdated);\n\t\t\t\t}\n\n\t\t\t\tthis._definitions.set(name, definition);\n\t\t\t}\n\n\t\t\t// Restore index storage data - direct Map construction for maximum performance\n\t\t\tfor (const [name, storageData] of Object.entries(state._indexes)) {\n\t\t\t\tconst storage = new IndexStorage();\n\n\t\t\t\t// Direct Map/Set construction instead of individual add() calls\n\t\t\t\tfor (const [indexKey, recordKeysArray] of Object.entries(storageData)) {\n\t\t\t\t\tstorage._storage.set(indexKey, new Set(recordKeysArray));\n\t\t\t\t\tstorage._refCounts.set(indexKey, recordKeysArray.length);\n\t\t\t\t}\n\n\t\t\t\tthis._indexes.set(name, storage);\n\t\t\t}\n\n\t\t\t// Restore stats\n\t\t\tthis._stats = {\n\t\t\t\t...state._stats,\n\t\t\t\tlastOptimized: new Date(state._stats.lastOptimized)\n\t\t\t};\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Update performance statistics\n\t * @param {number} operationTime - Time taken for operation in ms\n\t * @private\n\t */\n\t_updatePerformanceStats (operationTime) {\n\t\tthis._stats.totalOperations++;\n\t\tthis._stats.totalTime += operationTime;\n\t}\n}\n","import { ConfigurationError } from \"./errors.js\";\n\n/**\n * Version retention policies\n */\nexport const RetentionPolicies = {\n\tCOUNT: \"count\",\n\tTIME: \"time\",\n\tSIZE: \"size\",\n\tNONE: \"none\"\n};\n\n/**\n * Version entry with metadata\n */\nexport class VersionEntry {\n\t/**\n\t * @param {Object} data - Version data\n\t * @param {Object} [metadata={}] - Version metadata\n\t */\n\tconstructor (data, metadata = {}) {\n\t\tthis.data = Object.freeze(structuredClone(data));\n\t\tthis.timestamp = new Date();\n\t\tthis.size = this._calculateSize(data);\n\t\tthis.metadata = Object.freeze({\n\t\t\toperation: \"update\",\n\t\t\t...metadata\n\t\t});\n\n\t\tObject.freeze(this);\n\t}\n\n\t/**\n\t * Calculate estimated size of version data\n\t * @param {Object} data - Data to measure\n\t * @returns {number} Size in bytes\n\t * @private\n\t */\n\t_calculateSize (data) {\n\t\ttry {\n\t\t\treturn JSON.stringify(data).length * 2; // UTF-16 estimate\n\t\t} catch {\n\t\t\treturn 1024; // Fallback estimate\n\t\t}\n\t}\n\n\t/**\n\t * Check if version is older than specified time\n\t * @param {number} maxAge - Maximum age in milliseconds\n\t * @returns {boolean} True if version is older\n\t */\n\tisOlderThan (maxAge) {\n\t\treturn Date.now() - this.timestamp.getTime() > maxAge;\n\t}\n\n\t/**\n\t * Get age of version in milliseconds\n\t * @returns {number} Age in milliseconds\n\t */\n\tgetAge () {\n\t\treturn Date.now() - this.timestamp.getTime();\n\t}\n\n\t/**\n\t * Convert to plain object for serialization\n\t * @returns {Object} Plain object representation\n\t */\n\ttoObject () {\n\t\treturn {\n\t\t\tdata: this.data,\n\t\t\ttimestamp: this.timestamp.toISOString(),\n\t\t\tsize: this.size,\n\t\t\tmetadata: this.metadata\n\t\t};\n\t}\n}\n\n/**\n * Version history for a single record\n */\nexport class VersionHistory {\n\t/**\n\t * @param {string} recordKey - Record key\n\t * @param {Object} [policy={}] - Retention policy\n\t */\n\tconstructor (recordKey, policy = {}) {\n\t\tthis.recordKey = recordKey;\n\t\tthis.policy = policy;\n\t\tthis.versions = [];\n\t\tthis.totalSize = 0;\n\t\tthis.createdAt = new Date();\n\t\tthis.lastAccessed = new Date();\n\t}\n\n\t/**\n\t * Add a new version\n\t * @param {Object} data - Version data\n\t * @param {Object} [metadata={}] - Version metadata\n\t * @returns {VersionEntry} Created version entry\n\t */\n\taddVersion (data, metadata = {}) {\n\t\tconst version = new VersionEntry(data, metadata);\n\t\tthis.versions.push(version);\n\t\tthis.totalSize += version.size;\n\t\tthis.lastAccessed = new Date();\n\n\t\t// Apply retention policy\n\t\tthis._applyRetentionPolicy();\n\n\t\treturn version;\n\t}\n\n\t/**\n\t * Get version by index (0 = oldest, -1 = newest)\n\t * @param {number} index - Version index\n\t * @returns {VersionEntry|undefined} Version entry\n\t */\n\tgetVersion (index) {\n\t\tthis.lastAccessed = new Date();\n\n\t\tif (index < 0) {\n\t\t\treturn this.versions[this.versions.length + index];\n\t\t}\n\n\t\treturn this.versions[index];\n\t}\n\n\t/**\n\t * Get latest version\n\t * @returns {VersionEntry|undefined} Latest version\n\t */\n\tgetLatest () {\n\t\treturn this.getVersion(-1);\n\t}\n\n\t/**\n\t * Get oldest version\n\t * @returns {VersionEntry|undefined} Oldest version\n\t */\n\tgetOldest () {\n\t\treturn this.getVersion(0);\n\t}\n\n\t/**\n\t * Get all versions within time range\n\t * @param {Date} [start] - Start time (inclusive)\n\t * @param {Date} [end] - End time (inclusive)\n\t * @returns {VersionEntry[]} Array of versions in range\n\t */\n\tgetVersionsInRange (start, end) {\n\t\tthis.lastAccessed = new Date();\n\n\t\treturn this.versions.filter(version => {\n\t\t\tconst timestamp = version.timestamp;\n\t\t\tconst afterStart = !start || timestamp >= start;\n\t\t\tconst beforeEnd = !end || timestamp <= end;\n\n\t\t\treturn afterStart && beforeEnd;\n\t\t});\n\t}\n\n\t/**\n\t * Get number of versions\n\t * @returns {number} Version count\n\t */\n\tgetCount () {\n\t\treturn this.versions.length;\n\t}\n\n\t/**\n\t * Get total size of all versions\n\t * @returns {number} Total size in bytes\n\t */\n\tgetTotalSize () {\n\t\treturn this.totalSize;\n\t}\n\n\t/**\n\t * Clear all versions\n\t * @returns {number} Number of versions cleared\n\t */\n\tclear () {\n\t\tconst count = this.versions.length;\n\t\tthis.versions = [];\n\t\tthis.totalSize = 0;\n\n\t\treturn count;\n\t}\n\n\t/**\n\t * Remove versions older than specified age\n\t * @param {number} maxAge - Maximum age in milliseconds\n\t * @returns {number} Number of versions removed\n\t */\n\tremoveOlderThan (maxAge) {\n\t\tconst oldCount = this.versions.length;\n\t\tconst cutoffTime = Date.now() - maxAge;\n\n\t\tthis.versions = this.versions.filter(version => {\n\t\t\tconst keep = version.timestamp.getTime() >= cutoffTime;\n\t\t\tif (!keep) {\n\t\t\t\tthis.totalSize -= version.size;\n\t\t\t}\n\n\t\t\treturn keep;\n\t\t});\n\n\t\treturn oldCount - this.versions.length;\n\t}\n\n\t/**\n\t * Apply retention policy to limit versions\n\t * @private\n\t */\n\t_applyRetentionPolicy () {\n\t\tif (!this.policy || this.policy.type === RetentionPolicies.NONE) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet removed = 0;\n\n\t\tswitch (this.policy.type) {\n\t\t\tcase RetentionPolicies.COUNT:\n\t\t\t\tremoved = this._applyCountPolicy();\n\t\t\t\tbreak;\n\t\t\tcase RetentionPolicies.TIME:\n\t\t\t\tremoved = this._applyTimePolicy();\n\t\t\t\tbreak;\n\t\t\tcase RetentionPolicies.SIZE:\n\t\t\t\tremoved = this._applySizePolicy();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tremoved = 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn removed;\n\t}\n\n\t/**\n\t * Apply count-based retention policy\n\t * @returns {number} Number of versions removed\n\t * @private\n\t */\n\t_applyCountPolicy () {\n\t\tconst maxCount = this.policy.maxCount || 10;\n\t\tif (this.versions.length <= maxCount) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst removeCount = this.versions.length - maxCount;\n\t\tconst removed = this.versions.splice(0, removeCount);\n\n\t\tfor (const version of removed) {\n\t\t\tthis.totalSize -= version.size;\n\t\t}\n\n\t\treturn removed.length;\n\t}\n\n\t/**\n\t * Apply time-based retention policy\n\t * @returns {number} Number of versions removed\n\t * @private\n\t */\n\t_applyTimePolicy () {\n\t\tconst maxAge = this.policy.maxAge || 30 * 24 * 60 * 60 * 1000; // 30 days default\n\n\t\treturn this.removeOlderThan(maxAge);\n\t}\n\n\t/**\n\t * Apply size-based retention policy\n\t * @returns {number} Number of versions removed\n\t * @private\n\t */\n\t_applySizePolicy () {\n\t\tconst maxSize = this.policy.maxSize || 10 * 1024 * 1024; // 10MB default\n\t\tif (this.totalSize <= maxSize) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet removed = 0;\n\t\twhile (this.totalSize > maxSize && this.versions.length > 1) {\n\t\t\tconst version = this.versions.shift();\n\t\t\tthis.totalSize -= version.size;\n\t\t\tremoved++;\n\t\t}\n\n\t\treturn removed;\n\t}\n\n\t/**\n\t * Get statistics for this version history\n\t * @returns {Object} Statistics object\n\t */\n\tgetStats () {\n\t\treturn {\n\t\t\trecordKey: this.recordKey,\n\t\t\tversionCount: this.versions.length,\n\t\t\ttotalSize: this.totalSize,\n\t\t\taverageSize: this.versions.length > 0 ? this.totalSize / this.versions.length : 0,\n\t\t\toldestVersion: this.versions.length > 0 ? this.versions[0].timestamp : null,\n\t\t\tnewestVersion: this.versions.length > 0 ? this.versions[this.versions.length - 1].timestamp : null,\n\t\t\tcreatedAt: this.createdAt,\n\t\t\tlastAccessed: this.lastAccessed,\n\t\t\tpolicy: this.policy\n\t\t};\n\t}\n}\n\n/**\n * Version manager for handling versioning across all records\n */\nexport class VersionManager {\n\t/**\n\t * @param {Object} [globalPolicy={}] - Global retention policy\n\t */\n\tconstructor (globalPolicy = {}) {\n\t\tthis.globalPolicy = this._validatePolicy(globalPolicy);\n\t\t// Map<recordKey, VersionHistory>\n\t\tthis.histories = new Map();\n\t\tthis.stats = {\n\t\t\ttotalHistories: 0,\n\t\t\ttotalVersions: 0,\n\t\t\ttotalSize: 0,\n\t\t\tlastCleanup: new Date(),\n\t\t\tcleanupCount: 0\n\t\t};\n\t}\n\n\t/**\n\t * Enable versioning for a record\n\t * @param {string} recordKey - Record key\n\t * @param {Object} [policy] - Custom retention policy for this record\n\t * @returns {VersionHistory} Created version history\n\t */\n\tenableVersioning (recordKey, policy) {\n\t\tif (this.histories.has(recordKey)) {\n\t\t\treturn this.histories.get(recordKey);\n\t\t}\n\n\t\tconst effectivePolicy = policy || this.globalPolicy;\n\t\tconst history = new VersionHistory(recordKey, effectivePolicy);\n\t\tthis.histories.set(recordKey, history);\n\t\tthis.stats.totalHistories++;\n\n\t\treturn history;\n\t}\n\n\t/**\n\t * Disable versioning for a record\n\t * @param {string} recordKey - Record key\n\t * @returns {boolean} True if versioning was disabled\n\t */\n\tdisableVersioning (recordKey) {\n\t\tconst history = this.histories.get(recordKey);\n\t\tif (!history) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.stats.totalVersions -= history.getCount();\n\t\tthis.stats.totalSize -= history.getTotalSize();\n\t\tthis.stats.totalHistories--;\n\n\t\treturn this.histories.delete(recordKey);\n\t}\n\n\t/**\n\t * Add a version for a record\n\t * @param {string} recordKey - Record key\n\t * @param {Object} data - Version data\n\t * @param {Object} [metadata={}] - Version metadata\n\t * @returns {VersionEntry} Created version entry\n\t * @throws {VersionError} If versioning is not enabled for record\n\t */\n\taddVersion (recordKey, data, metadata = {}) {\n\t\tlet history = this.histories.get(recordKey);\n\t\tif (!history) {\n\t\t\t// Auto-enable versioning with global policy\n\t\t\thistory = this.enableVersioning(recordKey);\n\t\t}\n\n\t\tconst oldCount = history.getCount();\n\t\tconst oldSize = history.getTotalSize();\n\n\t\tconst version = history.addVersion(data, metadata);\n\n\t\t// Update global stats\n\t\tthis.stats.totalVersions += history.getCount() - oldCount;\n\t\tthis.stats.totalSize += history.getTotalSize() - oldSize;\n\n\t\treturn version;\n\t}\n\n\t/**\n\t * Get version history for a record\n\t * @param {string} recordKey - Record key\n\t * @returns {VersionHistory|undefined} Version history\n\t */\n\tgetHistory (recordKey) {\n\t\treturn this.histories.get(recordKey);\n\t}\n\n\t/**\n\t * Get specific version of a record\n\t * @param {string} recordKey - Record key\n\t * @param {number} versionIndex - Version index\n\t * @returns {VersionEntry|undefined} Version entry\n\t */\n\tgetVersion (recordKey, versionIndex) {\n\t\tconst history = this.histories.get(recordKey);\n\n\t\treturn history ? history.getVersion(versionIndex) : undefined;\n\t}\n\n\t/**\n\t * Get latest version of a record\n\t * @param {string} recordKey - Record key\n\t * @returns {VersionEntry|undefined} Latest version\n\t */\n\tgetLatestVersion (recordKey) {\n\t\tconst history = this.histories.get(recordKey);\n\n\t\treturn history ? history.getLatest() : undefined;\n\t}\n\n\t/**\n\t * Check if versioning is enabled for a record\n\t * @param {string} recordKey - Record key\n\t * @returns {boolean} True if versioning is enabled\n\t */\n\tisVersioningEnabled (recordKey) {\n\t\treturn this.histories.has(recordKey);\n\t}\n\n\t/**\n\t * Clean up versions based on retention policies\n\t * @param {Object} [options={}] - Cleanup options\n\t * @param {boolean} [options.force=false] - Force cleanup even if not needed\n\t * @param {string[]} [options.recordKeys] - Specific records to clean up\n\t * @returns {Object} Cleanup results\n\t */\n\tcleanup (options = {}) {\n\t\tconst { recordKeys } = options;\n\t\tconst results = {\n\t\t\thistoriesProcessed: 0,\n\t\t\tversionsRemoved: 0,\n\t\t\tsizeFreed: 0,\n\t\t\tstartTime: new Date()\n\t\t};\n\n\t\tconst keysToProcess = recordKeys || Array.from(this.histories.keys());\n\n\t\tfor (const recordKey of keysToProcess) {\n\t\t\tconst history = this.histories.get(recordKey);\n\t\t\tif (history) {\n\t\t\t\tconst oldCount = history.getCount();\n\t\t\t\tconst oldSize = history.getTotalSize();\n\n\t\t\t\t// Apply retention policy\n\t\t\t\thistory._applyRetentionPolicy();\n\n\t\t\t\tconst newCount = history.getCount();\n\t\t\t\tconst newSize = history.getTotalSize();\n\n\t\t\t\tresults.historiesProcessed++;\n\t\t\t\tresults.versionsRemoved += oldCount - newCount;\n\t\t\t\tresults.sizeFreed += oldSize - newSize;\n\n\t\t\t\t// Remove empty histories\n\t\t\t\tif (newCount === 0) {\n\t\t\t\t\tthis.histories.delete(recordKey);\n\t\t\t\t\tthis.stats.totalHistories--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Update global stats\n\t\tthis.stats.totalVersions -= results.versionsRemoved;\n\t\tthis.stats.totalSize -= results.sizeFreed;\n\t\tthis.stats.lastCleanup = new Date();\n\t\tthis.stats.cleanupCount++;\n\n\t\tresults.endTime = new Date();\n\t\tresults.duration = results.endTime.getTime() - results.startTime.getTime();\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Set global retention policy\n\t * @param {Object} policy - Retention policy\n\t * @returns {VersionManager} This instance for chaining\n\t */\n\tsetGlobalPolicy (policy) {\n\t\tthis.globalPolicy = this._validatePolicy(policy);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get comprehensive statistics\n\t * @returns {Object} Statistics object\n\t */\n\tgetStats () {\n\t\t// Recalculate stats from histories\n\t\tlet totalVersions = 0;\n\t\tlet totalSize = 0;\n\t\tconst historyStats = [];\n\n\t\tfor (const history of this.histories.values()) {\n\t\t\tconst stats = history.getStats();\n\t\t\thistoryStats.push(stats);\n\t\t\ttotalVersions += stats.versionCount;\n\t\t\ttotalSize += stats.totalSize;\n\t\t}\n\n\t\treturn {\n\t\t\t...this.stats,\n\t\t\ttotalHistories: this.histories.size,\n\t\t\ttotalVersions,\n\t\t\ttotalSize,\n\t\t\taverageVersionsPerRecord: this.histories.size > 0 ? totalVersions / this.histories.size : 0,\n\t\t\taverageSizePerRecord: this.histories.size > 0 ? totalSize / this.histories.size : 0,\n\t\t\tglobalPolicy: this.globalPolicy,\n\t\t\thistories: historyStats\n\t\t};\n\t}\n\n\t/**\n\t * Export version data for backup\n\t * @param {string[]} [recordKeys] - Specific records to export\n\t * @returns {Object} Exportable version data\n\t */\n\texport (recordKeys) {\n\t\tconst keysToExport = recordKeys || Array.from(this.histories.keys());\n\t\tconst exportData = {\n\t\t\tglobalPolicy: this.globalPolicy,\n\t\t\thistories: {},\n\t\t\texportedAt: new Date().toISOString()\n\t\t};\n\n\t\tfor (const recordKey of keysToExport) {\n\t\t\tconst history = this.histories.get(recordKey);\n\t\t\tif (history) {\n\t\t\t\texportData.histories[recordKey] = {\n\t\t\t\t\tpolicy: history.policy,\n\t\t\t\t\tversions: history.versions.map(v => v.toObject()),\n\t\t\t\t\tcreatedAt: history.createdAt.toISOString(),\n\t\t\t\t\tlastAccessed: history.lastAccessed.toISOString()\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn exportData;\n\t}\n\n\t/**\n\t * Import version data from backup\n\t * @param {Object} exportData - Exported version data\n\t * @param {Object} [options={}] - Import options\n\t * @param {boolean} [options.merge=false] - Whether to merge with existing data\n\t * @returns {Object} Import results\n\t */\n\timport (exportData, options = {}) {\n\t\tconst { merge = false } = options;\n\t\tconst results = {\n\t\t\thistoriesImported: 0,\n\t\t\tversionsImported: 0,\n\t\t\terrors: []\n\t\t};\n\n\t\tif (!merge) {\n\t\t\tthis.histories.clear();\n\t\t}\n\n\t\tif (exportData.globalPolicy) {\n\t\t\tthis.globalPolicy = this._validatePolicy(exportData.globalPolicy);\n\t\t}\n\n\t\tfor (const [recordKey, historyData] of Object.entries(exportData.histories)) {\n\t\t\ttry {\n\t\t\t\tconst history = new VersionHistory(recordKey, historyData.policy);\n\t\t\t\thistory.createdAt = new Date(historyData.createdAt);\n\t\t\t\thistory.lastAccessed = new Date(historyData.lastAccessed);\n\n\t\t\t\tfor (const versionData of historyData.versions) {\n\t\t\t\t\tconst version = new VersionEntry(versionData.data, versionData.metadata);\n\t\t\t\t\t// Restore original timestamp\n\t\t\t\t\tObject.defineProperty(version, \"timestamp\", {\n\t\t\t\t\t\tvalue: new Date(versionData.timestamp),\n\t\t\t\t\t\twritable: false\n\t\t\t\t\t});\n\t\t\t\t\thistory.versions.push(version);\n\t\t\t\t\thistory.totalSize += version.size;\n\t\t\t\t\tresults.versionsImported++;\n\t\t\t\t}\n\n\t\t\t\tthis.histories.set(recordKey, history);\n\t\t\t\tresults.historiesImported++;\n\t\t\t} catch (error) {\n\t\t\t\tresults.errors.push({\n\t\t\t\t\trecordKey,\n\t\t\t\t\terror: error.message\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Update stats\n\t\tthis._updateStats();\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Clear all version data\n\t * @returns {Object} Clear results\n\t */\n\tclear () {\n\t\tconst results = {\n\t\t\thistoriesCleared: this.histories.size,\n\t\t\tversionsCleared: this.stats.totalVersions,\n\t\t\tsizeFreed: this.stats.totalSize\n\t\t};\n\n\t\tthis.histories.clear();\n\t\tthis.stats = {\n\t\t\ttotalHistories: 0,\n\t\t\ttotalVersions: 0,\n\t\t\ttotalSize: 0,\n\t\t\tlastCleanup: new Date(),\n\t\t\tcleanupCount: this.stats.cleanupCount\n\t\t};\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Validate retention policy\n\t * @param {Object} policy - Policy to validate\n\t * @returns {Object} Validated policy\n\t * @throws {ConfigurationError} If policy is invalid\n\t * @private\n\t */\n\t_validatePolicy (policy) {\n\t\tif (!policy || typeof policy !== \"object\") {\n\t\t\treturn { type: RetentionPolicies.NONE };\n\t\t}\n\n\t\tconst validTypes = Object.values(RetentionPolicies);\n\t\tif (policy.type && !validTypes.includes(policy.type)) {\n\t\t\tthrow new ConfigurationError(`Invalid retention policy type: ${policy.type}`, \"retentionPolicy.type\", policy.type);\n\t\t}\n\n\t\tconst validated = { ...policy };\n\n\t\tif (validated.type === RetentionPolicies.COUNT && validated.maxCount !== undefined) {\n\t\t\tif (typeof validated.maxCount !== \"number\" || validated.maxCount < 1) {\n\t\t\t\tthrow new ConfigurationError(\"maxCount must be a positive number\", \"retentionPolicy.maxCount\", validated.maxCount);\n\t\t\t}\n\t\t}\n\n\t\tif (validated.type === RetentionPolicies.TIME && validated.maxAge !== undefined) {\n\t\t\tif (typeof validated.maxAge !== \"number\" || validated.maxAge < 1) {\n\t\t\t\tthrow new ConfigurationError(\"maxAge must be a positive number\", \"retentionPolicy.maxAge\", validated.maxAge);\n\t\t\t}\n\t\t}\n\n\t\tif (validated.type === RetentionPolicies.SIZE && validated.maxSize !== undefined) {\n\t\t\tif (typeof validated.maxSize !== \"number\" || validated.maxSize < 1) {\n\t\t\t\tthrow new ConfigurationError(\"maxSize must be a positive number\", \"retentionPolicy.maxSize\", validated.maxSize);\n\t\t\t}\n\t\t}\n\n\t\treturn validated;\n\t}\n\n\t/**\n\t * Update global statistics\n\t * @private\n\t */\n\t_updateStats () {\n\t\tlet totalVersions = 0;\n\t\tlet totalSize = 0;\n\n\t\tfor (const history of this.histories.values()) {\n\t\t\ttotalVersions += history.getCount();\n\t\t\ttotalSize += history.getTotalSize();\n\t\t}\n\n\t\tthis.stats.totalHistories = this.histories.size;\n\t\tthis.stats.totalVersions = totalVersions;\n\t\tthis.stats.totalSize = totalSize;\n\t}\n}\n","import { TransactionError } from \"./errors.js\";\nimport { OperationTypes } from \"./constants.js\";\nimport { randomUUID as uuid } from \"crypto\";\n\n/**\n * Transaction operation entry\n */\nexport class TransactionOperation {\n\t/**\n\t * @param {string} type - Operation type\n\t * @param {string} key - Record key\n\t * @param {*} [oldValue] - Previous value (for rollback)\n\t * @param {*} [newValue] - New value\n\t * @param {Object} [metadata={}] - Additional metadata\n\t */\n\tconstructor (type, key, oldValue, newValue, metadata = {}) {\n\t\tthis.id = uuid();\n\t\tthis.type = type;\n\t\tthis.key = key;\n\t\tthis.oldValue = oldValue;\n\t\tthis.newValue = newValue;\n\t\tthis.metadata = metadata;\n\t\tthis.timestamp = new Date();\n\n\t\tObject.freeze(this);\n\t}\n\n\t/**\n\t * Create rollback operation\n\t * @returns {TransactionOperation} Rollback operation\n\t */\n\tcreateRollback () {\n\t\tswitch (this.type) {\n\t\t\tcase OperationTypes.SET:\n\t\t\t\treturn this.oldValue === undefined ?\n\t\t\t\t\tnew TransactionOperation(OperationTypes.DELETE, this.key, this.newValue, undefined) :\n\t\t\t\t\tnew TransactionOperation(OperationTypes.SET, this.key, this.newValue, this.oldValue);\n\n\t\t\tcase OperationTypes.DELETE:\n\t\t\t\treturn new TransactionOperation(OperationTypes.SET, this.key, undefined, this.oldValue);\n\n\t\t\tdefault:\n\t\t\t\tthrow new TransactionError(`Cannot create rollback for operation type: ${this.type}`, null, \"rollback\");\n\t\t}\n\t}\n}\n","import { TransactionError } from \"./errors.js\";\nimport { TransactionStates, IsolationLevels } from \"./constants.js\";\nimport { TransactionOperation } from \"./transaction-operation.js\";\nimport { randomUUID as uuid } from \"crypto\";\n\n/**\n * Transaction implementation with ACID properties\n */\nexport class Transaction {\n\t/**\n\t * @param {string} [id] - Transaction ID (auto-generated if not provided)\n\t * @param {Object} [options={}] - Transaction options\n\t * @param {number} [options.isolationLevel=IsolationLevels.READ_COMMITTED] - Isolation level\n\t * @param {number} [options.timeout=60000] - Transaction timeout in milliseconds\n\t * @param {boolean} [options.readOnly=false] - Whether transaction is read-only\n\t */\n\tconstructor (id = uuid(), options = {}) {\n\t\tthis.id = id;\n\t\tthis.state = TransactionStates.PENDING;\n\t\tthis.isolationLevel = options.isolationLevel || IsolationLevels.READ_COMMITTED;\n\t\tthis.timeout = options.timeout || 60000;\n\t\tthis.readOnly = options.readOnly || false;\n\t\tthis.startTime = null;\n\t\tthis.endTime = null;\n\n\t\t// Operation log for rollback\n\t\tthis.operations = [];\n\n\t\t// Read set for isolation (record keys read during transaction)\n\t\tthis.readSet = new Set();\n\n\t\t// Write set for isolation (record keys written during transaction)\n\t\tthis.writeSet = new Set();\n\n\t\t// Snapshot for repeatable read isolation\n\t\tthis.snapshot = new Map();\n\n\t\t// Validation callback for custom constraints\n\t\tthis.validationCallback = null;\n\n\t\t// Abort reason (set when transaction is aborted)\n\t\tthis.abortReason = null;\n\n\t\tObject.seal(this);\n\t}\n\n\t/**\n\t * Begin the transaction\n\t * @returns {Transaction} This transaction for chaining\n\t * @throws {TransactionError} If transaction is already active\n\t */\n\tbegin () {\n\t\tif (this.state !== TransactionStates.PENDING) {\n\t\t\tthrow new TransactionError(\n\t\t\t\t`Cannot begin transaction in state: ${this.state}`,\n\t\t\t\tthis.id,\n\t\t\t\t\"begin\"\n\t\t\t);\n\t\t}\n\n\t\tthis.state = TransactionStates.ACTIVE;\n\t\tthis.startTime = new Date();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an operation to the transaction log\n\t * @param {string} type - Operation type\n\t * @param {string} key - Record key\n\t * @param {*} [oldValue] - Previous value\n\t * @param {*} [newValue] - New value\n\t * @param {Object} [metadata={}] - Additional metadata\n\t * @returns {TransactionOperation} Created operation\n\t * @throws {TransactionError} If transaction is not active or is read-only\n\t */\n\taddOperation (type, key, oldValue, newValue, metadata = {}) {\n\t\tthis._checkActive();\n\n\t\tif (this.readOnly && type !== \"read\") {\n\t\t\tthrow new TransactionError(\n\t\t\t\t\"Cannot perform write operations in read-only transaction\",\n\t\t\t\tthis.id,\n\t\t\t\t\"write\"\n\t\t\t);\n\t\t}\n\n\t\t// Check timeout\n\t\tif (this._isTimedOut()) {\n\t\t\tthrow new TransactionError(\n\t\t\t\t\"Transaction has timed out\",\n\t\t\t\tthis.id,\n\t\t\t\t\"timeout\"\n\t\t\t);\n\t\t}\n\n\t\tconst operation = new TransactionOperation(type, key, oldValue, newValue, metadata);\n\t\tthis.operations.push(operation);\n\n\t\t// Track read and write sets\n\t\tif (type === \"read\") {\n\t\t\tthis.readSet.add(key);\n\t\t} else {\n\t\t\tthis.writeSet.add(key);\n\t\t}\n\n\t\treturn operation;\n\t}\n\n\t/**\n\t * Set validation callback for custom constraints\n\t * @param {Function} callback - Validation function\n\t * @returns {Transaction} This transaction for chaining\n\t */\n\tsetValidation (callback) {\n\t\tthis.validationCallback = callback;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Validate transaction before commit\n\t * @param {Object} [context] - Validation context\n\t * @returns {boolean} True if validation passes\n\t * @throws {TransactionError} If validation fails\n\t */\n\tvalidate (context = {}) {\n\t\tif (this.validationCallback) {\n\t\t\tconst result = this.validationCallback(this, context);\n\t\t\tif (result !== true) {\n\t\t\t\tconst message = typeof result === \"string\" ? result : \"Transaction validation failed\";\n\t\t\t\tthrow new TransactionError(message, this.id, \"validation\");\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Commit the transaction\n\t * @param {Object} [context] - Commit context\n\t * @returns {Transaction} This transaction for chaining\n\t * @throws {TransactionError} If commit fails\n\t */\n\tcommit (context = {}) {\n\t\tthis._checkActive();\n\n\t\ttry {\n\t\t\t// Validate before commit\n\t\t\tthis.validate(context);\n\n\t\t\tthis.state = TransactionStates.COMMITTED;\n\t\t\tthis.endTime = new Date();\n\n\t\t\treturn this;\n\t\t} catch (error) {\n\t\t\t// Auto-abort on commit failure\n\t\t\tthis.abort();\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Abort the transaction\n\t * @param {string} [reason] - Reason for abort\n\t * @returns {Transaction} This transaction for chaining\n\t */\n\tabort (reason = \"User abort\") {\n\t\tif (this.state === TransactionStates.ABORTED || this.state === TransactionStates.COMMITTED) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis.state = TransactionStates.ABORTED;\n\t\tthis.endTime = new Date();\n\t\tthis.abortReason = reason;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get rollback operations (in reverse order)\n\t * @returns {TransactionOperation[]} Array of rollback operations\n\t */\n\tgetRollbackOperations () {\n\t\treturn this.operations\n\t\t\t.slice()\n\t\t\t.reverse()\n\t\t\t.filter(op => op.type !== \"read\") // Filter out read operations\n\t\t\t.map(op => op.createRollback())\n\t\t\t.filter(op => op !== null);\n\t}\n\n\t/**\n\t * Check if transaction is active\n\t * @returns {boolean} True if transaction is active\n\t */\n\tisActive () {\n\t\treturn this.state === TransactionStates.ACTIVE;\n\t}\n\n\t/**\n\t * Check if transaction is committed\n\t * @returns {boolean} True if transaction is committed\n\t */\n\tisCommitted () {\n\t\treturn this.state === TransactionStates.COMMITTED;\n\t}\n\n\t/**\n\t * Check if transaction is aborted\n\t * @returns {boolean} True if transaction is aborted\n\t */\n\tisAborted () {\n\t\treturn this.state === TransactionStates.ABORTED;\n\t}\n\n\t/**\n\t * Get transaction duration\n\t * @returns {number|null} Duration in milliseconds, null if not completed\n\t */\n\tgetDuration () {\n\t\tif (!this.startTime) return null;\n\t\tconst endTime = this.endTime || new Date();\n\n\t\treturn endTime.getTime() - this.startTime.getTime();\n\t}\n\n\t/**\n\t * Get transaction statistics\n\t * @returns {Object} Transaction statistics\n\t */\n\tgetStats () {\n\t\treturn {\n\t\t\tid: this.id,\n\t\t\tstate: this.state,\n\t\t\tisolationLevel: this.isolationLevel,\n\t\t\treadOnly: this.readOnly,\n\t\t\tstartTime: this.startTime,\n\t\t\tendTime: this.endTime,\n\t\t\tduration: this.getDuration(),\n\t\t\toperationCount: this.operations.length,\n\t\t\treadSetSize: this.readSet.size,\n\t\t\twriteSetSize: this.writeSet.size,\n\t\t\tsnapshotSize: this.snapshot.size,\n\t\t\tabortReason: this.abortReason,\n\t\t\ttimedOut: this._isTimedOut()\n\t\t};\n\t}\n\n\t/**\n\t * Export transaction for debugging/logging\n\t * @returns {Object} Exportable transaction data\n\t */\n\texport () {\n\t\treturn {\n\t\t\t...this.getStats(),\n\t\t\toperations: this.operations.map(op => ({\n\t\t\t\tid: op.id,\n\t\t\t\ttype: op.type,\n\t\t\t\tkey: op.key,\n\t\t\t\ttimestamp: op.timestamp,\n\t\t\t\tmetadata: op.metadata\n\t\t\t})),\n\t\t\treadSet: Array.from(this.readSet),\n\t\t\twriteSet: Array.from(this.writeSet)\n\t\t};\n\t}\n\n\t/**\n\t * Check if transaction is active and throw if not\n\t * @throws {TransactionError} If transaction is not active\n\t * @private\n\t */\n\t_checkActive () {\n\t\tif (this.state !== TransactionStates.ACTIVE) {\n\t\t\tthrow new TransactionError(\n\t\t\t\t`Transaction is not active (current state: ${this.state})`,\n\t\t\t\tthis.id,\n\t\t\t\t\"state\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Check if transaction has timed out\n\t * @returns {boolean} True if timed out\n\t * @private\n\t */\n\t_isTimedOut () {\n\t\tif (!this.startTime) return false;\n\n\t\treturn Date.now() - this.startTime.getTime() > this.timeout;\n\t}\n}\n","import { ConcurrencyError } from \"./errors.js\";\nimport { LockTypes } from \"./constants.js\";\n\n/**\n * Lock manager for controlling concurrent access\n */\nexport class LockManager {\n\tconstructor () {\n\t\t// Map<recordKey, {type: string, holders: Set<transactionId>, waiters: Array}>\n\t\tthis.locks = new Map();\n\t\tthis.lockTimeout = 30000; // 30 seconds default\n\t}\n\n\t/**\n\t * Acquire a lock on a record\n\t * @param {string} transactionId - Transaction ID\n\t * @param {string} recordKey - Record key to lock\n\t * @param {string} lockType - Type of lock (shared/exclusive)\n\t * @param {number} [timeout] - Lock timeout in milliseconds\n\t * @returns {Promise<boolean>} True if lock acquired\n\t * @throws {ConcurrencyError} If lock cannot be acquired\n\t */\n\tasync acquireLock (transactionId, recordKey, lockType, timeout = this.lockTimeout) {\n\t\tconst startTime = Date.now();\n\n\t\twhile (Date.now() - startTime < timeout) {\n\t\t\tif (this._tryAcquireLock(transactionId, recordKey, lockType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Wait a bit before retrying\n\t\t\tawait new Promise(resolve => setTimeout(resolve, 10));\n\t\t}\n\n\t\tthrow new ConcurrencyError(\n\t\t\t`Failed to acquire ${lockType} lock on record '${recordKey}' within timeout`,\n\t\t\trecordKey,\n\t\t\t\"lock\"\n\t\t);\n\t}\n\n\t/**\n\t * Try to acquire lock immediately\n\t * @param {string} transactionId - Transaction ID\n\t * @param {string} recordKey - Record key\n\t * @param {string} lockType - Lock type\n\t * @returns {boolean} True if lock acquired\n\t * @private\n\t */\n\t_tryAcquireLock (transactionId, recordKey, lockType) {\n\t\tconst existingLock = this.locks.get(recordKey);\n\n\t\tif (!existingLock) {\n\t\t\t// No existing lock, create new one\n\t\t\tthis.locks.set(recordKey, {\n\t\t\t\ttype: lockType,\n\t\t\t\tholders: new Set([transactionId]),\n\t\t\t\twaiters: []\n\t\t\t});\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check if already holding the lock\n\t\tif (existingLock.holders.has(transactionId)) {\n\t\t\t// Check for lock upgrade\n\t\t\tif (existingLock.type === LockTypes.SHARED && lockType === LockTypes.EXCLUSIVE) {\n\t\t\t\t// Can upgrade if we're the only holder\n\t\t\t\tif (existingLock.holders.size === 1) {\n\t\t\t\t\texistingLock.type = LockTypes.EXCLUSIVE;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false; // Cannot upgrade with other holders\n\t\t\t}\n\n\t\t\treturn true; // Already have compatible lock\n\t\t}\n\n\t\t// Check compatibility\n\t\tif (lockType === LockTypes.SHARED && existingLock.type === LockTypes.SHARED) {\n\t\t\t// Shared locks are compatible\n\t\t\texistingLock.holders.add(transactionId);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Exclusive locks or mixed locks are not compatible\n\t\treturn false;\n\t}\n\n\t/**\n\t * Release a lock\n\t * @param {string} transactionId - Transaction ID\n\t * @param {string} recordKey - Record key\n\t * @returns {boolean} True if lock was released\n\t */\n\treleaseLock (transactionId, recordKey) {\n\t\tconst lock = this.locks.get(recordKey);\n\t\tif (!lock || !lock.holders.has(transactionId)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlock.holders.delete(transactionId);\n\n\t\t// If no more holders, remove the lock\n\t\tif (lock.holders.size === 0) {\n\t\t\tthis.locks.delete(recordKey);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Release all locks held by a transaction\n\t * @param {string} transactionId - Transaction ID\n\t * @returns {number} Number of locks released\n\t */\n\treleaseAllLocks (transactionId) {\n\t\tlet released = 0;\n\n\t\tfor (const [recordKey, lock] of this.locks) {\n\t\t\tif (lock.holders.has(transactionId)) {\n\t\t\t\tlock.holders.delete(transactionId);\n\t\t\t\treleased++;\n\n\t\t\t\t// If no more holders, remove the lock\n\t\t\t\tif (lock.holders.size === 0) {\n\t\t\t\t\tthis.locks.delete(recordKey);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn released;\n\t}\n\n\t/**\n\t * Check if transaction holds any locks\n\t * @param {string} transactionId - Transaction ID\n\t * @returns {boolean} True if transaction holds locks\n\t */\n\tholdsLocks (transactionId) {\n\t\tfor (const lock of this.locks.values()) {\n\t\t\tif (lock.holders.has(transactionId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Get lock statistics\n\t * @returns {Object} Lock statistics\n\t */\n\tgetStats () {\n\t\tconst stats = {\n\t\t\ttotalLocks: this.locks.size,\n\t\t\tsharedLocks: 0,\n\t\t\texclusiveLocks: 0,\n\t\t\tlockHolders: new Set(),\n\t\t\trecordsLocked: []\n\t\t};\n\n\t\tfor (const [recordKey, lock] of this.locks) {\n\t\t\tif (lock.type === LockTypes.SHARED) {\n\t\t\t\tstats.sharedLocks++;\n\t\t\t} else {\n\t\t\t\tstats.exclusiveLocks++;\n\t\t\t}\n\n\t\t\tfor (const holder of lock.holders) {\n\t\t\t\tstats.lockHolders.add(holder);\n\t\t\t}\n\n\t\t\tstats.recordsLocked.push({\n\t\t\t\trecordKey,\n\t\t\t\ttype: lock.type,\n\t\t\t\tholders: Array.from(lock.holders)\n\t\t\t});\n\t\t}\n\n\t\tstats.uniqueHolders = stats.lockHolders.size;\n\n\t\treturn stats;\n\t}\n}\n","/**\n * Transaction statistics manager for tracking metrics and performance\n */\nexport class TransactionStatistics {\n\tconstructor () {\n\t\tthis.stats = {\n\t\t\ttotalTransactions: 0,\n\t\t\tcommittedTransactions: 0,\n\t\t\tabortedTransactions: 0,\n\t\t\tactiveTransactions: 0,\n\t\t\taverageDuration: 0,\n\t\t\ttotalDuration: 0\n\t\t};\n\t}\n\n\t/**\n\t * Increment total transaction count\n\t */\n\tincrementTotal () {\n\t\tthis.stats.totalTransactions++;\n\t}\n\n\t/**\n\t * Increment committed transaction count\n\t */\n\tincrementCommitted () {\n\t\tthis.stats.committedTransactions++;\n\t}\n\n\t/**\n\t * Increment aborted transaction count\n\t */\n\tincrementAborted () {\n\t\tthis.stats.abortedTransactions++;\n\t}\n\n\t/**\n\t * Increment active transaction count\n\t */\n\tincrementActive () {\n\t\tthis.stats.activeTransactions++;\n\t}\n\n\t/**\n\t * Decrement active transaction count\n\t */\n\tdecrementActive () {\n\t\tthis.stats.activeTransactions--;\n\t}\n\n\t/**\n\t * Update duration statistics based on completed transaction\n\t * @param {Transaction} transaction - Completed transaction\n\t */\n\tupdateDurationStats (transaction) {\n\t\tconst duration = transaction.getDuration();\n\t\tif (duration !== null) {\n\t\t\tthis.stats.totalDuration += duration;\n\t\t\tconst completedTransactions = this.stats.committedTransactions + this.stats.abortedTransactions;\n\t\t\tthis.stats.averageDuration = this.stats.totalDuration / completedTransactions;\n\t\t}\n\t}\n\n\t/**\n\t * Get comprehensive statistics\n\t * @param {Object} lockStats - Lock manager statistics\n\t * @param {number} activeCount - Current active transaction count\n\t * @param {number} transactionCounter - Global transaction counter\n\t * @returns {Object} Complete statistics object\n\t */\n\tgetStats (lockStats, activeCount, transactionCounter) {\n\t\treturn {\n\t\t\t...this.stats,\n\t\t\tactiveTransactions: activeCount,\n\t\t\tlockStats,\n\t\t\ttransactionCounter\n\t\t};\n\t}\n\n\t/**\n\t * Reset all statistics to zero\n\t */\n\treset () {\n\t\tthis.stats = {\n\t\t\ttotalTransactions: 0,\n\t\t\tcommittedTransactions: 0,\n\t\t\tabortedTransactions: 0,\n\t\t\tactiveTransactions: 0,\n\t\t\taverageDuration: 0,\n\t\t\ttotalDuration: 0\n\t\t};\n\t}\n\n\t/**\n\t * Get raw statistics object (for internal use)\n\t * @returns {Object} Raw stats object\n\t */\n\tgetRawStats () {\n\t\treturn { ...this.stats };\n\t}\n}\n","/**\n * Analyzer for detecting relationships between transaction keys\n * Handles hierarchical, semantic, pattern, temporal, and functional relationships\n */\nexport class KeyRelationshipAnalyzer {\n\t/**\n\t * Creates a new KeyRelationshipAnalyzer instance\n\t * Initializes caches for pattern and semantic analysis\n\t */\n\tconstructor () {\n\t\t// Pattern cache for performance\n\t\tthis.patternCache = new Map();\n\t\tthis.semanticCache = new Map();\n\t}\n\n\t/**\n\t * Check if two keys are related through various relationship types\n\t * @param {string} key1 - First key\n\t * @param {string} key2 - Second key\n\t * @returns {boolean} True if keys are related\n\t */\n\tareKeysRelated (key1, key2) {\n\t\t// Direct match - always related\n\t\tif (key1 === key2) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for hierarchical relationships\n\t\tif (this._hasHierarchicalKeyRelationship(key1, key2)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for semantic relationships\n\t\tif (this._hasSemanticKeyRelationship(key1, key2)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for pattern-based relationships\n\t\tif (this._hasPatternBasedKeyRelationship(key1, key2)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for composite key relationships\n\t\tif (this._hasCompositeKeyRelationship(key1, key2)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for temporal relationships\n\t\tif (this._hasTemporalKeyRelationship(key1, key2)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for index-based relationships\n\t\tif (this._hasIndexKeyRelationship(key1, key2)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for collection relationships\n\t\tif (this._hasCollectionKeyRelationship(key1, key2)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for functional dependencies\n\t\tif (this._hasFunctionalDependency(key1, key2)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if a key falls within the range that could affect a snapshot\n\t * @param {Transaction} transaction - Transaction with snapshot\n\t * @param {string} operationKey - Key from other transaction's operation\n\t * @param {string} snapshotKey - Key from snapshot\n\t * @param {*} expectedValue - Expected value from snapshot\n\t * @returns {boolean} True if operation key could affect snapshot\n\t */\n\tisKeyInSnapshotRange (transaction, operationKey, snapshotKey, expectedValue) {\n\t\t// Direct key match - always affects snapshot\n\t\tif (operationKey === snapshotKey) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for explicit range metadata stored with the snapshot\n\t\tif (this._hasExplicitRangeMetadata(transaction, snapshotKey)) {\n\t\t\treturn this._checkExplicitRange(transaction, operationKey, snapshotKey);\n\t\t}\n\n\t\t// Infer range from snapshot key patterns\n\t\tif (this._isPatternBasedSnapshot(snapshotKey)) {\n\t\t\treturn this._checkPatternBasedRange(operationKey, snapshotKey);\n\t\t}\n\n\t\t// Check for hierarchical key relationships\n\t\tif (this._hasHierarchicalRelationship(operationKey, snapshotKey)) {\n\t\t\treturn this._checkHierarchicalRange(operationKey, snapshotKey, expectedValue);\n\t\t}\n\n\t\t// Check for index-based range queries\n\t\tif (this._isIndexBasedSnapshot(transaction, snapshotKey)) {\n\t\t\treturn this._checkIndexBasedRange(transaction, operationKey, snapshotKey);\n\t\t}\n\n\t\t// Check for semantic key relationships\n\t\tif (this._hasSemanticRelationship(operationKey, snapshotKey)) {\n\t\t\treturn this._checkSemanticRange(operationKey, snapshotKey);\n\t\t}\n\n\t\t// Check for temporal range relationships\n\t\tif (this._isTemporalSnapshot(snapshotKey)) {\n\t\t\treturn this._checkTemporalRange(operationKey, snapshotKey);\n\t\t}\n\n\t\t// Check for composite key range relationships\n\t\tif (this._isCompositeKeySnapshot(snapshotKey)) {\n\t\t\treturn this._checkCompositeKeyRange(operationKey, snapshotKey);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if a key matches a range specification\n\t * @param {string} key - Key to check\n\t * @param {Object} range - Range specification\n\t * @returns {boolean} True if key is in range\n\t */\n\tkeyMatchesRange (key, range) {\n\t\tif (range.min !== undefined && range.max !== undefined) {\n\t\t\treturn key >= range.min && key <= range.max;\n\t\t}\n\n\t\tif (range.prefix !== undefined) {\n\t\t\treturn key.startsWith(range.prefix);\n\t\t}\n\n\t\tif (range.pattern !== undefined) {\n\t\t\ttry {\n\t\t\t\tconst regex = new RegExp(range.pattern);\n\n\t\t\t\treturn regex.test(key);\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if key matches a query specification\n\t * @param {string} key - Key to check\n\t * @param {Object} queryInfo - Query specification\n\t * @returns {boolean} True if key matches query\n\t */\n\tkeyMatchesQuery (key, queryInfo) {\n\t\tif (queryInfo.type === \"range\") {\n\t\t\treturn this.keyMatchesRange(key, queryInfo);\n\t\t}\n\n\t\tif (queryInfo.type === \"prefix\") {\n\t\t\treturn key.startsWith(queryInfo.prefix || \"\");\n\t\t}\n\n\t\tif (queryInfo.type === \"pattern\") {\n\t\t\ttry {\n\t\t\t\tconst regex = new RegExp(queryInfo.pattern || \"\");\n\n\t\t\t\treturn regex.test(key);\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (queryInfo.type === \"in\") {\n\t\t\treturn Array.isArray(queryInfo.values) && queryInfo.values.includes(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if key matches an index range\n\t * @param {string} key - Key to check\n\t * @param {Object} indexRange - Index range specification\n\t * @returns {boolean} True if key matches index range\n\t */\n\tkeyMatchesIndexRange (key, indexRange) {\n\t\tif (indexRange.fields && Array.isArray(indexRange.fields)) {\n\t\t\tfor (const field of indexRange.fields) {\n\t\t\t\tif (key.includes(field)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (indexRange.values) {\n\t\t\treturn this.keyMatchesRange(key, indexRange.values);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if two keys have a hierarchical relationship\n\t * Analyzes parent-child, sibling, and ancestor-descendant relationships\n\t * @param {string} key1 - First key to compare\n\t * @param {string} key2 - Second key to compare\n\t * @returns {boolean} True if keys have hierarchical relationship\n\t * @private\n\t */\n\t_hasHierarchicalKeyRelationship (key1, key2) {\n\t\tconst separators = [\":\", \"/\", \".\", \"_\", \"-\"];\n\n\t\tfor (const sep of separators) {\n\t\t\tif (key1.includes(sep) && key2.includes(sep)) {\n\t\t\t\tconst parts1 = key1.split(sep);\n\t\t\t\tconst parts2 = key2.split(sep);\n\n\t\t\t\tif (this._isParentChildRelationship(parts1, parts2) ||\n\t\t\t\t\tthis._isSiblingRelationship(parts1, parts2) ||\n\t\t\t\t\tthis._isAncestorDescendantRelationship(parts1, parts2)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn key1.startsWith(key2) || key2.startsWith(key1);\n\t}\n\n\t/**\n\t * Check if operation key and snapshot key have hierarchical relationship for snapshot range\n\t * @param {string} operationKey - Key from operation\n\t * @param {string} snapshotKey - Key from snapshot\n\t * @returns {boolean} True if keys have hierarchical relationship\n\t * @private\n\t */\n\t_hasHierarchicalRelationship (operationKey, snapshotKey) {\n\t\tconst separators = [\":\", \"/\", \".\", \"_\", \"-\"];\n\n\t\tfor (const sep of separators) {\n\t\t\tif (operationKey.includes(sep) && snapshotKey.includes(sep)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if operation key falls within hierarchical range of snapshot key\n\t * @param {string} operationKey - Key from operation\n\t * @param {string} snapshotKey - Key from snapshot\n\t * @param {*} expectedValue - Expected value from snapshot\n\t * @returns {boolean} True if operation key is in hierarchical range\n\t * @private\n\t */\n\t_checkHierarchicalRange (operationKey, snapshotKey, expectedValue) {\n\t\tconst separators = [\":\", \"/\", \".\", \"_\", \"-\"];\n\n\t\tfor (const sep of separators) {\n\t\t\tif (operationKey.includes(sep) && snapshotKey.includes(sep)) {\n\t\t\t\tconst opParts = operationKey.split(sep);\n\t\t\t\tconst snapParts = snapshotKey.split(sep);\n\n\t\t\t\tif (this._isParentChildRelationship(opParts, snapParts) ||\n\t\t\t\t\tthis._isSiblingRelationship(opParts, snapParts) ||\n\t\t\t\t\tthis._isCollectionMembership(opParts, snapParts, expectedValue)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if two key parts arrays have a parent-child relationship\n\t * @param {string[]} opParts - Parts from operation key\n\t * @param {string[]} snapParts - Parts from snapshot key\n\t * @returns {boolean} True if there's a parent-child relationship\n\t * @private\n\t */\n\t_isParentChildRelationship (opParts, snapParts) {\n\t\tif (opParts.length > snapParts.length) {\n\t\t\tfor (let i = 0; i < snapParts.length; i++) {\n\t\t\t\tif (opParts[i] !== snapParts[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (snapParts.length > opParts.length) {\n\t\t\tfor (let i = 0; i < opParts.length; i++) {\n\t\t\t\tif (opParts[i] !== snapParts[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if two key parts arrays have a sibling relationship\n\t * @param {string[]} opParts - Parts from operation key\n\t * @param {string[]} snapParts - Parts from snapshot key\n\t * @returns {boolean} True if there's a sibling relationship\n\t * @private\n\t */\n\t_isSiblingRelationship (opParts, snapParts) {\n\t\tif (opParts.length === snapParts.length && opParts.length > 1) {\n\t\t\tfor (let i = 0; i < opParts.length - 1; i++) {\n\t\t\t\tif (opParts[i] !== snapParts[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn opParts[opParts.length - 1] !== snapParts[snapParts.length - 1];\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if two key parts arrays have an ancestor-descendant relationship\n\t * @param {string[]} parts1 - Parts from first key\n\t * @param {string[]} parts2 - Parts from second key\n\t * @returns {boolean} True if there's an ancestor-descendant relationship\n\t * @private\n\t */\n\t_isAncestorDescendantRelationship (parts1, parts2) {\n\t\tconst shorter = parts1.length < parts2.length ? parts1 : parts2;\n\t\tconst longer = parts1.length < parts2.length ? parts2 : parts1;\n\n\t\tif (shorter.length < longer.length) {\n\t\t\tfor (let i = 0; i < shorter.length; i++) {\n\t\t\t\tif (shorter[i] !== longer[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if operation key parts indicate collection membership relative to snapshot\n\t * @param {string[]} opParts - Parts from operation key\n\t * @param {string[]} snapParts - Parts from snapshot key\n\t * @param {*} expectedValue - Expected value from snapshot\n\t * @returns {boolean} True if operation key is collection member\n\t * @private\n\t */\n\t_isCollectionMembership (opParts, snapParts, expectedValue) {\n\t\tif (Array.isArray(expectedValue) ||\n\t\t\texpectedValue && typeof expectedValue === \"object\" && expectedValue.length !== undefined) {\n\t\t\treturn this._isParentChildRelationship(opParts, snapParts) ||\n\t\t\t\tthis._isSiblingRelationship(opParts, snapParts);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if two keys have semantic relationship based on their content meaning\n\t * @param {string} key1 - First key to compare\n\t * @param {string} key2 - Second key to compare\n\t * @returns {boolean} True if keys have semantic relationship\n\t * @private\n\t */\n\t_hasSemanticKeyRelationship (key1, key2) {\n\t\tconst semantics1 = this._extractSemanticIdentifiers(key1);\n\t\tconst semantics2 = this._extractSemanticIdentifiers(key2);\n\n\t\tfor (const sem1 of semantics1) {\n\t\t\tfor (const sem2 of semantics2) {\n\t\t\t\tif (this._areSemanticallySimilar(sem1, sem2)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._hasEntityRelationship(semantics1, semantics2);\n\t}\n\n\t/**\n\t * Check if operation key and snapshot key have semantic relationship for snapshot range\n\t * @param {string} operationKey - Key from operation\n\t * @param {string} snapshotKey - Key from snapshot\n\t * @returns {boolean} True if keys have semantic relationship\n\t * @private\n\t */\n\t_hasSemanticRelationship (operationKey, snapshotKey) {\n\t\tconst semanticPrefixes = [\n\t\t\t\"user\", \"account\", \"profile\", \"session\",\n\t\t\t\"order\", \"product\", \"cart\", \"payment\",\n\t\t\t\"post\", \"comment\", \"thread\", \"message\",\n\t\t\t\"document\", \"file\", \"folder\", \"workspace\"\n\t\t];\n\n\t\tfor (const prefix of semanticPrefixes) {\n\t\t\tif (operationKey.toLowerCase().includes(prefix) &&\n\t\t\t\tsnapshotKey.toLowerCase().includes(prefix)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if operation key falls within semantic range of snapshot key\n\t * @param {string} operationKey - Key from operation\n\t * @param {string} snapshotKey - Key from snapshot\n\t * @returns {boolean} True if operation key is in semantic range\n\t * @private\n\t */\n\t_checkSemanticRange (operationKey, snapshotKey) {\n\t\tconst opSemantics = this._extractSemanticIdentifiers(operationKey);\n\t\tconst snapSemantics = this._extractSemanticIdentifiers(snapshotKey);\n\n\t\tfor (const opSemantic of opSemantics) {\n\t\t\tfor (const snapSemantic of snapSemantics) {\n\t\t\t\tif (this._areSemanticallySimilar(opSemantic, snapSemantic)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Extract semantic identifiers from a key string using pattern matching\n\t * @param {string} key - Key to extract semantic identifiers from\n\t * @returns {string[]} Array of semantic identifiers found in the key\n\t * @private\n\t */\n\t_extractSemanticIdentifiers (key) {\n\t\tconst cacheKey = `semantic:${key}`;\n\t\tif (this.semanticCache.has(cacheKey)) {\n\t\t\treturn this.semanticCache.get(cacheKey);\n\t\t}\n\n\t\tconst identifiers = [];\n\t\tconst patterns = [\n\t\t\t/(\\w+):(\\w+)/g, // entity:id\n\t\t\t/(\\w+)_(\\w+)/g, // entity_id\n\t\t\t/([a-z]+)([A-Z]\\w+)/g // entityId (camelCase)\n\t\t];\n\n\t\tfor (const pattern of patterns) {\n\t\t\tlet match;\n\t\t\twhile ((match = pattern.exec(key)) !== null) {\n\t\t\t\tidentifiers.push(match[1].toLowerCase());\n\t\t\t\tif (match[2]) {\n\t\t\t\t\tidentifiers.push(match[2].toLowerCase());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.semanticCache.set(cacheKey, identifiers);\n\n\t\treturn identifiers;\n\t}\n\n\t/**\n\t * Check if two semantic identifiers are similar\n\t * Handles singular/plural forms and semantic equivalence\n\t * @param {string} id1 - First identifier\n\t * @param {string} id2 - Second identifier\n\t * @returns {boolean} True if identifiers are semantically similar\n\t * @private\n\t */\n\t_areSemanticallySimilar (id1, id2) {\n\t\tif (id1 === id2) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst singularPlural = [\n\t\t\t[\"user\", \"users\"], [\"account\", \"accounts\"], [\"profile\", \"profiles\"],\n\t\t\t[\"order\", \"orders\"], [\"product\", \"products\"], [\"item\", \"items\"],\n\t\t\t[\"post\", \"posts\"], [\"comment\", \"comments\"], [\"message\", \"messages\"],\n\t\t\t[\"file\", \"files\"], [\"document\", \"documents\"], [\"folder\", \"folders\"]\n\t\t];\n\n\t\tfor (const [singular, plural] of singularPlural) {\n\t\t\tif (id1 === singular && id2 === plural ||\n\t\t\t\tid1 === plural && id2 === singular) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if two semantic identifier arrays have entity relationships\n\t * @param {string[]} semantics1 - Semantic identifiers from first key\n\t * @param {string[]} semantics2 - Semantic identifiers from second key\n\t * @returns {boolean} True if entities have defined relationships\n\t * @private\n\t */\n\t_hasEntityRelationship (semantics1, semantics2) {\n\t\tconst entityRelations = [\n\t\t\t[\"user\", \"profile\"], [\"user\", \"account\"], [\"user\", \"session\"],\n\t\t\t[\"profile\", \"account\"], [\"account\", \"session\"],\n\t\t\t[\"user\", \"order\"], [\"user\", \"cart\"], [\"user\", \"payment\"],\n\t\t\t[\"order\", \"product\"], [\"order\", \"payment\"], [\"cart\", \"product\"],\n\t\t\t[\"user\", \"post\"], [\"user\", \"comment\"], [\"user\", \"message\"],\n\t\t\t[\"post\", \"comment\"], [\"thread\", \"message\"], [\"document\", \"file\"],\n\t\t\t[\"user\", \"workspace\"], [\"workspace\", \"document\"], [\"workspace\", \"folder\"],\n\t\t\t[\"folder\", \"file\"], [\"document\", \"file\"]\n\t\t];\n\n\t\tfor (const [entity1, entity2] of entityRelations) {\n\t\t\tconst hasEntity1InBoth = semantics1.includes(entity1) && semantics2.includes(entity2);\n\t\t\tconst hasEntity2InBoth = semantics1.includes(entity2) && semantics2.includes(entity1);\n\n\t\t\tif (hasEntity1InBoth || hasEntity2InBoth) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if two keys have pattern-based relationship\n\t * @param {string} key1 - First key to compare\n\t * @param {string} key2 - Second key to compare\n\t * @returns {boolean} True if keys have pattern-based relationship\n\t * @private\n\t */\n\t_hasPatternBasedKeyRelationship (key1, key2) {\n\t\tif (this._isPatternBasedSnapshot(key1)) {\n\t\t\treturn this._checkPatternBasedRange(key2, key1);\n\t\t}\n\n\t\tif (this._isPatternBasedSnapshot(key2)) {\n\t\t\treturn this._checkPatternBasedRange(key1, key2);\n\t\t}\n\n\t\treturn this._haveSimilarPatterns(key1, key2);\n\t}\n\n\t/**\n\t * Check if a snapshot key contains pattern-based wildcards or indicators\n\t * @param {string} snapshotKey - Key from snapshot to check\n\t * @returns {boolean} True if key contains pattern-based elements\n\t * @private\n\t */\n\t_isPatternBasedSnapshot (snapshotKey) {\n\t\treturn snapshotKey.includes(\"*\") ||\n\t\t\tsnapshotKey.includes(\"?\") ||\n\t\t\tsnapshotKey.includes(\"[\") ||\n\t\t\tsnapshotKey.includes(\"{\") ||\n\t\t\tsnapshotKey.endsWith(\"_range\") ||\n\t\t\tsnapshotKey.endsWith(\"_pattern\");\n\t}\n\n\t/**\n\t * Check if operation key matches a pattern-based snapshot key range\n\t * @param {string} operationKey - Key from operation\n\t * @param {string} snapshotKey - Pattern-based snapshot key\n\t * @returns {boolean} True if operation key matches pattern\n\t * @private\n\t */\n\t_checkPatternBasedRange (operationKey, snapshotKey) {\n\t\tif (snapshotKey.includes(\"*\")) {\n\t\t\tconst pattern = snapshotKey.replace(/\\*/g, \".*\");\n\t\t\ttry {\n\t\t\t\tconst regex = new RegExp(`^${pattern}$`);\n\n\t\t\t\treturn regex.test(operationKey);\n\t\t\t} catch {\n\t\t\t\tconst prefix = snapshotKey.split(\"*\")[0];\n\n\t\t\t\treturn operationKey.startsWith(prefix);\n\t\t\t}\n\t\t}\n\n\t\tif (snapshotKey.includes(\"?\")) {\n\t\t\tconst pattern = snapshotKey.replace(/\\?/g, \".\");\n\t\t\ttry {\n\t\t\t\tconst regex = new RegExp(`^${pattern}$`);\n\n\t\t\t\treturn regex.test(operationKey);\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (snapshotKey.includes(\"[\")) {\n\t\t\ttry {\n\t\t\t\tconst regex = new RegExp(`^${snapshotKey}$`);\n\n\t\t\t\treturn regex.test(operationKey);\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (snapshotKey.includes(\"{\") && snapshotKey.includes(\"}\")) {\n\t\t\tconst beforeBrace = snapshotKey.substring(0, snapshotKey.indexOf(\"{\"));\n\t\t\tconst afterBrace = snapshotKey.substring(snapshotKey.indexOf(\"}\") + 1);\n\t\t\tconst choices = snapshotKey.substring(\n\t\t\t\tsnapshotKey.indexOf(\"{\") + 1,\n\t\t\t\tsnapshotKey.indexOf(\"}\")\n\t\t\t).split(\",\");\n\n\t\t\tfor (const choice of choices) {\n\t\t\t\tconst fullPattern = beforeBrace + choice.trim() + afterBrace;\n\t\t\t\tif (operationKey === fullPattern || operationKey.startsWith(fullPattern)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (snapshotKey.endsWith(\"_range\") || snapshotKey.endsWith(\"_pattern\")) {\n\t\t\tconst baseKey = snapshotKey.replace(/_range$|_pattern$/, \"\");\n\n\t\t\treturn operationKey.startsWith(baseKey);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if two keys have similar structural patterns\n\t * @param {string} key1 - First key to compare\n\t * @param {string} key2 - Second key to compare\n\t * @returns {boolean} True if keys have similar patterns\n\t * @private\n\t */\n\t_haveSimilarPatterns (key1, key2) {\n\t\tconst pattern1 = this._extractKeyPattern(key1);\n\t\tconst pattern2 = this._extractKeyPattern(key2);\n\n\t\treturn this._patternsAreSimilar(pattern1, pattern2);\n\t}\n\n\t/**\n\t * Extract structural pattern from a key by normalizing variable components\n\t * @param {string} key - Key to extract pattern from\n\t * @returns {string} Normalized pattern string\n\t * @private\n\t */\n\t_extractKeyPattern (key) {\n\t\tconst cacheKey = `pattern:${key}`;\n\t\tif (this.patternCache.has(cacheKey)) {\n\t\t\treturn this.patternCache.get(cacheKey);\n\t\t}\n\n\t\tconst pattern = key\n\t\t\t.replace(/\\d+/g, \"#\") // Numbers become #\n\t\t\t.replace(/[a-f0-9]{8,}/g, \"&\") // Hashes/UUIDs become &\n\t\t\t.replace(/\\w{1,3}(?=:|_|-)/g, \"@\"); // Short prefixes become @\n\n\t\tthis.patternCache.set(cacheKey, pattern);\n\n\t\treturn pattern;\n\t}\n\n\t/**\n\t * Check if two patterns are similar based on similarity threshold\n\t * @param {string} pattern1 - First pattern to compare\n\t * @param {string} pattern2 - Second pattern to compare\n\t * @returns {boolean} True if patterns are similar (>70% similarity)\n\t * @private\n\t */\n\t_patternsAreSimilar (pattern1, pattern2) {\n\t\tif (pattern1 === pattern2) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst similarity = this._calculatePatternSimilarity(pattern1, pattern2);\n\n\t\treturn similarity > 0.7;\n\t}\n\n\t/**\n\t * Calculate similarity score between two patterns using Levenshtein distance\n\t * @param {string} pattern1 - First pattern\n\t * @param {string} pattern2 - Second pattern\n\t * @returns {number} Similarity score between 0 and 1\n\t * @private\n\t */\n\t_calculatePatternSimilarity (pattern1, pattern2) {\n\t\tconst len1 = pattern1.length;\n\t\tconst len2 = pattern2.length;\n\t\tconst maxLen = Math.max(len1, len2);\n\n\t\tif (maxLen === 0) return 1;\n\n\t\tconst distance = this._levenshteinDistance(pattern1, pattern2);\n\n\t\treturn 1 - distance / maxLen;\n\t}\n\n\t/**\n\t * Calculate Levenshtein distance between two strings\n\t * @param {string} str1 - First string\n\t * @param {string} str2 - Second string\n\t * @returns {number} Edit distance between strings\n\t * @private\n\t */\n\t_levenshteinDistance (str1, str2) {\n\t\tconst matrix = [];\n\n\t\tfor (let i = 0; i <= str2.length; i++) {\n\t\t\tmatrix[i] = [i];\n\t\t}\n\n\t\tfor (let j = 0; j <= str1.length; j++) {\n\t\t\tmatrix[0][j] = j;\n\t\t}\n\n\t\tfor (let i = 1; i <= str2.length; i++) {\n\t\t\tfor (let j = 1; j <= str1.length; j++) {\n\t\t\t\tif (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n\t\t\t\t\tmatrix[i][j] = matrix[i - 1][j - 1];\n\t\t\t\t} else {\n\t\t\t\t\tmatrix[i][j] = Math.min(\n\t\t\t\t\t\tmatrix[i - 1][j - 1] + 1, // substitution\n\t\t\t\t\t\tmatrix[i][j - 1] + 1, // insertion\n\t\t\t\t\t\tmatrix[i - 1][j] + 1 // deletion\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn matrix[str2.length][str1.length];\n\t}\n\n\t/**\n\t * Check if two keys have temporal relationship based on time-related components\n\t * @param {string} key1 - First key to compare\n\t * @param {string} key2 - Second key to compare\n\t * @returns {boolean} True if keys have temporal relationship\n\t * @private\n\t */\n\t_hasTemporalKeyRelationship (key1, key2) {\n\t\tif (this._isTemporalSnapshot(key1) && this._isTemporalSnapshot(key2)) {\n\t\t\tconst temporal1 = this._extractTemporalComponents(key1);\n\t\t\tconst temporal2 = this._extractTemporalComponents(key2);\n\n\t\t\treturn this._haveTemporalOverlap(temporal1, temporal2);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if a snapshot key contains temporal/time-related keywords\n\t * @param {string} snapshotKey - Key from snapshot to check\n\t * @returns {boolean} True if key contains temporal indicators\n\t * @private\n\t */\n\t_isTemporalSnapshot (snapshotKey) {\n\t\tconst temporalKeywords = [\n\t\t\t\"timestamp\", \"time\", \"date\", \"created\", \"updated\", \"modified\",\n\t\t\t\"datetime\", \"ts\", \"epoch\", \"iso\", \"utc\", \"log\", \"event\", \"history\"\n\t\t];\n\n\t\treturn temporalKeywords.some(keyword =>\n\t\t\tsnapshotKey.toLowerCase().includes(keyword)\n\t\t);\n\t}\n\n\t/**\n\t * Check if operation key falls within temporal range of snapshot key\n\t * @param {string} operationKey - Key from operation\n\t * @param {string} snapshotKey - Temporal snapshot key\n\t * @returns {boolean} True if operation key is in temporal range\n\t * @private\n\t */\n\t_checkTemporalRange (operationKey, snapshotKey) {\n\t\tif (this._isTemporalSnapshot(operationKey)) {\n\t\t\tconst opTemporal = this._extractTemporalComponents(operationKey);\n\t\t\tconst snapTemporal = this._extractTemporalComponents(snapshotKey);\n\n\t\t\treturn this._haveTemporalOverlap(opTemporal, snapTemporal);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Extract temporal components from a key using regex patterns\n\t * @param {string} key - Key to extract temporal components from\n\t * @returns {Object} Object with temporal component flags\n\t * @private\n\t */\n\t_extractTemporalComponents (key) {\n\t\tconst components = {\n\t\t\thasDate: false,\n\t\t\thasTime: false,\n\t\t\thasTimestamp: false,\n\t\t\thasEpoch: false\n\t\t};\n\n\t\tif ((/\\d{4}-\\d{2}-\\d{2}/).test(key)) components.hasDate = true;\n\t\tif ((/\\d{2}:\\d{2}:\\d{2}/).test(key)) components.hasTime = true;\n\t\tif ((/\\d{13}/).test(key)) components.hasTimestamp = true;\n\t\tif ((/\\d{10}/).test(key)) components.hasEpoch = true;\n\n\t\treturn components;\n\t}\n\n\t/**\n\t * Check if two temporal component objects have overlapping temporal elements\n\t * @param {Object} opTemporal - Temporal components from operation key\n\t * @param {Object} snapTemporal - Temporal components from snapshot key\n\t * @returns {boolean} True if temporal components overlap\n\t * @private\n\t */\n\t_haveTemporalOverlap (opTemporal, snapTemporal) {\n\t\treturn opTemporal.hasDate && snapTemporal.hasDate ||\n\t\t\topTemporal.hasTime && snapTemporal.hasTime ||\n\t\t\topTemporal.hasTimestamp && snapTemporal.hasTimestamp ||\n\t\t\topTemporal.hasEpoch && snapTemporal.hasEpoch;\n\t}\n\n\t/**\n\t * Check if two keys have composite key relationship\n\t * @param {string} key1 - First key to compare\n\t * @param {string} key2 - Second key to compare\n\t * @returns {boolean} True if keys have composite key relationship\n\t * @private\n\t */\n\t_hasCompositeKeyRelationship (key1, key2) {\n\t\treturn this._checkCompositeKeyRange(key1, key2) ||\n\t\t\tthis._checkCompositeKeyRange(key2, key1);\n\t}\n\n\t/**\n\t * Check if a snapshot key represents a composite key structure\n\t * @param {string} snapshotKey - Key from snapshot to check\n\t * @returns {boolean} True if key is composite key structure\n\t * @private\n\t */\n\t_isCompositeKeySnapshot (snapshotKey) {\n\t\treturn snapshotKey.includes(\":\") ||\n\t\t\tsnapshotKey.includes(\"#\") ||\n\t\t\tsnapshotKey.includes(\"|\") ||\n\t\t\tsnapshotKey.includes(\"@\") ||\n\t\t\tsnapshotKey.split(\"_\").length > 2 ||\n\t\t\tsnapshotKey.split(\"-\").length > 2;\n\t}\n\n\t/**\n\t * Check if operation key falls within composite key range of snapshot key\n\t * @param {string} operationKey - Key from operation\n\t * @param {string} snapshotKey - Composite snapshot key\n\t * @returns {boolean} True if operation key is in composite key range\n\t * @private\n\t */\n\t_checkCompositeKeyRange (operationKey, snapshotKey) {\n\t\tconst separators = [\":\", \"#\", \"|\", \"@\", \"_\", \"-\"];\n\n\t\tfor (const sep of separators) {\n\t\t\tif (operationKey.includes(sep) && snapshotKey.includes(sep)) {\n\t\t\t\tconst opParts = operationKey.split(sep);\n\t\t\t\tconst snapParts = snapshotKey.split(sep);\n\n\t\t\t\tif (this._hasCompositeKeyOverlap(opParts, snapParts)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if operation key parts overlap with snapshot key parts in composite key\n\t * @param {string[]} opParts - Parts from operation key\n\t * @param {string[]} snapParts - Parts from snapshot key\n\t * @returns {boolean} True if key parts have composite overlap\n\t * @private\n\t */\n\t_hasCompositeKeyOverlap (opParts, snapParts) {\n\t\tconst minLength = Math.min(opParts.length, snapParts.length);\n\n\t\tfor (let i = 1; i <= minLength; i++) {\n\t\t\tlet allMatch = true;\n\t\t\tfor (let j = 0; j < i; j++) {\n\t\t\t\tif (opParts[j] !== snapParts[j]) {\n\t\t\t\t\tallMatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (allMatch) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if two keys have index-based relationship\n\t * @param {string} key1 - First key to compare\n\t * @param {string} key2 - Second key to compare\n\t * @returns {boolean} True if keys have index relationship\n\t * @private\n\t */\n\t_hasIndexKeyRelationship (key1, key2) {\n\t\tconst isIndex1 = this._isIndexKey(key1);\n\t\tconst isIndex2 = this._isIndexKey(key2);\n\n\t\tif (isIndex1 || isIndex2) {\n\t\t\tconst base1 = this._extractBaseKeyFromIndex(key1);\n\t\t\tconst base2 = this._extractBaseKeyFromIndex(key2);\n\n\t\t\treturn base1 === base2 ||\n\t\t\t\tkey1.startsWith(base2) ||\n\t\t\t\tkey2.startsWith(base1) ||\n\t\t\t\tbase1.startsWith(base2) ||\n\t\t\t\tbase2.startsWith(base1);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if a key represents an index key structure\n\t * @param {string} key - Key to check\n\t * @returns {boolean} True if key is an index key\n\t * @private\n\t */\n\t_isIndexKey (key) {\n\t\treturn key.includes(\"_index\") ||\n\t\t\tkey.includes(\"_idx\") ||\n\t\t\tkey.startsWith(\"idx_\") ||\n\t\t\tkey.includes(\"_key\") ||\n\t\t\tkey.includes(\"_lookup\");\n\t}\n\n\t/**\n\t * Extract base key from an index key by removing index-specific suffixes\n\t * @param {string} indexKey - Index key to extract base from\n\t * @returns {string} Base key without index identifiers\n\t * @private\n\t */\n\t_extractBaseKeyFromIndex (indexKey) {\n\t\treturn indexKey\n\t\t\t.replace(/_index.*$/, \"\")\n\t\t\t.replace(/_idx.*$/, \"\")\n\t\t\t.replace(/^idx_/, \"\")\n\t\t\t.replace(/_key.*$/, \"\")\n\t\t\t.replace(/_lookup.*$/, \"\");\n\t}\n\n\t/**\n\t * Check if a snapshot key represents an index-based query\n\t * @param {Transaction} transaction - Transaction containing snapshot\n\t * @param {string} snapshotKey - Key from snapshot to check\n\t * @returns {boolean} True if snapshot is index-based\n\t * @private\n\t */\n\t_isIndexBasedSnapshot (transaction, snapshotKey) {\n\t\treturn snapshotKey.includes(\"_index\") ||\n\t\t\tsnapshotKey.includes(\"_idx\") ||\n\t\t\tsnapshotKey.startsWith(\"idx_\") ||\n\t\t\ttransaction.snapshot.has(`${snapshotKey}:index_range`);\n\t}\n\n\t/**\n\t * Check if operation key falls within index-based range of snapshot key\n\t * @param {Transaction} transaction - Transaction containing snapshot\n\t * @param {string} operationKey - Key from operation\n\t * @param {string} snapshotKey - Index-based snapshot key\n\t * @returns {boolean} True if operation key is in index range\n\t * @private\n\t */\n\t_checkIndexBasedRange (transaction, operationKey, snapshotKey) {\n\t\tconst indexRange = transaction.snapshot.get(`${snapshotKey}:index_range`);\n\t\tif (indexRange) {\n\t\t\treturn this.keyMatchesIndexRange(operationKey, indexRange);\n\t\t}\n\n\t\tif (snapshotKey.includes(\"_index\") || snapshotKey.includes(\"_idx\")) {\n\t\t\tconst baseKey = snapshotKey.replace(/_index.*$|_idx.*$/, \"\");\n\n\t\t\treturn operationKey.startsWith(baseKey);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if two keys have collection-based relationship\n\t * @param {string} key1 - First key to compare\n\t * @param {string} key2 - Second key to compare\n\t * @returns {boolean} True if keys have collection relationship\n\t * @private\n\t */\n\t_hasCollectionKeyRelationship (key1, key2) {\n\t\tconst isCollection1 = this._isCollectionKey(key1);\n\t\tconst isCollection2 = this._isCollectionKey(key2);\n\n\t\tif (isCollection1 || isCollection2) {\n\t\t\tconst base1 = this._extractCollectionBase(key1);\n\t\t\tconst base2 = this._extractCollectionBase(key2);\n\n\t\t\treturn base1 === base2 ||\n\t\t\t\tkey1.startsWith(base2) ||\n\t\t\t\tkey2.startsWith(base1);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if a key represents a collection structure\n\t * @param {string} key - Key to check\n\t * @returns {boolean} True if key is a collection key\n\t * @private\n\t */\n\t_isCollectionKey (key) {\n\t\tconst collectionIndicators = [\n\t\t\t\"_list\", \"_array\", \"_set\", \"_collection\",\n\t\t\t\"_items\", \"_elements\", \"_members\", \"_entries\"\n\t\t];\n\n\t\treturn collectionIndicators.some(indicator => key.includes(indicator));\n\t}\n\n\t/**\n\t * Extract base key from a collection key by removing collection-specific suffixes\n\t * @param {string} collectionKey - Collection key to extract base from\n\t * @returns {string} Base key without collection identifiers\n\t * @private\n\t */\n\t_extractCollectionBase (collectionKey) {\n\t\tconst indicators = [\"_list\", \"_array\", \"_set\", \"_collection\", \"_items\", \"_elements\", \"_members\", \"_entries\"];\n\n\t\tfor (const indicator of indicators) {\n\t\t\tif (collectionKey.includes(indicator)) {\n\t\t\t\treturn collectionKey.replace(indicator, \"\");\n\t\t\t}\n\t\t}\n\n\t\treturn collectionKey;\n\t}\n\n\t/**\n\t * Check if two keys have functional dependency relationship\n\t * @param {string} key1 - First key to compare\n\t * @param {string} key2 - Second key to compare\n\t * @returns {boolean} True if keys have functional dependency\n\t * @private\n\t */\n\t_hasFunctionalDependency (key1, key2) {\n\t\tconst dependencies = [\n\t\t\t[\"user_id\", \"user_email\"], [\"user_id\", \"user_profile\"],\n\t\t\t[\"account_id\", \"user_id\"], [\"session_id\", \"user_id\"],\n\t\t\t[\"order_id\", \"user_id\"], [\"order_id\", \"order_total\"],\n\t\t\t[\"payment_id\", \"order_id\"], [\"shipping_id\", \"order_id\"],\n\t\t\t[\"post_id\", \"user_id\"], [\"comment_id\", \"post_id\"],\n\t\t\t[\"message_id\", \"thread_id\"], [\"file_id\", \"folder_id\"],\n\t\t\t[\"document_id\", \"workspace_id\"], [\"task_id\", \"project_id\"]\n\t\t];\n\n\t\tconst norm1 = this._normalizeKeyForDependency(key1);\n\t\tconst norm2 = this._normalizeKeyForDependency(key2);\n\n\t\tfor (const [dep1, dep2] of dependencies) {\n\t\t\tif (norm1.includes(dep1) && norm2.includes(dep2) ||\n\t\t\t\tnorm1.includes(dep2) && norm2.includes(dep1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Normalize a key for functional dependency comparison by converting to standard format\n\t * @param {string} key - Key to normalize\n\t * @returns {string} Normalized key in lowercase with underscores\n\t * @private\n\t */\n\t_normalizeKeyForDependency (key) {\n\t\treturn key.toLowerCase()\n\t\t\t.replace(/[:\\-/.]/g, \"_\")\n\t\t\t.replace(/([a-z])([A-Z])/g, \"$1_$2\")\n\t\t\t.toLowerCase();\n\t}\n\n\t/**\n\t * Check if transaction snapshot has explicit range metadata for a key\n\t * @param {Transaction} transaction - Transaction containing snapshot\n\t * @param {string} snapshotKey - Key from snapshot to check\n\t * @returns {boolean} True if explicit range metadata exists\n\t * @private\n\t */\n\t_hasExplicitRangeMetadata (transaction, snapshotKey) {\n\t\treturn transaction.snapshot.has(`${snapshotKey}:range`) ||\n\t\t\ttransaction.snapshot.has(`${snapshotKey}:query`) ||\n\t\t\ttransaction.snapshot.has(`${snapshotKey}:predicate`);\n\t}\n\n\t/**\n\t * Check if operation key matches explicit range metadata for snapshot key\n\t * @param {Transaction} transaction - Transaction containing snapshot\n\t * @param {string} operationKey - Key from operation\n\t * @param {string} snapshotKey - Key from snapshot with explicit range\n\t * @returns {boolean} True if operation key matches explicit range\n\t * @private\n\t */\n\t_checkExplicitRange (transaction, operationKey, snapshotKey) {\n\t\tconst rangeInfo = transaction.snapshot.get(`${snapshotKey}:range`);\n\t\tif (rangeInfo && typeof rangeInfo === \"object\") {\n\t\t\treturn this.keyMatchesRange(operationKey, rangeInfo);\n\t\t}\n\n\t\tconst queryInfo = transaction.snapshot.get(`${snapshotKey}:query`);\n\t\tif (queryInfo) {\n\t\t\treturn this.keyMatchesQuery(operationKey, queryInfo);\n\t\t}\n\n\t\tconst predicateInfo = transaction.snapshot.get(`${snapshotKey}:predicate`);\n\t\tif (predicateInfo && typeof predicateInfo === \"function\") {\n\t\t\ttry {\n\t\t\t\treturn predicateInfo(operationKey);\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Clear internal caches\n\t */\n\tclearCaches () {\n\t\tthis.patternCache.clear();\n\t\tthis.semanticCache.clear();\n\t}\n}\n","import { IsolationLevels } from \"./constants.js\";\nimport { KeyRelationshipAnalyzer } from \"./key-relationship-analyzer.js\";\n\n/**\n * Deadlock detector using multiple detection strategies\n */\nexport class DeadlockDetector {\n\tconstructor (lockManager) {\n\t\tthis.lockManager = lockManager;\n\t\tthis.keyAnalyzer = new KeyRelationshipAnalyzer();\n\t}\n\n\t/**\n\t * Check for deadlocks using multiple detection strategies\n\t * @param {Transaction[]} activeTransactions - Active transactions\n\t * @param {Object} [options={}] - Detection options\n\t * @returns {Object} Deadlock detection results\n\t */\n\tdetectDeadlocks (activeTransactions, options = {}) {\n\t\tconst opts = {\n\t\t\tuseLockGraph: true,\n\t\t\tuseResourceGraph: true,\n\t\t\tuseTimeoutDetection: true,\n\t\t\ttimeoutThreshold: 10000,\n\t\t\t...options\n\t\t};\n\n\t\tconst results = {\n\t\t\tdeadlocks: [],\n\t\t\tsuspectedDeadlocks: [],\n\t\t\ttimeoutVictims: [],\n\t\t\twaitForGraph: null,\n\t\t\tresourceGraph: null\n\t\t};\n\n\t\tif (activeTransactions.length < 2) {\n\t\t\treturn results;\n\t\t}\n\n\t\t// 1. Lock-based wait-for graph deadlock detection\n\t\tif (opts.useLockGraph) {\n\t\t\tconst lockDeadlocks = this._detectLockBasedDeadlocks(activeTransactions);\n\t\t\tresults.deadlocks.push(...lockDeadlocks.cycles);\n\t\t\tresults.waitForGraph = lockDeadlocks.graph;\n\t\t}\n\n\t\t// 2. Resource allocation graph deadlock detection\n\t\tif (opts.useResourceGraph) {\n\t\t\tconst resourceDeadlocks = this._detectResourceDeadlocks(activeTransactions);\n\t\t\tresults.deadlocks.push(...resourceDeadlocks.cycles);\n\t\t\tresults.resourceGraph = resourceDeadlocks.graph;\n\t\t}\n\n\t\t// 3. Isolation-level based deadlock detection\n\t\tconst isolationDeadlocks = this._detectIsolationDeadlocks(activeTransactions);\n\t\tresults.suspectedDeadlocks.push(...isolationDeadlocks);\n\n\t\t// 4. Timeout-based deadlock detection (fallback)\n\t\tif (opts.useTimeoutDetection) {\n\t\t\tconst timeoutVictims = this._detectTimeoutVictims(activeTransactions, opts.timeoutThreshold);\n\t\t\tresults.timeoutVictims.push(...timeoutVictims);\n\t\t}\n\n\t\t// Remove duplicates and merge results\n\t\tresults.deadlocks = this._deduplicateDeadlocks(results.deadlocks);\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Detect deadlocks using lock-based wait-for graph\n\t * @param {Transaction[]} activeTransactions - Active transactions\n\t * @returns {Object} Lock-based deadlock detection results\n\t * @private\n\t */\n\t_detectLockBasedDeadlocks (activeTransactions) {\n\t\tconst waitForGraph = this._buildLockWaitForGraph(activeTransactions);\n\t\tconst cycles = this._detectCyclesInGraph(waitForGraph);\n\n\t\treturn {\n\t\t\tgraph: waitForGraph,\n\t\t\tcycles: cycles.map(cycle => ({\n\t\t\t\ttype: \"lock\",\n\t\t\t\ttransactions: cycle,\n\t\t\t\tresources: this._getResourcesInvolvedInCycle(cycle, activeTransactions)\n\t\t\t}))\n\t\t};\n\t}\n\n\t/**\n\t * Build wait-for graph based on lock dependencies\n\t * @param {Transaction[]} transactions - Active transactions\n\t * @returns {Map<string, Set<string>>} Wait-for graph\n\t * @private\n\t */\n\t_buildLockWaitForGraph (transactions) {\n\t\tconst graph = new Map();\n\t\tconst lockStats = this.lockManager.getStats();\n\n\t\t// Initialize graph nodes\n\t\tfor (const tx of transactions) {\n\t\t\tgraph.set(tx.id, new Set());\n\t\t}\n\n\t\t// Build edges based on lock conflicts\n\t\tfor (const lockInfo of lockStats.recordsLocked) {\n\t\t\tconst { recordKey, holders } = lockInfo;\n\n\t\t\t// Find transactions waiting for this lock\n\t\t\tconst waitingTransactions = this._findTransactionsWaitingForLock(recordKey, transactions);\n\n\t\t\t// Create edges from waiting transactions to lock holders\n\t\t\tfor (const waitingTx of waitingTransactions) {\n\t\t\t\tfor (const holderId of holders) {\n\t\t\t\t\tif (waitingTx !== holderId && graph.has(waitingTx) && graph.has(holderId)) {\n\t\t\t\t\t\tgraph.get(waitingTx).add(holderId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn graph;\n\t}\n\n\t/**\n\t * Find transactions that are waiting for a specific lock\n\t * @param {string} recordKey - Record key\n\t * @param {Transaction[]} transactions - All transactions to check\n\t * @returns {string[]} Transaction IDs waiting for the lock\n\t * @private\n\t */\n\t_findTransactionsWaitingForLock (recordKey, transactions) {\n\t\tconst waiting = [];\n\n\t\tfor (const tx of transactions) {\n\t\t\tconst hasOperationOnKey = tx.writeSet.has(recordKey) || tx.readSet.has(recordKey);\n\t\t\tconst holdsLock = this.lockManager.holdsLocks(tx.id);\n\n\t\t\tif (hasOperationOnKey && !holdsLock) {\n\t\t\t\twaiting.push(tx.id);\n\t\t\t}\n\t\t}\n\n\t\treturn waiting;\n\t}\n\n\t/**\n\t * Detect deadlocks using resource allocation graph\n\t * @param {Transaction[]} activeTransactions - Active transactions\n\t * @returns {Object} Resource-based deadlock detection results\n\t * @private\n\t */\n\t_detectResourceDeadlocks (activeTransactions) {\n\t\tconst resourceGraph = this._buildResourceAllocationGraph(activeTransactions);\n\t\tconst cycles = this._detectCyclesInResourceGraph(resourceGraph);\n\n\t\treturn {\n\t\t\tgraph: resourceGraph,\n\t\t\tcycles: cycles.map(cycle => ({\n\t\t\t\ttype: \"resource\",\n\t\t\t\ttransactions: cycle.transactions,\n\t\t\t\tresources: cycle.resources\n\t\t\t}))\n\t\t};\n\t}\n\n\t/**\n\t * Build resource allocation graph\n\t * @param {Transaction[]} transactions - Active transactions\n\t * @returns {Object} Resource allocation graph\n\t * @private\n\t */\n\t_buildResourceAllocationGraph (transactions) {\n\t\tconst graph = {\n\t\t\ttransactions: new Map(), // tx -> Set<resources>\n\t\t\tresources: new Map(), // resource -> Set<tx>\n\t\t\twaiting: new Map() // tx -> Set<resources waiting for>\n\t\t};\n\n\t\t// Initialize\n\t\tfor (const tx of transactions) {\n\t\t\tgraph.transactions.set(tx.id, new Set());\n\t\t\tgraph.waiting.set(tx.id, new Set());\n\t\t}\n\n\t\t// Build allocation and waiting relationships\n\t\tconst lockStats = this.lockManager.getStats();\n\n\t\tfor (const lockInfo of lockStats.recordsLocked) {\n\t\t\tconst { recordKey, holders } = lockInfo;\n\n\t\t\tif (!graph.resources.has(recordKey)) {\n\t\t\t\tgraph.resources.set(recordKey, new Set());\n\t\t\t}\n\n\t\t\t// Record allocations\n\t\t\tfor (const holderId of holders) {\n\t\t\t\tif (graph.transactions.has(holderId)) {\n\t\t\t\t\tgraph.transactions.get(holderId).add(recordKey);\n\t\t\t\t\tgraph.resources.get(recordKey).add(holderId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Record waiting relationships\n\t\t\tconst waitingTx = this._findTransactionsWaitingForLock(recordKey, transactions);\n\t\t\tfor (const txId of waitingTx) {\n\t\t\t\tif (graph.waiting.has(txId)) {\n\t\t\t\t\tgraph.waiting.get(txId).add(recordKey);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn graph;\n\t}\n\n\t/**\n\t * Detect cycles in a wait-for graph\n\t * @param {Map<string, Set<string>>} graph - Wait-for graph\n\t * @returns {string[][]} Array of cycles (each cycle is array of transaction IDs)\n\t * @private\n\t */\n\t_detectCyclesInGraph (graph) {\n\t\tconst visited = new Set();\n\t\tconst recursionStack = new Set();\n\t\tconst cycles = [];\n\n\t\tconst dfs = (node, path) => {\n\t\t\tif (recursionStack.has(node)) {\n\t\t\t\t// Found a cycle\n\t\t\t\tconst cycleStart = path.indexOf(node);\n\t\t\t\tconst cycle = path.slice(cycleStart);\n\t\t\t\tcycles.push([...cycle, node]);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (visited.has(node)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvisited.add(node);\n\t\t\trecursionStack.add(node);\n\t\t\tpath.push(node);\n\n\t\t\tconst neighbors = graph.get(node) || new Set();\n\t\t\tfor (const neighbor of neighbors) {\n\t\t\t\tdfs(neighbor, [...path]);\n\t\t\t}\n\n\t\t\trecursionStack.delete(node);\n\t\t};\n\n\t\t// Start DFS from each unvisited node\n\t\tfor (const node of graph.keys()) {\n\t\t\tif (!visited.has(node)) {\n\t\t\t\tdfs(node, []);\n\t\t\t}\n\t\t}\n\n\t\treturn cycles;\n\t}\n\n\t/**\n\t * Detect cycles in resource allocation graph\n\t * @param {Object} resourceGraph - Resource allocation graph\n\t * @returns {Object[]} Array of resource-based cycles\n\t * @private\n\t */\n\t_detectCyclesInResourceGraph (resourceGraph) {\n\t\tconst cycles = [];\n\n\t\t// Convert resource graph to wait-for graph\n\t\tconst waitForGraph = new Map();\n\n\t\tfor (const [txId] of resourceGraph.transactions) {\n\t\t\twaitForGraph.set(txId, new Set());\n\t\t}\n\n\t\t// Build wait-for relationships\n\t\tfor (const [waitingTx, wantedResources] of resourceGraph.waiting) {\n\t\t\tfor (const resource of wantedResources) {\n\t\t\t\tconst holders = resourceGraph.resources.get(resource) || new Set();\n\t\t\t\tfor (const holdingTx of holders) {\n\t\t\t\t\tif (waitingTx !== holdingTx) {\n\t\t\t\t\t\twaitForGraph.get(waitingTx).add(holdingTx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Detect cycles in the converted graph\n\t\tconst graphCycles = this._detectCyclesInGraph(waitForGraph);\n\n\t\t// Convert back to resource cycles\n\t\tfor (const cycle of graphCycles) {\n\t\t\tconst resources = this._getResourcesInvolvedInCycle(cycle,\n\t\t\t\tArray.from(resourceGraph.transactions.keys()).map(id => ({ id })));\n\t\t\tcycles.push({\n\t\t\t\ttransactions: cycle,\n\t\t\t\tresources: Array.from(resources)\n\t\t\t});\n\t\t}\n\n\t\treturn cycles;\n\t}\n\n\t/**\n\t * Get resources involved in a deadlock cycle\n\t * @param {string[]} cycle - Array of transaction IDs in cycle\n\t * @param {Transaction[]|Object[]} transactions - Transaction objects or objects with id\n\t * @returns {Set<string>} Set of resource keys involved\n\t * @private\n\t */\n\t_getResourcesInvolvedInCycle (cycle, transactions) {\n\t\tconst resources = new Set();\n\n\t\tfor (const txId of cycle) {\n\t\t\tconst tx = transactions.find(t => t.id === txId);\n\t\t\tif (tx && tx.writeSet && tx.readSet) {\n\t\t\t\tfor (const key of tx.writeSet) {\n\t\t\t\t\tresources.add(key);\n\t\t\t\t}\n\t\t\t\tfor (const key of tx.readSet) {\n\t\t\t\t\tresources.add(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn resources;\n\t}\n\n\t/**\n\t * Detect isolation-level based deadlocks\n\t * @param {Transaction[]} activeTransactions - Active transactions\n\t * @returns {Object[]} Array of suspected isolation deadlocks\n\t * @private\n\t */\n\t_detectIsolationDeadlocks (activeTransactions) {\n\t\tconst suspectedDeadlocks = [];\n\n\t\tfor (let i = 0; i < activeTransactions.length; i++) {\n\t\t\tfor (let j = i + 1; j < activeTransactions.length; j++) {\n\t\t\t\tconst tx1 = activeTransactions[i];\n\t\t\t\tconst tx2 = activeTransactions[j];\n\n\t\t\t\tif (this._hasIsolationConflict(tx1, tx2)) {\n\t\t\t\t\tsuspectedDeadlocks.push({\n\t\t\t\t\t\ttype: \"isolation\",\n\t\t\t\t\t\ttransactions: [tx1.id, tx2.id],\n\t\t\t\t\t\tconflict: this._getIsolationConflictType(tx1, tx2)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn suspectedDeadlocks;\n\t}\n\n\t/**\n\t * Check if two transactions have isolation conflicts\n\t * @param {Transaction} tx1 - First transaction\n\t * @param {Transaction} tx2 - Second transaction\n\t * @returns {boolean} True if isolation conflict exists\n\t * @private\n\t */\n\t_hasIsolationConflict (tx1, tx2) {\n\t\tif (tx1.isolationLevel >= IsolationLevels.REPEATABLE_READ ||\n\t\t\ttx2.isolationLevel >= IsolationLevels.REPEATABLE_READ) {\n\n\t\t\tconst tx1ReadsWhatTx2Writes = this._readsOtherWrites(tx1, tx2);\n\t\t\tconst tx2ReadsWhatTx1Writes = this._readsOtherWrites(tx2, tx1);\n\n\t\t\treturn tx1ReadsWhatTx2Writes || tx2ReadsWhatTx1Writes;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Get the type of isolation conflict between transactions\n\t * @param {Transaction} tx1 - First transaction\n\t * @param {Transaction} tx2 - Second transaction\n\t * @returns {string} Conflict type description\n\t * @private\n\t */\n\t_getIsolationConflictType (tx1, tx2) {\n\t\tif (this._readsOtherWrites(tx1, tx2) && this._readsOtherWrites(tx2, tx1)) {\n\t\t\treturn \"bidirectional-dependency\";\n\t\t} else if (this._readsOtherWrites(tx1, tx2)) {\n\t\t\treturn \"tx1-depends-on-tx2\";\n\t\t} else if (this._readsOtherWrites(tx2, tx1)) {\n\t\t\treturn \"tx2-depends-on-tx1\";\n\t\t}\n\n\t\treturn \"unknown\";\n\t}\n\n\t/**\n\t * Check if one transaction reads what another writes\n\t * @param {Transaction} reader - Reading transaction\n\t * @param {Transaction} writer - Writing transaction\n\t * @returns {boolean} True if dependency exists\n\t * @private\n\t */\n\t_readsOtherWrites (reader, writer) {\n\t\tfor (const readKey of reader.readSet) {\n\t\t\tif (writer.writeSet.has(readKey)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Detect timeout-based deadlock victims\n\t * @param {Transaction[]} activeTransactions - Active transactions\n\t * @param {number} timeoutThreshold - Timeout threshold in milliseconds\n\t * @returns {string[]} Transaction IDs that have timed out\n\t * @private\n\t */\n\t_detectTimeoutVictims (activeTransactions, timeoutThreshold) {\n\t\tconst victims = [];\n\n\t\tfor (const transaction of activeTransactions) {\n\t\t\tconst duration = transaction.getDuration();\n\t\t\tif (duration !== null && duration > timeoutThreshold) {\n\t\t\t\tvictims.push(transaction.id);\n\t\t\t}\n\t\t}\n\n\t\treturn victims;\n\t}\n\n\t/**\n\t * Remove duplicate deadlocks from results\n\t * @param {Object[]} deadlocks - Array of deadlock objects\n\t * @returns {Object[]} Deduplicated deadlocks\n\t * @private\n\t */\n\t_deduplicateDeadlocks (deadlocks) {\n\t\tconst seen = new Set();\n\t\tconst unique = [];\n\n\t\tfor (const deadlock of deadlocks) {\n\t\t\tconst signature = this._createDeadlockSignature(deadlock);\n\n\t\t\tif (!seen.has(signature)) {\n\t\t\t\tseen.add(signature);\n\t\t\t\tunique.push(deadlock);\n\t\t\t}\n\t\t}\n\n\t\treturn unique;\n\t}\n\n\t/**\n\t * Create a normalized signature for a deadlock\n\t * @param {Object} deadlock - Deadlock object\n\t * @returns {string} Normalized signature\n\t * @private\n\t */\n\t_createDeadlockSignature (deadlock) {\n\t\tconst sortedTransactions = [...deadlock.transactions].sort();\n\t\tconst sortedResources = deadlock.resources ? [...deadlock.resources].sort() : [];\n\n\t\treturn `${deadlock.type}:${sortedTransactions.join(\",\")}:${sortedResources.join(\",\")}`;\n\t}\n}\n","import { TransactionError } from \"./errors.js\";\nimport { IsolationLevels } from \"./constants.js\";\nimport { KeyRelationshipAnalyzer } from \"./key-relationship-analyzer.js\";\n\n/**\n * Validator for transaction isolation levels and conflict detection\n */\nexport class IsolationValidator {\n\tconstructor () {\n\t\tthis.keyAnalyzer = new KeyRelationshipAnalyzer();\n\t}\n\n\t/**\n\t * Validate isolation level requirements for a transaction\n\t * @param {Transaction} transaction - Transaction to validate\n\t * @param {Map<string, Transaction>} allTransactions - All active transactions\n\t * @throws {TransactionError} If isolation violation detected\n\t */\n\tvalidateIsolation (transaction, allTransactions) {\n\t\tswitch (transaction.isolationLevel) {\n\t\t\tcase IsolationLevels.READ_UNCOMMITTED:\n\t\t\t\t// No validation needed - allows dirty reads\n\t\t\t\tbreak;\n\n\t\t\tcase IsolationLevels.READ_COMMITTED:\n\t\t\t\tthis._validateReadCommitted(transaction, allTransactions);\n\t\t\t\tbreak;\n\n\t\t\tcase IsolationLevels.REPEATABLE_READ:\n\t\t\t\tthis._validateRepeatableRead(transaction, allTransactions);\n\t\t\t\tbreak;\n\n\t\t\tcase IsolationLevels.SERIALIZABLE:\n\t\t\t\tthis._validateSerializable(transaction, allTransactions);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new TransactionError(\n\t\t\t\t\t`Unknown isolation level: ${transaction.isolationLevel}`,\n\t\t\t\t\ttransaction.id,\n\t\t\t\t\t\"isolation\"\n\t\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Validate READ_COMMITTED isolation level\n\t * @param {Transaction} transaction - Transaction to validate\n\t * @param {Map<string, Transaction>} allTransactions - All transactions\n\t * @throws {TransactionError} If isolation violation detected\n\t * @private\n\t */\n\t_validateReadCommitted (transaction, allTransactions) {\n\t\tfor (const writeKey of transaction.writeSet) {\n\t\t\tconst conflictingTransactions = this._findConflictingWrites(transaction.id, writeKey, allTransactions);\n\t\t\tif (conflictingTransactions.length > 0) {\n\t\t\t\tthrow new TransactionError(\n\t\t\t\t\t`Write conflict detected on key '${writeKey}' with transactions: ${conflictingTransactions.join(\", \")}`,\n\t\t\t\t\ttransaction.id,\n\t\t\t\t\t\"write-conflict\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Validate REPEATABLE_READ isolation level\n\t * @param {Transaction} transaction - Transaction to validate\n\t * @param {Map<string, Transaction>} allTransactions - All transactions\n\t * @throws {TransactionError} If isolation violation detected\n\t * @private\n\t */\n\t_validateRepeatableRead (transaction, allTransactions) {\n\t\t// First validate READ_COMMITTED requirements\n\t\tthis._validateReadCommitted(transaction, allTransactions);\n\n\t\t// Check for repeatable read violations\n\t\tfor (const readKey of transaction.readSet) {\n\t\t\tif (this._hasReadSetConflict(transaction, readKey, allTransactions)) {\n\t\t\t\tthrow new TransactionError(\n\t\t\t\t\t`Repeatable read violation: key '${readKey}' was modified by another transaction`,\n\t\t\t\t\ttransaction.id,\n\t\t\t\t\t\"repeatable-read-violation\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Check for phantom reads in range queries\n\t\tif (transaction.snapshot.size > 0) {\n\t\t\tfor (const [snapshotKey, snapshotValue] of transaction.snapshot) {\n\t\t\t\tif (this._hasSnapshotConflict(transaction, snapshotKey, snapshotValue, allTransactions)) {\n\t\t\t\t\tthrow new TransactionError(\n\t\t\t\t\t\t`Phantom read detected: snapshot inconsistency for key '${snapshotKey}'`,\n\t\t\t\t\t\ttransaction.id,\n\t\t\t\t\t\t\"phantom-read\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Validate SERIALIZABLE isolation level\n\t * @param {Transaction} transaction - Transaction to validate\n\t * @param {Map<string, Transaction>} allTransactions - All transactions\n\t * @throws {TransactionError} If isolation violation detected\n\t * @private\n\t */\n\t_validateSerializable (transaction, allTransactions) {\n\t\t// First validate REPEATABLE_READ requirements\n\t\tthis._validateRepeatableRead(transaction, allTransactions);\n\n\t\t// Check for read-write conflicts\n\t\tfor (const readKey of transaction.readSet) {\n\t\t\tconst conflictingWrites = this._findConflictingWritesToRead(transaction, readKey, allTransactions);\n\t\t\tif (conflictingWrites.length > 0) {\n\t\t\t\tthrow new TransactionError(\n\t\t\t\t\t`Serialization conflict: key '${readKey}' was written by concurrent transactions: ${conflictingWrites.join(\", \")}`,\n\t\t\t\t\ttransaction.id,\n\t\t\t\t\t\"serialization-conflict\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Check for write-read conflicts\n\t\tfor (const writeKey of transaction.writeSet) {\n\t\t\tconst conflictingReads = this._findConflictingReadsToWrite(transaction, writeKey, allTransactions);\n\t\t\tif (conflictingReads.length > 0) {\n\t\t\t\tthrow new TransactionError(\n\t\t\t\t\t`Serialization conflict: key '${writeKey}' was read by concurrent transactions: ${conflictingReads.join(\", \")}`,\n\t\t\t\t\ttransaction.id,\n\t\t\t\t\t\"serialization-conflict\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Find transactions that have conflicting writes to the same key\n\t * @param {string} excludeTransactionId - Transaction ID to exclude from search\n\t * @param {string} key - Key to check for conflicts\n\t * @param {Map<string, Transaction>} allTransactions - All transactions\n\t * @returns {string[]} Array of conflicting transaction IDs\n\t * @private\n\t */\n\t_findConflictingWrites (excludeTransactionId, key, allTransactions) {\n\t\tconst conflicting = [];\n\n\t\tfor (const [txId, transaction] of allTransactions) {\n\t\t\tif (txId !== excludeTransactionId &&\n\t\t\t\ttransaction.isActive() &&\n\t\t\t\ttransaction.writeSet.has(key)) {\n\t\t\t\tconflicting.push(txId);\n\t\t\t}\n\t\t}\n\n\t\treturn conflicting;\n\t}\n\n\t/**\n\t * Find transactions that wrote to a key this transaction read\n\t * @param {Transaction} transaction - Transaction to check\n\t * @param {string} key - Key that was read\n\t * @param {Map<string, Transaction>} allTransactions - All transactions\n\t * @returns {string[]} Array of conflicting transaction IDs\n\t * @private\n\t */\n\t_findConflictingWritesToRead (transaction, key, allTransactions) {\n\t\tconst conflicting = [];\n\n\t\tfor (const [txId, otherTx] of allTransactions) {\n\t\t\tif (txId !== transaction.id &&\n\t\t\t\totherTx.isActive() &&\n\t\t\t\totherTx.writeSet.has(key) &&\n\t\t\t\tthis._transactionsOverlap(transaction, otherTx)) {\n\t\t\t\tconflicting.push(txId);\n\t\t\t}\n\t\t}\n\n\t\treturn conflicting;\n\t}\n\n\t/**\n\t * Find transactions that read a key this transaction wrote\n\t * @param {Transaction} transaction - Transaction to check\n\t * @param {string} key - Key that was written\n\t * @param {Map<string, Transaction>} allTransactions - All transactions\n\t * @returns {string[]} Array of conflicting transaction IDs\n\t * @private\n\t */\n\t_findConflictingReadsToWrite (transaction, key, allTransactions) {\n\t\tconst conflicting = [];\n\n\t\tfor (const [txId, otherTx] of allTransactions) {\n\t\t\tif (txId !== transaction.id &&\n\t\t\t\totherTx.isActive() &&\n\t\t\t\totherTx.readSet.has(key) &&\n\t\t\t\tthis._transactionsOverlap(transaction, otherTx)) {\n\t\t\t\tconflicting.push(txId);\n\t\t\t}\n\t\t}\n\n\t\treturn conflicting;\n\t}\n\n\t/**\n\t * Check if a read key has conflicts with other transactions\n\t * @param {Transaction} transaction - Transaction to check\n\t * @param {string} key - Key that was read\n\t * @param {Map<string, Transaction>} allTransactions - All transactions\n\t * @returns {boolean} True if conflict detected\n\t * @private\n\t */\n\t_hasReadSetConflict (transaction, key, allTransactions) {\n\t\tfor (const [txId, otherTx] of allTransactions) {\n\t\t\tif (txId !== transaction.id &&\n\t\t\t\totherTx.isCommitted() &&\n\t\t\t\totherTx.writeSet.has(key) &&\n\t\t\t\totherTx.startTime > transaction.startTime &&\n\t\t\t\totherTx.endTime < new Date()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if snapshot has conflicts indicating phantom reads\n\t * @param {Transaction} transaction - Transaction to check\n\t * @param {string} key - Snapshot key\n\t * @param {*} expectedValue - Expected value from snapshot\n\t * @param {Map<string, Transaction>} allTransactions - All transactions\n\t * @returns {boolean} True if conflict detected\n\t * @private\n\t */\n\t_hasSnapshotConflict (transaction, key, expectedValue, allTransactions) {\n\t\t// Check if any other transaction modified this specific key\n\t\tif (this._hasReadSetConflict(transaction, key, allTransactions)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for phantom reads in range-based operations\n\t\tfor (const [txId, otherTx] of allTransactions) {\n\t\t\tif (txId !== transaction.id && this._transactionsOverlap(transaction, otherTx)) {\n\t\t\t\tif (this._hasPhantomConflict(transaction, otherTx, key, expectedValue)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check for serialization anomalies specific to snapshots\n\t\tif (this._hasSerializationAnomalyInSnapshot(transaction, key, allTransactions)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if another transaction creates phantom reads for this transaction's snapshot\n\t * @param {Transaction} transaction - Transaction with snapshot\n\t * @param {Transaction} otherTransaction - Other concurrent transaction\n\t * @param {string} key - Snapshot key\n\t * @param {*} expectedValue - Expected value from snapshot\n\t * @returns {boolean} True if phantom conflict detected\n\t * @private\n\t */\n\t_hasPhantomConflict (transaction, otherTransaction, key, expectedValue) {\n\t\tfor (const operation of otherTransaction.operations) {\n\t\t\tif (operation.type !== \"read\") {\n\t\t\t\tif (operation.key === key) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (this.keyAnalyzer.isKeyInSnapshotRange(transaction, operation.key, key, expectedValue)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check for serialization anomalies in snapshot data\n\t * @param {Transaction} transaction - Transaction with snapshot\n\t * @param {string} key - Snapshot key\n\t * @param {Map<string, Transaction>} allTransactions - All transactions\n\t * @returns {boolean} True if serialization anomaly detected\n\t * @private\n\t */\n\t_hasSerializationAnomalyInSnapshot (transaction, key, allTransactions) {\n\t\tfor (const [txId, otherTx] of allTransactions) {\n\t\t\tif (txId !== transaction.id &&\n\t\t\t\totherTx.isActive() &&\n\t\t\t\tthis._transactionsOverlap(transaction, otherTx)) {\n\n\t\t\t\tif (this._hasWriteSkewAnomaly(transaction, otherTx, key)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (this._hasDependencyCycle(transaction, otherTx)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check for write-skew anomalies between transactions\n\t * @param {Transaction} tx1 - First transaction\n\t * @param {Transaction} tx2 - Second transaction\n\t * @param {string} key - Key being checked\n\t * @returns {boolean} True if write-skew detected\n\t * @private\n\t */\n\t_hasWriteSkewAnomaly (tx1, tx2, key) {\n\t\tconst tx1ReadsRelated = this._hasRelatedReads(tx1, key);\n\t\tconst tx2ReadsRelated = this._hasRelatedReads(tx2, key);\n\n\t\tif (!tx1ReadsRelated || !tx2ReadsRelated) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst tx1Writes = Array.from(tx1.writeSet);\n\t\tconst tx2Writes = Array.from(tx2.writeSet);\n\t\tconst hasOverlappingWrites = tx1Writes.some(k => tx2Writes.includes(k));\n\n\t\tif (hasOverlappingWrites) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tx1Writes.length > 0 && tx2Writes.length > 0;\n\t}\n\n\t/**\n\t * Check if transaction has reads related to a key\n\t * @param {Transaction} transaction - Transaction to check\n\t * @param {string} key - Reference key\n\t * @returns {boolean} True if has related reads\n\t * @private\n\t */\n\t_hasRelatedReads (transaction, key) {\n\t\tfor (const readKey of transaction.readSet) {\n\t\t\tif (this.keyAnalyzer.areKeysRelated(readKey, key)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check for dependency cycles between transactions\n\t * @param {Transaction} tx1 - First transaction\n\t * @param {Transaction} tx2 - Second transaction\n\t * @returns {boolean} True if dependency cycle detected\n\t * @private\n\t */\n\t_hasDependencyCycle (tx1, tx2) {\n\t\tconst tx1ReadsTx2Writes = this._readsOtherWrites(tx1, tx2);\n\t\tconst tx2ReadsTx1Writes = this._readsOtherWrites(tx2, tx1);\n\n\t\treturn tx1ReadsTx2Writes && tx2ReadsTx1Writes;\n\t}\n\n\t/**\n\t * Check if one transaction reads what another writes\n\t * @param {Transaction} reader - Reading transaction\n\t * @param {Transaction} writer - Writing transaction\n\t * @returns {boolean} True if dependency exists\n\t * @private\n\t */\n\t_readsOtherWrites (reader, writer) {\n\t\tfor (const readKey of reader.readSet) {\n\t\t\tif (writer.writeSet.has(readKey)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if two transactions have overlapping execution periods\n\t * @param {Transaction} tx1 - First transaction\n\t * @param {Transaction} tx2 - Second transaction\n\t * @returns {boolean} True if transactions overlap in time\n\t * @private\n\t */\n\t_transactionsOverlap (tx1, tx2) {\n\t\tif (!tx1.startTime || !tx2.startTime) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst tx1Start = tx1.startTime.getTime();\n\t\tconst tx1End = tx1.endTime ? tx1.endTime.getTime() : Date.now();\n\t\tconst tx2Start = tx2.startTime.getTime();\n\t\tconst tx2End = tx2.endTime ? tx2.endTime.getTime() : Date.now();\n\n\t\treturn tx1Start < tx2End && tx2Start < tx1End;\n\t}\n}\n","import { TransactionError } from \"./errors.js\";\nimport { LockTypes } from \"./constants.js\";\nimport { Transaction } from \"./transaction-individual.js\";\nimport { LockManager } from \"./lock-manager.js\";\nimport { TransactionStatistics } from \"./transaction-statistics.js\";\nimport { DeadlockDetector } from \"./deadlock-detector.js\";\nimport { IsolationValidator } from \"./isolation-validator.js\";\n\n/**\n * Refactored transaction manager for coordinating multiple transactions\n * Delegates complex operations to specialized classes\n */\nexport class TransactionManager {\n\tconstructor () {\n\t\t// Active transactions\n\t\tthis.transactions = new Map();\n\n\t\t// Lock manager for concurrency control\n\t\tthis.lockManager = new LockManager();\n\n\t\t// Global transaction counter\n\t\tthis.transactionCounter = 0;\n\n\t\t// Specialized components\n\t\tthis.statistics = new TransactionStatistics();\n\t\tthis.deadlockDetector = new DeadlockDetector(this.lockManager);\n\t\tthis.isolationValidator = new IsolationValidator();\n\t}\n\n\t/**\n\t * Begin a new transaction\n\t * @param {Object} [options={}] - Transaction options\n\t * @returns {Transaction} New transaction instance\n\t */\n\tbegin (options = {}) {\n\t\tconst transaction = new Transaction(undefined, options);\n\t\ttransaction.begin();\n\n\t\tthis.transactions.set(transaction.id, transaction);\n\t\tthis.transactionCounter++;\n\t\tthis.statistics.incrementTotal();\n\t\tthis.statistics.incrementActive();\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Get transaction by ID\n\t * @param {string} transactionId - Transaction ID\n\t * @returns {Transaction|undefined} Transaction instance\n\t */\n\tgetTransaction (transactionId) {\n\t\treturn this.transactions.get(transactionId);\n\t}\n\n\t/**\n\t * Commit a transaction\n\t * @param {string} transactionId - Transaction ID\n\t * @param {Object} [context] - Commit context\n\t * @returns {Transaction} Committed transaction\n\t * @throws {TransactionError} If transaction not found or commit fails\n\t */\n\tasync commit (transactionId, context = {}) {\n\t\tconst transaction = this.transactions.get(transactionId);\n\t\tif (!transaction) {\n\t\t\tthrow new TransactionError(`Transaction ${transactionId} not found`, transactionId, \"commit\");\n\t\t}\n\n\t\ttry {\n\t\t\t// Acquire locks for all writes\n\t\t\tfor (const key of transaction.writeSet) {\n\t\t\t\tawait this.lockManager.acquireLock(transactionId, key, LockTypes.EXCLUSIVE);\n\t\t\t}\n\n\t\t\t// Perform isolation level checks using specialized validator\n\t\t\tthis.isolationValidator.validateIsolation(transaction, this.transactions);\n\n\t\t\t// Commit the transaction\n\t\t\ttransaction.commit(context);\n\n\t\t\t// Update statistics\n\t\t\tthis.statistics.incrementCommitted();\n\t\t\tthis.statistics.decrementActive();\n\t\t\tthis.statistics.updateDurationStats(transaction);\n\n\t\t\treturn transaction;\n\t\t} catch (error) {\n\t\t\t// Auto-abort on failure\n\t\t\tthis.abort(transactionId, error.message);\n\t\t\tthrow error;\n\t\t/* c8 ignore next */ } finally {\n\t\t\t// Always release locks\n\t\t\tthis.lockManager.releaseAllLocks(transactionId);\n\t\t}\n\t}\n\n\t/**\n\t * Abort a transaction\n\t * @param {string} transactionId - Transaction ID\n\t * @param {string} [reason] - Reason for abort\n\t * @returns {Transaction} Aborted transaction\n\t * @throws {TransactionError} If transaction not found\n\t */\n\tabort (transactionId, reason = \"Manual abort\") {\n\t\tconst transaction = this.transactions.get(transactionId);\n\t\tif (!transaction) {\n\t\t\tthrow new TransactionError(`Transaction ${transactionId} not found`, transactionId, \"abort\");\n\t\t}\n\n\t\ttransaction.abort(reason);\n\n\t\t// Release all locks\n\t\tthis.lockManager.releaseAllLocks(transactionId);\n\n\t\t// Update statistics\n\t\tthis.statistics.incrementAborted();\n\t\tthis.statistics.decrementActive();\n\t\tthis.statistics.updateDurationStats(transaction);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Clean up completed transactions\n\t * @param {number} [maxAge=3600000] - Maximum age in milliseconds (default: 1 hour)\n\t * @returns {number} Number of transactions cleaned up\n\t */\n\tcleanup (maxAge = 3600000) {\n\t\tconst cutoffTime = Date.now() - maxAge;\n\t\tlet cleaned = 0;\n\n\t\tfor (const [id, transaction] of this.transactions) {\n\t\t\t// Special case: maxAge of 0 means clean ALL completed transactions\n\t\t\tif (transaction.endTime && (maxAge === 0 || transaction.endTime.getTime() < cutoffTime)) {\n\t\t\t\tthis.transactions.delete(id);\n\t\t\t\tcleaned++;\n\t\t\t}\n\t\t}\n\n\t\treturn cleaned;\n\t}\n\n\t/**\n\t * Get all active transactions\n\t * @returns {Transaction[]} Array of active transactions\n\t */\n\tgetActiveTransactions () {\n\t\treturn Array.from(this.transactions.values()).filter(t => t.isActive());\n\t}\n\n\t/**\n\t * Check for deadlocks using specialized detector\n\t * @param {Object} [options={}] - Detection options\n\t * @returns {Object} Deadlock detection results\n\t */\n\tdetectDeadlocks (options = {}) {\n\t\tconst activeTransactions = this.getActiveTransactions();\n\n\t\treturn this.deadlockDetector.detectDeadlocks(activeTransactions, options);\n\t}\n\n\t/**\n\t * Get comprehensive statistics\n\t * @returns {Object} Statistics object\n\t */\n\tgetStats () {\n\t\tconst activeCount = this.getActiveTransactions().length;\n\t\tconst lockStats = this.lockManager.getStats();\n\n\t\treturn this.statistics.getStats(lockStats, activeCount, this.transactionCounter);\n\t}\n\n\t/**\n\t * Reset all statistics\n\t */\n\tresetStats () {\n\t\tthis.statistics.reset();\n\t}\n\n\t/**\n\t * Get access to specialized components for advanced usage\n\t * @returns {Object} Specialized components\n\t */\n\tgetComponents () {\n\t\treturn {\n\t\t\tstatistics: this.statistics,\n\t\t\tdeadlockDetector: this.deadlockDetector,\n\t\t\tisolationValidator: this.isolationValidator,\n\t\t\tlockManager: this.lockManager\n\t\t};\n\t}\n\n\t/**\n\t * Validate isolation for a specific transaction (for testing/debugging)\n\t * @param {string} transactionId - Transaction ID to validate\n\t * @throws {TransactionError} If validation fails\n\t */\n\tvalidateTransactionIsolation (transactionId) {\n\t\tconst transaction = this.transactions.get(transactionId);\n\t\tif (!transaction) {\n\t\t\tthrow new TransactionError(`Transaction ${transactionId} not found`, transactionId, \"validate\");\n\t\t}\n\n\t\tthis.isolationValidator.validateIsolation(transaction, this.transactions);\n\t}\n\n\t/**\n\t * Force deadlock detection and return results\n\t * @param {Object} [options={}] - Detection options\n\t * @returns {Object} Deadlock detection results\n\t */\n\tcheckForDeadlocks (options = {}) {\n\t\treturn this.detectDeadlocks(options);\n\t}\n\n\t/**\n\t * Get detailed transaction information for debugging\n\t * @param {string} transactionId - Transaction ID\n\t * @returns {Object|null} Detailed transaction info or null if not found\n\t */\n\tgetTransactionDetails (transactionId) {\n\t\tconst transaction = this.transactions.get(transactionId);\n\t\tif (!transaction) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\t...transaction.getStats(),\n\t\t\tlockInfo: this.lockManager.getStats().recordsLocked.filter(\n\t\t\t\tlock => lock.holders.includes(transactionId)\n\t\t\t)\n\t\t};\n\t}\n\n\t/**\n\t * Get system health information\n\t * @returns {Object} System health metrics\n\t */\n\tgetSystemHealth () {\n\t\tconst stats = this.getStats();\n\t\tconst deadlockResults = this.detectDeadlocks();\n\n\t\treturn {\n\t\t\tactiveTransactions: stats.activeTransactions,\n\t\t\ttotalTransactions: stats.totalTransactions,\n\t\t\tcommitRate: stats.totalTransactions > 0 ? stats.committedTransactions / stats.totalTransactions : 0,\n\t\t\taverageDuration: stats.averageDuration,\n\t\t\thasDeadlocks: deadlockResults.deadlocks.length > 0,\n\t\t\tsuspectedDeadlocks: deadlockResults.suspectedDeadlocks.length,\n\t\t\ttimeoutVictims: deadlockResults.timeoutVictims.length,\n\t\t\ttotalLocks: stats.lockStats.totalLocks,\n\t\t\tlockUtilization: stats.lockStats.totalLocks > 0 ? stats.lockStats.uniqueHolders / stats.lockStats.totalLocks : 0\n\t\t};\n\t}\n}\n","/**\n * Query operation types\n */\nexport const QueryTypes = {\n\tFIND: \"find\",\n\tFILTER: \"filter\",\n\tSEARCH: \"search\",\n\tWHERE: \"where\",\n\tSORT: \"sort\",\n\tLIMIT: \"limit\",\n\tAGGREGATE: \"aggregate\"\n};\n\n/**\n * Cost estimation factors\n */\nexport const CostFactors = {\n\tINDEX_LOOKUP: 1,\n\tFULL_SCAN: 100,\n\tFILTER_EVALUATION: 10,\n\tSORT_OPERATION: 50,\n\tMEMORY_ACCESS: 1,\n\tCOMPARISON: 2,\n\tREGEX_MATCH: 20\n};\n\n/**\n * Query execution plan step\n */\nexport class QueryPlanStep {\n\t/**\n\t * @param {string} operation - Operation type\n\t * @param {Object} [options={}] - Operation options\n\t * @param {number} [estimatedCost=0] - Estimated cost of this step\n\t * @param {number} [estimatedRows=0] - Estimated number of rows processed\n\t */\n\tconstructor (operation, options = {}, estimatedCost = 0, estimatedRows = 0) {\n\t\tthis.operation = operation;\n\t\tthis.options = options;\n\t\tthis.estimatedCost = estimatedCost;\n\t\tthis.estimatedRows = estimatedRows;\n\t\tthis.actualCost = null;\n\t\tthis.actualRows = null;\n\t\tthis.startTime = null;\n\t\tthis.endTime = null;\n\t}\n\n\t/**\n\t * Start execution timing\n\t */\n\tstartExecution () {\n\t\tthis.startTime = Date.now();\n\t}\n\n\t/**\n\t * End execution timing\n\t * @param {number} actualRows - Actual number of rows processed\n\t */\n\tendExecution (actualRows) {\n\t\tthis.endTime = Date.now();\n\t\tthis.actualCost = this.endTime - this.startTime;\n\t\tthis.actualRows = actualRows;\n\t}\n\n\t/**\n\t * Get execution statistics\n\t * @returns {Object} Execution statistics\n\t */\n\tgetStats () {\n\t\treturn {\n\t\t\toperation: this.operation,\n\t\t\toptions: this.options,\n\t\t\testimatedCost: this.estimatedCost,\n\t\t\testimatedRows: this.estimatedRows,\n\t\t\tactualCost: this.actualCost,\n\t\t\tactualRows: this.actualRows,\n\t\t\tcostAccuracy: this.actualCost && this.estimatedCost ?\n\t\t\t\tMath.abs(this.actualCost - this.estimatedCost) / this.estimatedCost :\n\t\t\t\tnull,\n\t\t\trowAccuracy: this.actualRows !== null && this.estimatedRows ?\n\t\t\t\tMath.abs(this.actualRows - this.estimatedRows) / this.estimatedRows :\n\t\t\t\tnull\n\t\t};\n\t}\n}\n\n/**\n * Query execution plan\n */\nexport class QueryPlan {\n\t/**\n\t * @param {string} queryId - Unique query identifier\n\t * @param {Object} originalQuery - Original query object\n\t */\n\tconstructor (queryId, originalQuery) {\n\t\tthis.queryId = queryId;\n\t\tthis.originalQuery = originalQuery;\n\t\tthis.steps = [];\n\t\tthis.totalEstimatedCost = 0;\n\t\tthis.totalEstimatedRows = 0;\n\t\tthis.totalActualCost = null;\n\t\tthis.totalActualRows = null;\n\t\tthis.createdAt = new Date();\n\t\tthis.executedAt = null;\n\t\tthis.completedAt = null;\n\t}\n\n\t/**\n\t * Add a step to the execution plan\n\t * @param {QueryPlanStep} step - Query plan step\n\t * @returns {QueryPlan} This plan for chaining\n\t */\n\taddStep (step) {\n\t\tthis.steps.push(step);\n\t\tthis.totalEstimatedCost += step.estimatedCost;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start plan execution\n\t */\n\tstartExecution () {\n\t\tthis.executedAt = new Date();\n\t}\n\n\t/**\n\t * Complete plan execution\n\t * @param {number} actualRows - Final number of rows returned\n\t */\n\tcompleteExecution (actualRows) {\n\t\tthis.completedAt = new Date();\n\t\tthis.totalActualRows = actualRows;\n\t\tthis.totalActualCost = this.completedAt.getTime() - (this.executedAt?.getTime() || this.createdAt.getTime());\n\t}\n\n\t/**\n\t * Get execution statistics\n\t * @returns {Object} Execution statistics\n\t */\n\tgetStats () {\n\t\treturn {\n\t\t\tqueryId: this.queryId,\n\t\t\toriginalQuery: this.originalQuery,\n\t\t\tstepCount: this.steps.length,\n\t\t\ttotalEstimatedCost: this.totalEstimatedCost,\n\t\t\ttotalEstimatedRows: this.totalEstimatedRows,\n\t\t\ttotalActualCost: this.totalActualCost,\n\t\t\ttotalActualRows: this.totalActualRows,\n\t\t\tcreatedAt: this.createdAt,\n\t\t\texecutedAt: this.executedAt,\n\t\t\tcompletedAt: this.completedAt,\n\t\t\tsteps: this.steps.map(step => step.getStats()),\n\t\t\tefficiency: this.totalActualCost && this.totalEstimatedCost ?\n\t\t\t\tthis.totalEstimatedCost / this.totalActualCost :\n\t\t\t\tnull\n\t\t};\n\t}\n\n\t/**\n\t * Export plan for debugging\n\t * @returns {Object} Exportable plan data\n\t */\n\texport () {\n\t\treturn {\n\t\t\t...this.getStats(),\n\t\t\texplanation: this._generateExplanation()\n\t\t};\n\t}\n\n\t/**\n\t * Generate human-readable explanation of the plan\n\t * @returns {string[]} Array of explanation lines\n\t * @private\n\t */\n\t_generateExplanation () {\n\t\tconst explanation = [];\n\n\t\texplanation.push(`Query Plan for: ${JSON.stringify(this.originalQuery)}`);\n\t\texplanation.push(`Estimated cost: ${this.totalEstimatedCost}, rows: ${this.totalEstimatedRows}`);\n\n\t\tif (this.totalActualCost !== null) {\n\t\t\texplanation.push(`Actual cost: ${this.totalActualCost}, rows: ${this.totalActualRows}`);\n\t\t}\n\n\t\texplanation.push(\"\");\n\t\texplanation.push(\"Execution steps:\");\n\n\t\tthis.steps.forEach((step, index) => {\n\t\t\tconst stats = step.getStats();\n\t\t\texplanation.push(`${index + 1}. ${stats.operation} (cost: ${stats.estimatedCost}, rows: ${stats.estimatedRows})`);\n\n\t\t\tif (stats.actualCost !== null) {\n\t\t\t\texplanation.push(`   Actual: cost: ${stats.actualCost}, rows: ${stats.actualRows}`);\n\t\t\t}\n\t\t});\n\n\t\treturn explanation;\n\t}\n}\n\n/**\n * Statistics about data distribution for cost estimation\n */\nexport class DataStatistics {\n\tconstructor () {\n\t\tthis.totalRecords = 0;\n\t\tthis.indexStatistics = new Map(); // Map<indexName, {cardinality, selectivity, histogram}>\n\t\tthis.fieldStatistics = new Map(); // Map<fieldName, {nullCount, uniqueValues, dataType, avgLength}>\n\t\tthis.lastUpdated = new Date();\n\t}\n\n\t/**\n\t * Update statistics from current data\n\t * @param {Map} records - Current record data\n\t * @param {Map} indexes - Current index data\n\t */\n\tupdate (records, indexes) {\n\t\tthis.totalRecords = records.size;\n\t\tthis.lastUpdated = new Date();\n\n\t\t// Update field statistics\n\t\tthis._updateFieldStatistics(records);\n\n\t\t// Update index statistics\n\t\tthis._updateIndexStatistics(indexes);\n\t}\n\n\t/**\n\t * Get selectivity estimate for a field value\n\t * @param {string} fieldName - Field name\n\t * @returns {number} Selectivity estimate (0-1)\n\t */\n\tgetSelectivity (fieldName) {\n\t\tconst fieldStats = this.fieldStatistics.get(fieldName);\n\t\tif (!fieldStats) {\n\t\t\treturn 0.1; // Default selectivity\n\t\t}\n\n\t\t// Simple selectivity estimation\n\t\treturn 1 / (fieldStats.uniqueValues || 1);\n\t}\n\n\t/**\n\t * Get cardinality estimate for an index\n\t * @param {string} indexName - Index name\n\t * @returns {number} Cardinality estimate\n\t */\n\tgetIndexCardinality (indexName) {\n\t\tconst indexStats = this.indexStatistics.get(indexName);\n\n\t\treturn indexStats ? indexStats.cardinality : this.totalRecords;\n\t}\n\n\t/**\n\t * Update field statistics\n\t * @param {Map} records - Record data\n\t * @private\n\t */\n\t_updateFieldStatistics (records) {\n\t\tconst fieldData = new Map();\n\n\t\t// Collect field data\n\t\tfor (const record of records.values()) {\n\t\t\tfor (const [fieldName, value] of Object.entries(record)) {\n\t\t\t\tif (!fieldData.has(fieldName)) {\n\t\t\t\t\tfieldData.set(fieldName, {\n\t\t\t\t\t\tvalues: new Set(),\n\t\t\t\t\t\tnullCount: 0,\n\t\t\t\t\t\ttotalLength: 0,\n\t\t\t\t\t\tcount: 0\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst data = fieldData.get(fieldName);\n\t\t\t\tdata.count++;\n\n\t\t\t\tif (value === null || value === undefined) {\n\t\t\t\t\tdata.nullCount++;\n\t\t\t\t} else {\n\t\t\t\t\tdata.values.add(value);\n\t\t\t\t\tif (typeof value === \"string\") {\n\t\t\t\t\t\tdata.totalLength += value.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Convert to statistics\n\t\tfor (const [fieldName, data] of fieldData) {\n\t\t\tthis.fieldStatistics.set(fieldName, {\n\t\t\t\tuniqueValues: data.values.size,\n\t\t\t\tnullCount: data.nullCount,\n\t\t\t\tdataType: this._inferDataType(data.values),\n\t\t\t\tavgLength: data.totalLength / data.count || 0,\n\t\t\t\tcardinality: data.values.size / this.totalRecords\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update index statistics\n\t * @param {Map} indexes - Index data\n\t * @private\n\t */\n\t_updateIndexStatistics (indexes) {\n\t\tfor (const [indexName, indexStorage] of indexes) {\n\t\t\tconst stats = indexStorage.getStats();\n\t\t\tthis.indexStatistics.set(indexName, {\n\t\t\t\tcardinality: stats.totalKeys,\n\t\t\t\tselectivity: stats.totalKeys / this.totalRecords || 1,\n\t\t\t\tavgEntriesPerKey: stats.totalEntries / stats.totalKeys || 1,\n\t\t\t\tmemoryUsage: stats.memoryUsage\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Infer data type from values\n\t * @param {Set} values - Set of values\n\t * @returns {string} Inferred data type\n\t * @private\n\t */\n\t_inferDataType (values) {\n\t\tconst sample = Array.from(values).slice(0, 10);\n\t\tconst types = new Set(sample.map(v => typeof v));\n\n\t\tif (types.size === 1) {\n\t\t\treturn types.values().next().value;\n\t\t}\n\n\t\treturn \"mixed\";\n\t}\n}\n\n/**\n * Query optimizer that creates efficient execution plans\n */\nexport class QueryOptimizer {\n\t/**\n\t * @param {Object} [options={}] - Optimizer options\n\t * @param {boolean} [options.collectStatistics=true] - Whether to collect query statistics\n\t * @param {number} [options.statisticsUpdateInterval=1000] - How often to update statistics (queries)\n\t */\n\tconstructor (options = {}) {\n\t\tthis.options = {\n\t\t\tcollectStatistics: true,\n\t\t\tstatisticsUpdateInterval: 1000,\n\t\t\t...options\n\t\t};\n\n\t\tthis.statistics = new DataStatistics();\n\t\tthis.queryCounter = 0;\n\t\tthis.planCache = new Map();\n\t\tthis.executionHistory = [];\n\t\tthis.maxHistorySize = 1000;\n\t\tthis.cacheHits = 0;\n\t\tthis.totalCacheRequests = 0;\n\n\t\t// Cost model adjustments based on learning\n\t\tthis.costAdjustments = new Map([\n\t\t\t[\"INDEX_LOOKUP\", 1.0],\n\t\t\t[\"FULL_SCAN\", 1.0],\n\t\t\t[\"FILTER_EVALUATION\", 1.0],\n\t\t\t[\"SORT_OPERATION\", 1.0],\n\t\t\t[\"MEMORY_ACCESS\", 1.0],\n\t\t\t[\"COMPARISON\", 1.0],\n\t\t\t[\"REGEX_MATCH\", 1.0]\n\t\t]);\n\t\tthis.lastCostModelUpdate = new Date();\n\t}\n\n\t/**\n\t * Create an optimized query plan\n\t * @param {Object} query - Query object\n\t * @param {Object} context - Query context (available indexes, etc.)\n\t * @returns {QueryPlan} Optimized query plan\n\t */\n\tcreatePlan (query, context) {\n\t\tconst queryId = `query_${++this.queryCounter}`;\n\t\tconst plan = new QueryPlan(queryId, query);\n\n\t\t// Track cache request\n\t\tthis.totalCacheRequests++;\n\n\t\t// Check plan cache first\n\t\tconst cacheKey = this._generateCacheKey(query);\n\t\tconst cachedPlan = this.planCache.get(cacheKey);\n\t\tif (cachedPlan && this._isCacheValid(cachedPlan)) {\n\t\t\t// Cache hit\n\t\t\tthis.cacheHits++;\n\n\t\t\treturn this._copyPlan(cachedPlan, queryId);\n\t\t}\n\n\t\t// Cache miss - create optimized plan\n\t\tthis._buildOptimizedPlan(plan, query, context);\n\n\t\t// Cache the plan\n\t\tthis.planCache.set(cacheKey, plan);\n\n\t\treturn plan;\n\t}\n\n\t/**\n\t * Update statistics with current data\n\t * @param {Map} records - Current records\n\t * @param {Map} indexes - Current indexes\n\t */\n\tupdateStatistics (records, indexes) {\n\t\tthis.statistics.update(records, indexes);\n\t}\n\n\t/**\n\t * Record plan execution for learning\n\t * @param {QueryPlan} plan - Executed plan\n\t */\n\trecordExecution (plan) {\n\t\tif (!this.options.collectStatistics) return;\n\n\t\tthis.executionHistory.push(plan.getStats());\n\n\t\t// Limit history size\n\t\tif (this.executionHistory.length > this.maxHistorySize) {\n\t\t\tthis.executionHistory.shift();\n\t\t}\n\n\t\t// Periodically update statistics\n\t\tif (this.queryCounter % this.options.statisticsUpdateInterval === 0) {\n\t\t\tthis._updateCostModel();\n\t\t}\n\t}\n\n\t/**\n\t * Get optimal execution strategy for a query\n\t * @param {Object} query - Query object\n\t * @param {Object} context - Available indexes and options\n\t * @returns {Object} Execution strategy\n\t */\n\tgetOptimalStrategy (query, context) {\n\t\tconst strategies = this._generateStrategies(query, context);\n\n\t\t// Estimate costs for each strategy\n\t\tconst costedStrategies = strategies.map(strategy => ({\n\t\t\t...strategy,\n\t\t\testimatedCost: this._estimateStrategyCost(strategy)\n\t\t}));\n\n\t\t// Sort by estimated cost\n\t\tcostedStrategies.sort((a, b) => a.estimatedCost - b.estimatedCost);\n\n\t\treturn costedStrategies[0] || { type: \"full_scan\", estimatedCost: this._getAdjustedCostFactor(\"FULL_SCAN\") * this.statistics.totalRecords };\n\t}\n\n\t/**\n\t * Get optimizer statistics\n\t * @returns {Object} Optimizer statistics\n\t */\n\tgetStats () {\n\t\treturn {\n\t\t\tqueryCounter: this.queryCounter,\n\t\t\tplanCacheSize: this.planCache.size,\n\t\t\texecutionHistorySize: this.executionHistory.length,\n\t\t\tdataStatistics: {\n\t\t\t\ttotalRecords: this.statistics.totalRecords,\n\t\t\t\tlastUpdated: this.statistics.lastUpdated,\n\t\t\t\tindexCount: this.statistics.indexStatistics.size,\n\t\t\t\tfieldCount: this.statistics.fieldStatistics.size\n\t\t\t},\n\t\t\taverageQueryCost: this._calculateAverageQueryCost(),\n\t\t\tcacheHitRate: this._calculateCacheHitRate(),\n\t\t\tcacheStatistics: {\n\t\t\t\ttotalRequests: this.totalCacheRequests,\n\t\t\t\thits: this.cacheHits,\n\t\t\t\tmisses: this.totalCacheRequests - this.cacheHits,\n\t\t\t\thitRate: this._calculateCacheHitRate()\n\t\t\t},\n\t\t\tcostModel: {\n\t\t\t\tadjustments: Object.fromEntries(this.costAdjustments),\n\t\t\t\tlastUpdated: this.lastCostModelUpdate\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Clear optimizer caches and history\n\t */\n\tclear () {\n\t\tthis.planCache.clear();\n\t\tthis.executionHistory = [];\n\t\tthis.queryCounter = 0;\n\t\tthis.cacheHits = 0;\n\t\tthis.totalCacheRequests = 0;\n\n\t\t// Reset cost adjustments to default values\n\t\tthis.costAdjustments.clear();\n\t\tthis.costAdjustments.set(\"INDEX_LOOKUP\", 1.0);\n\t\tthis.costAdjustments.set(\"FULL_SCAN\", 1.0);\n\t\tthis.costAdjustments.set(\"FILTER_EVALUATION\", 1.0);\n\t\tthis.costAdjustments.set(\"SORT_OPERATION\", 1.0);\n\t\tthis.costAdjustments.set(\"MEMORY_ACCESS\", 1.0);\n\t\tthis.costAdjustments.set(\"COMPARISON\", 1.0);\n\t\tthis.costAdjustments.set(\"REGEX_MATCH\", 1.0);\n\t\tthis.lastCostModelUpdate = new Date();\n\t}\n\n\t/**\n\t * Build optimized execution plan\n\t * @param {QueryPlan} plan - Plan to build\n\t * @param {Object} query - Query object\n\t * @param {Object} context - Query context\n\t * @private\n\t */\n\t_buildOptimizedPlan (plan, query, context) {\n\t\tconst strategy = this.getOptimalStrategy(query, context);\n\n\t\tswitch (strategy.type) {\n\t\t\tcase \"index_lookup\":\n\t\t\t\tthis._addIndexLookupSteps(plan, strategy);\n\t\t\t\tbreak;\n\t\t\tcase \"filtered_scan\":\n\t\t\t\tthis._addFilteredScanSteps(plan, query, strategy);\n\t\t\t\tbreak;\n\t\t\tcase \"full_scan\":\n\t\t\t\tthis._addFullScanSteps(plan);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis._addFullScanSteps(plan);\n\t\t}\n\n\t\t// Add post-processing steps\n\t\tthis._addPostProcessingSteps(plan, query);\n\t}\n\n\t/**\n\t * Add index lookup steps to plan\n\t * @param {QueryPlan} plan - Query plan\n\t * @param {Object} strategy - Execution strategy\n\t * @private\n\t */\n\t_addIndexLookupSteps (plan, strategy) {\n\t\tconst step = new QueryPlanStep(\n\t\t\t\"index_lookup\",\n\t\t\t{\n\t\t\t\tindexName: strategy.indexName,\n\t\t\t\tlookupKey: strategy.lookupKey\n\t\t\t},\n\t\t\tthis._getAdjustedCostFactor(\"INDEX_LOOKUP\"),\n\t\t\tthis._estimateIndexLookupRows(strategy.indexName)\n\t\t);\n\n\t\tplan.addStep(step);\n\t}\n\n\t/**\n\t * Add filtered scan steps to plan\n\t * @param {QueryPlan} plan - Query plan\n\t * @param {Object} query - Query object\n\t * @param {Object} strategy - Execution strategy\n\t * @private\n\t */\n\t_addFilteredScanSteps (plan, query, strategy) {\n\t\t// First, index lookup for partial filtering\n\t\tif (strategy.indexName) {\n\t\t\tthis._addIndexLookupSteps(plan, strategy);\n\t\t}\n\n\t\t// Then, filter remaining records\n\t\tconst filterStep = new QueryPlanStep(\n\t\t\t\"filter\",\n\t\t\t{ predicate: query.filter || query.where },\n\t\t\tthis._getAdjustedCostFactor(\"FILTER_EVALUATION\") * this.statistics.totalRecords,\n\t\t\tthis.statistics.totalRecords * 0.1 // Assume 10% selectivity\n\t\t);\n\n\t\tplan.addStep(filterStep);\n\t}\n\n\t/**\n\t * Add full scan steps to plan\n\t * @param {QueryPlan} plan - Query plan\n\t * @private\n\t */\n\t_addFullScanSteps (plan) {\n\t\tconst step = new QueryPlanStep(\n\t\t\t\"full_scan\",\n\t\t\t{ scanType: \"sequential\" },\n\t\t\tthis._getAdjustedCostFactor(\"FULL_SCAN\") * this.statistics.totalRecords,\n\t\t\tthis.statistics.totalRecords\n\t\t);\n\n\t\tplan.addStep(step);\n\t}\n\n\t/**\n\t * Add post-processing steps (sort, limit, etc.)\n\t * @param {QueryPlan} plan - Query plan\n\t * @param {Object} query - Query object\n\t * @private\n\t */\n\t_addPostProcessingSteps (plan, query) {\n\t\t// Add sort step if needed\n\t\tif (query.sort || query.sortBy) {\n\t\t\tconst sortStep = new QueryPlanStep(\n\t\t\t\t\"sort\",\n\t\t\t\t{ sortField: query.sortBy, sortFunction: query.sort },\n\t\t\t\tthis._getAdjustedCostFactor(\"SORT_OPERATION\") * plan.totalEstimatedRows,\n\t\t\t\tplan.totalEstimatedRows\n\t\t\t);\n\t\t\tplan.addStep(sortStep);\n\t\t}\n\n\t\t// Add limit step if needed\n\t\tif (query.limit) {\n\t\t\tconst limitStep = new QueryPlanStep(\n\t\t\t\t\"limit\",\n\t\t\t\t{ offset: query.offset || 0, max: query.limit },\n\t\t\t\tthis._getAdjustedCostFactor(\"MEMORY_ACCESS\"),\n\t\t\t\tMath.min(query.limit, plan.totalEstimatedRows)\n\t\t\t);\n\t\t\tplan.addStep(limitStep);\n\t\t}\n\t}\n\n\t/**\n\t * Generate possible execution strategies\n\t * @param {Object} query - Query object\n\t * @param {Object} context - Available indexes and options\n\t * @returns {Array} Array of possible strategies\n\t * @private\n\t */\n\t_generateStrategies (query, context) {\n\t\tconst strategies = [];\n\n\t\t// Strategy 1: Full scan (always available)\n\t\tstrategies.push({ type: \"full_scan\" });\n\n\t\t// Strategy 2: Index-based lookup\n\t\tif (query.find && context.indexManager) {\n\t\t\tconst fields = Object.keys(query.find);\n\t\t\tconst optimalIndex = context.indexManager.getOptimalIndex(fields);\n\n\t\t\tif (optimalIndex) {\n\t\t\t\tstrategies.push({\n\t\t\t\t\ttype: \"index_lookup\",\n\t\t\t\t\tindexName: optimalIndex,\n\t\t\t\t\tlookupKey: this._generateLookupKey(query.find, fields)\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Strategy 3: Filtered scan with partial index\n\t\tif ((query.filter || query.where) && context.indexManager) {\n\t\t\tconst availableIndexes = context.indexManager.listIndexes();\n\n\t\t\tfor (const indexName of availableIndexes) {\n\t\t\t\tstrategies.push({\n\t\t\t\t\ttype: \"filtered_scan\",\n\t\t\t\t\tindexName,\n\t\t\t\t\tpartialFilter: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn strategies;\n\t}\n\n\t/**\n\t * Estimate cost of an execution strategy\n\t * @param {Object} strategy - Execution strategy\n\t * @returns {number} Estimated cost\n\t * @private\n\t */\n\t_estimateStrategyCost (strategy) {\n\t\tswitch (strategy.type) {\n\t\t\tcase \"index_lookup\":\n\t\t\t\treturn this._getAdjustedCostFactor(\"INDEX_LOOKUP\") +\n\t\t\t\t\tthis._estimateIndexLookupRows(strategy.indexName, strategy.lookupKey) * this._getAdjustedCostFactor(\"MEMORY_ACCESS\");\n\n\t\t\tcase \"filtered_scan\": {\n\t\t\t\tconst indexCost = strategy.indexName ? this._getAdjustedCostFactor(\"INDEX_LOOKUP\") : 0;\n\t\t\t\tconst filterCost = this._getAdjustedCostFactor(\"FILTER_EVALUATION\") * this.statistics.totalRecords;\n\n\t\t\t\treturn indexCost + filterCost;\n\t\t\t}\n\n\t\t\tcase \"full_scan\":\n\t\t\t\treturn this._getAdjustedCostFactor(\"FULL_SCAN\") * this.statistics.totalRecords;\n\n\t\t\tdefault:\n\t\t\t\treturn Number.MAX_SAFE_INTEGER;\n\t\t}\n\t}\n\n\t/**\n\t * Get cost factor adjusted by learned performance data\n\t * @param {string} factorName - Name of the cost factor\n\t * @returns {number} Adjusted cost factor\n\t * @private\n\t */\n\t_getAdjustedCostFactor (factorName) {\n\t\tconst baseCost = CostFactors[factorName] || 1;\n\t\tconst adjustment = this.costAdjustments.get(factorName) || 1.0;\n\n\t\treturn baseCost * adjustment;\n\t}\n\n\t/**\n\t * Estimate number of rows returned by index lookup\n\t * @param {string} indexName - Index name\n\t * @returns {number} Estimated row count\n\t * @private\n\t */\n\t_estimateIndexLookupRows (indexName) {\n\t\tconst indexStats = this.statistics.indexStatistics.get(indexName);\n\t\tif (!indexStats) {\n\t\t\treturn this.statistics.totalRecords * 0.1; // Default 10%\n\t\t}\n\n\t\treturn Math.max(1, this.statistics.totalRecords / indexStats.cardinality);\n\t}\n\n\t/**\n\t * Generate cache key for query\n\t * @param {Object} query - Query object\n\t * @returns {string} Cache key\n\t * @private\n\t */\n\t_generateCacheKey (query) {\n\t\treturn JSON.stringify(query);\n\t}\n\n\t/**\n\t * Check if cached plan is still valid\n\t * @param {QueryPlan} cachedPlan - Cached plan\n\t * @returns {boolean} True if cache is valid\n\t * @private\n\t */\n\t_isCacheValid (cachedPlan) {\n\t\t// Simple cache invalidation based on time\n\t\tconst maxAge = 5 * 60 * 1000; // 5 minutes\n\n\t\treturn Date.now() - cachedPlan.createdAt.getTime() < maxAge;\n\t}\n\n\t/**\n\t * Copy a cached plan with new ID\n\t * @param {QueryPlan} originalPlan - Original plan\n\t * @param {string} newQueryId - New query ID\n\t * @returns {QueryPlan} Copied plan\n\t * @private\n\t */\n\t_copyPlan (originalPlan, newQueryId) {\n\t\tconst newPlan = new QueryPlan(newQueryId, originalPlan.originalQuery);\n\n\t\tfor (const step of originalPlan.steps) {\n\t\t\tconst newStep = new QueryPlanStep(\n\t\t\t\tstep.operation,\n\t\t\t\tstep.options,\n\t\t\t\tstep.estimatedCost,\n\t\t\t\tstep.estimatedRows\n\t\t\t);\n\t\t\tnewPlan.addStep(newStep);\n\t\t}\n\n\t\treturn newPlan;\n\t}\n\n\t/**\n\t * Generate lookup key from query criteria\n\t * @param {Object} criteria - Query criteria\n\t * @param {string[]} fields - Field names\n\t * @returns {string} Lookup key\n\t * @private\n\t */\n\t_generateLookupKey (criteria, fields) {\n\t\treturn fields.sort().map(field => String(criteria[field])).join(\"|\");\n\t}\n\n\t/**\n\t * Update cost model based on execution history\n\t * @private\n\t */\n\t_updateCostModel () {\n\t\tif (this.executionHistory.length < 10) {\n\t\t\treturn; // Need sufficient data for meaningful analysis\n\t\t}\n\n\t\tthis.lastCostModelUpdate = new Date();\n\n\t\t// Analyze each operation type separately\n\t\tconst operationStats = this._analyzeOperationPerformance();\n\n\t\t// Update cost adjustments based on performance analysis\n\t\tfor (const [operation, stats] of operationStats) {\n\t\t\tif (stats.sampleSize >= 3) { // Only process operations with sufficient data\n\t\t\t\tconst currentAdjustment = this.costAdjustments.get(operation) || 1.0;\n\t\t\t\tlet newAdjustment = currentAdjustment;\n\n\t\t\t\t// Calculate performance ratio (actual vs estimated)\n\t\t\t\tconst performanceRatio = stats.avgActualCost / stats.avgEstimatedCost;\n\n\t\t\t\tif (stats.consistency > 0.7) { // Only adjust if performance is consistent\n\t\t\t\t\t// Gradually adjust towards the observed performance\n\t\t\t\t\tconst learningRate = 0.1; // Conservative learning rate\n\t\t\t\t\tnewAdjustment = currentAdjustment * (1 + learningRate * (performanceRatio - 1));\n\n\t\t\t\t\t// Clamp adjustments to reasonable bounds\n\t\t\t\t\tnewAdjustment = Math.max(0.1, Math.min(10.0, newAdjustment));\n\n\t\t\t\t\tthis.costAdjustments.set(operation, newAdjustment);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Clear old execution history to prevent memory bloat\n\t\tif (this.executionHistory.length > this.maxHistorySize * 0.8) {\n\t\t\tthis.executionHistory = this.executionHistory.slice(-Math.floor(this.maxHistorySize * 0.6));\n\t\t}\n\t}\n\n\t/**\n\t * Analyze operation performance from execution history\n\t * @returns {Map} Map of operation -> performance statistics\n\t * @private\n\t */\n\t_analyzeOperationPerformance () {\n\t\tconst operationStats = new Map();\n\n\t\t// Process each execution in history\n\t\tfor (const execution of this.executionHistory) {\n\t\t\tif (execution.steps && Array.isArray(execution.steps)) {\n\t\t\t\t// Analyze each step in the execution\n\t\t\t\tfor (const step of execution.steps) {\n\t\t\t\t\tif (step.operation && step.actualCost !== null && step.estimatedCost !== 0) {\n\t\t\t\t\t\tconst operation = this._mapOperationToCostFactor(step.operation);\n\t\t\t\t\t\tif (operation) {\n\t\t\t\t\t\t\tif (!operationStats.has(operation)) {\n\t\t\t\t\t\t\t\toperationStats.set(operation, {\n\t\t\t\t\t\t\t\t\tsampleSize: 0,\n\t\t\t\t\t\t\t\t\ttotalActualCost: 0,\n\t\t\t\t\t\t\t\t\ttotalEstimatedCost: 0,\n\t\t\t\t\t\t\t\t\tcosts: [],\n\t\t\t\t\t\t\t\t\testimatedCosts: []\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst stats = operationStats.get(operation);\n\t\t\t\t\t\t\tstats.sampleSize++;\n\t\t\t\t\t\t\tstats.totalActualCost += step.actualCost;\n\t\t\t\t\t\t\tstats.totalEstimatedCost += step.estimatedCost;\n\t\t\t\t\t\t\tstats.costs.push(step.actualCost);\n\t\t\t\t\t\t\tstats.estimatedCosts.push(step.estimatedCost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Calculate derived statistics\n\t\tfor (const [, stats] of operationStats) {\n\t\t\tstats.avgActualCost = stats.totalActualCost / stats.sampleSize;\n\t\t\tstats.avgEstimatedCost = stats.totalEstimatedCost / stats.sampleSize;\n\n\t\t\t// Calculate consistency (inverse of coefficient of variation)\n\t\t\tconst variance = this._calculateVariance(stats.costs, stats.avgActualCost);\n\t\t\tconst stdDev = Math.sqrt(variance);\n\t\t\tconst coefficientOfVariation = stdDev / stats.avgActualCost;\n\t\t\tstats.consistency = Math.max(0, 1 - coefficientOfVariation);\n\n\t\t\t// Calculate accuracy (how close estimates were to actual)\n\t\t\tconst accuracyScores = stats.costs.map((actual, i) => {\n\t\t\t\tconst estimated = stats.estimatedCosts[i];\n\n\t\t\t\treturn 1 - Math.abs(actual - estimated) / Math.max(actual, estimated);\n\t\t\t});\n\t\t\tstats.accuracy = accuracyScores.reduce((sum, score) => sum + score, 0) / accuracyScores.length;\n\t\t}\n\n\t\treturn operationStats;\n\t}\n\n\t/**\n\t * Map step operation to cost factor name\n\t * @param {string} operation - Operation name from step\n\t * @returns {string|null} Cost factor name\n\t * @private\n\t */\n\t_mapOperationToCostFactor (operation) {\n\t\tconst mapping = {\n\t\t\t\"index_lookup\": \"INDEX_LOOKUP\",\n\t\t\t\"full_scan\": \"FULL_SCAN\",\n\t\t\t\"filter\": \"FILTER_EVALUATION\",\n\t\t\t\"sort\": \"SORT_OPERATION\",\n\t\t\t\"limit\": \"MEMORY_ACCESS\",\n\t\t\t\"regex\": \"REGEX_MATCH\"\n\t\t};\n\n\t\treturn mapping[operation] || null;\n\t}\n\n\t/**\n\t * Calculate variance of a set of values\n\t * @param {number[]} values - Array of values\n\t * @param {number} mean - Mean of the values\n\t * @returns {number} Variance\n\t * @private\n\t */\n\t_calculateVariance (values, mean) {\n\t\tif (values.length <= 1) return 0;\n\n\t\tconst squaredDifferences = values.map(value => Math.pow(value - mean, 2));\n\n\t\treturn squaredDifferences.reduce((sum, diff) => sum + diff, 0) / (values.length - 1);\n\t}\n\n\t/**\n\t * Calculate average query cost from history\n\t * @returns {number} Average query cost\n\t * @private\n\t */\n\t_calculateAverageQueryCost () {\n\t\tif (this.executionHistory.length === 0) return 0;\n\n\t\tconst totalCost = this.executionHistory.reduce((sum, plan) => sum + (plan.totalActualCost || 0), 0);\n\n\t\treturn totalCost / this.executionHistory.length;\n\t}\n\n\t/**\n\t * Calculate cache hit rate\n\t * @returns {number} Cache hit rate (0-1)\n\t * @private\n\t */\n\t_calculateCacheHitRate () {\n\t\tif (this.totalCacheRequests === 0) return 0;\n\n\t\treturn this.cacheHits / this.totalCacheRequests;\n\t}\n}\n","/**\n * Deep immutability implementation with structural sharing\n */\nexport class ImmutableStore {\n\t/**\n\t * @param {Map} [data] - Initial data\n\t */\n\tconstructor (data = new Map()) {\n\t\tthis._data = new Map();\n\t\t// Freeze all initial data\n\t\tfor (const [key, value] of data) {\n\t\t\tthis._data.set(key, this._deepFreeze(value));\n\t\t}\n\t\tObject.freeze(this);\n\t}\n\n\t/**\n\t * Get a frozen record\n\t * @param {string} key - Record key\n\t * @returns {Object|null} Frozen record or null\n\t */\n\tget (key) {\n\t\treturn this._data.get(key) || null;\n\t}\n\n\t/**\n\t * Update record in store\n\t * @param {string} key - Record key\n\t * @param {Object} record - Record data\n\t * @returns {ImmutableStore} This store instance\n\t */\n\tset (key, record) {\n\t\t// Early return if setting same value\n\t\tif (this._data.get(key) === record) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis._data.set(key, this._deepFreeze(record));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove record from store\n\t * @param {string} key - Record key to remove\n\t * @returns {ImmutableStore} This store instance\n\t */\n\tdelete (key) {\n\t\t// Early return if key doesn't exist\n\t\tif (!this._data.has(key)) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis._data.delete(key);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Check if record exists\n\t * @param {string} key - Record key\n\t * @returns {boolean} True if exists\n\t */\n\thas (key) {\n\t\treturn this._data.has(key);\n\t}\n\n\t/**\n\t * Get all keys\n\t * @returns {string[]} Array of keys\n\t */\n\tkeys () {\n\t\treturn Array.from(this._data.keys());\n\t}\n\n\t/**\n\t * Get all values as frozen objects\n\t * @returns {IterableIterator<Object>} Iterator of frozen values\n\t */\n\tvalues () {\n\t\treturn this._data.values();\n\t}\n\n\t/**\n\t * Get store size\n\t * @returns {number} Number of records\n\t */\n\tget size () {\n\t\treturn this._data.size;\n\t}\n\n\t/**\n\t * Get all entries\n\t * @returns {IterableIterator<[string, Object]>} Iterator of [key, value] pairs\n\t */\n\tentries () {\n\t\treturn this._data.entries();\n\t}\n\n\t/**\n\t * Deep freeze an object (iterative implementation)\n\t * @param {*} obj - Object to freeze\n\t * @returns {*} Frozen object\n\t * @private\n\t */\n\t_deepFreeze (obj) {\n\t\tif (obj === null || typeof obj !== \"object\" || Object.isFrozen(obj)) {\n\t\t\treturn obj;\n\t\t}\n\n\t\tconst stack = [obj];\n\t\tconst visited = new WeakSet();\n\n\t\twhile (stack.length > 0) {\n\t\t\tconst current = stack.pop();\n\n\t\t\tif (!visited.has(current) && !Object.isFrozen(current)) {\n\t\t\t\tvisited.add(current);\n\n\t\t\t\tif (Array.isArray(current)) {\n\t\t\t\t\tfor (const item of current) {\n\t\t\t\t\t\tif (item !== null && typeof item === \"object\" && !Object.isFrozen(item)) {\n\t\t\t\t\t\t\tstack.push(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (const value of Object.values(current)) {\n\t\t\t\t\t\tif (value !== null && typeof value === \"object\" && !Object.isFrozen(value)) {\n\t\t\t\t\t\t\tstack.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tObject.freeze(current);\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t}\n}\n","/**\n * Streaming support for large datasets\n */\nexport class DataStream {\n\t/**\n\t * @param {Iterator} iterator - Data iterator\n\t * @param {Object} [options={}] - Stream options\n\t */\n\tconstructor (iterator, options = {}) {\n\t\tthis.iterator = iterator;\n\t\tthis.options = {\n\t\t\tbatchSize: 1000,\n\t\t\tbufferSize: 10000,\n\t\t\t...options\n\t\t};\n\t\tthis.buffer = [];\n\t\tthis.ended = false;\n\t\tthis.position = 0;\n\t}\n\n\t/**\n\t * Read next batch of records\n\t * @param {number} [size] - Batch size\n\t * @returns {Promise<Record[]>} Array of records\n\t */\n\tasync read (size = this.options.batchSize) {\n\t\tconst batch = [];\n\n\t\twhile (batch.length < size && !this.ended) {\n\t\t\tconst { value, done } = this.iterator.next();\n\n\t\t\tif (done) {\n\t\t\t\tthis.ended = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbatch.push(value);\n\t\t\tthis.position++;\n\t\t}\n\n\t\treturn batch;\n\t}\n\n\t/**\n\t * Read all remaining records\n\t * @returns {Promise<Record[]>} All records\n\t */\n\tasync readAll () {\n\t\tconst records = [];\n\n\t\twhile (!this.ended) {\n\t\t\tconst batch = await this.read();\n\t\t\trecords.push(...batch);\n\t\t}\n\n\t\treturn records;\n\t}\n\n\t/**\n\t * Apply transformation to stream\n\t * @param {Function} transform - Transform function\n\t * @returns {DataStream} New transformed stream\n\t */\n\tmap (transform) {\n\t\tconst transformedIterator = {\n\t\t\tnext: () => {\n\t\t\t\tconst { value, done } = this.iterator.next();\n\n\t\t\t\treturn done ? { done: true } : { value: transform(value), done: false };\n\t\t\t}\n\t\t};\n\n\t\treturn new DataStream(transformedIterator, this.options);\n\t}\n\n\t/**\n\t * Filter stream records\n\t * @param {Function} predicate - Filter predicate\n\t * @returns {DataStream} New filtered stream\n\t */\n\tfilter (predicate) {\n\t\tconst filteredIterator = {\n\t\t\tnext: () => {\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst { value, done } = this.iterator.next();\n\t\t\t\t\tif (done) return { done: true };\n\t\t\t\t\tif (predicate(value)) return { value, done: false };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\treturn new DataStream(filteredIterator, this.options);\n\t}\n\n\t/**\n\t * Take limited number of records\n\t * @param {number} limit - Maximum records\n\t * @returns {DataStream} New limited stream\n\t */\n\ttake (limit) {\n\t\tlet count = 0;\n\t\tconst limitedIterator = {\n\t\t\tnext: () => {\n\t\t\t\tif (count >= limit) return { done: true };\n\t\t\t\tconst { value, done } = this.iterator.next();\n\t\t\t\tif (done) return { done: true };\n\t\t\t\tcount++;\n\n\t\t\t\treturn { value, done: false };\n\t\t\t}\n\t\t};\n\n\t\treturn new DataStream(limitedIterator, this.options);\n\t}\n\n\t/**\n\t * Get stream statistics\n\t * @returns {Object} Stream statistics\n\t */\n\tgetStats () {\n\t\treturn {\n\t\t\tposition: this.position,\n\t\t\tended: this.ended,\n\t\t\tbufferSize: this.buffer.length,\n\t\t\toptions: this.options\n\t\t};\n\t}\n}\n","import { ImmutableStore } from \"./immutable-store.js\";\n\n/**\n * Manages storage operations with support for both mutable and immutable stores\n */\nexport class StorageManager {\n\t/**\n\t * @param {Object} config - Storage configuration\n\t */\n\tconstructor (config = {}) {\n\t\tthis.config = {\n\t\t\timmutable: false,\n\t\t\t...config\n\t\t};\n\n\t\t// Initialize storage based on configuration\n\t\tif (this.config.immutable) {\n\t\t\tthis._store = new ImmutableStore();\n\t\t} else {\n\t\t\tthis._store = new Map();\n\t\t}\n\t}\n\n\t/**\n\t * Get a record from storage\n\t * @param {string} key - Record key\n\t * @returns {Object|null} Record data or null\n\t */\n\tget (key) {\n\t\treturn this._store.get(key) || null;\n\t}\n\n\t/**\n\t * Set a record in storage\n\t * @param {string} key - Record key\n\t * @param {Object} data - Record data\n\t * @returns {boolean} Success status\n\t */\n\tset (key, data) {\n\t\tif (this.config.immutable) {\n\t\t\tthis._store = this._store.set(key, data);\n\t\t} else {\n\t\t\tthis._store.set(key, data);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Delete a record from storage\n\t * @param {string} key - Record key\n\t * @returns {boolean} Success status\n\t */\n\tdelete (key) {\n\t\tif (this.config.immutable) {\n\t\t\tthis._store = this._store.delete(key);\n\t\t} else {\n\t\t\tthis._store.delete(key);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check if record exists in storage\n\t * @param {string} key - Record key\n\t * @returns {boolean} True if exists\n\t */\n\thas (key) {\n\t\treturn this._store.has(key);\n\t}\n\n\t/**\n\t * Get all storage keys\n\t * @returns {string[]} Array of keys\n\t */\n\tkeys () {\n\t\tif (this.config.immutable) {\n\t\t\treturn this._store.keys();\n\t\t}\n\n\t\treturn Array.from(this._store.keys());\n\t}\n\n\t/**\n\t * Get all storage values\n\t * @returns {IterableIterator<Object>} Iterable of values\n\t */\n\tvalues () {\n\t\treturn this._store.values();\n\t}\n\n\t/**\n\t * Get all storage entries\n\t * @returns {Array<[string, Object]>} Array of [key, value] pairs\n\t */\n\tentries () {\n\t\treturn Array.from(this._store.entries());\n\t}\n\n\t/**\n\t * Get storage size\n\t * @returns {number} Number of records\n\t */\n\tget size () {\n\t\treturn this._store.size;\n\t}\n\n\t/**\n\t * Clear all storage\n\t */\n\tclear () {\n\t\tif (this.config.immutable) {\n\t\t\tthis._store = new ImmutableStore();\n\t\t} else {\n\t\t\tthis._store.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Override storage with bulk data (maximum performance)\n\t * @param {Array<[string, Object]>} data - Array of [key, value] pairs\n\t * @returns {boolean} Success status\n\t */\n\toverride (data) {\n\t\ttry {\n\t\t\tif (this.config.immutable) {\n\t\t\t\t// Create new ImmutableStore from data\n\t\t\t\tthis._store = new ImmutableStore(new Map(data));\n\t\t\t} else {\n\t\t\t\t// Direct Map construction from 2D array\n\t\t\t\tthis._store = new Map(data);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Get underlying store (for compatibility)\n\t * @returns {Map|ImmutableStore} The underlying store\n\t */\n\tgetStore () {\n\t\treturn this._store;\n\t}\n\n\t/**\n\t * Estimate storage memory usage\n\t * @returns {number} Estimated bytes\n\t */\n\testimateMemoryUsage () {\n\t\tlet dataSize = 0;\n\t\tfor (const [key, value] of this.entries()) {\n\t\t\tdataSize += JSON.stringify({ key, value }).length * 2; // UTF-16 estimate\n\t\t}\n\n\t\treturn dataSize;\n\t}\n}\n","import { randomUUID as uuid } from \"crypto\";\nimport { ValidationError, RecordNotFoundError, HaroError } from \"./errors.js\";\nimport { RecordFactory } from \"./record.js\";\n\n/**\n * Manages CRUD operations with validation and error handling\n */\nexport class CRUDManager {\n\t/**\n\t * @param {Object} dependencies - Required dependencies\n\t * @param {StorageManager} dependencies.storageManager - Storage manager\n\t * @param {IndexManager} dependencies.indexManager - Index manager\n\t * @param {VersionManager} [dependencies.versionManager] - Version manager\n\t * @param {Object} dependencies.config - Configuration\n\t */\n\tconstructor ({ storageManager, indexManager, versionManager = null, config }) {\n\t\tthis.storageManager = storageManager;\n\t\tthis.indexManager = indexManager;\n\t\tthis.versionManager = versionManager;\n\t\tthis.config = config;\n\t}\n\n\t/**\n\t * Set or update a record with comprehensive validation and error handling\n\t * @param {string|null} key - Record key or null for auto-generation\n\t * @param {Object} [data={}] - Record data\n\t * @param {Object} [options={}] - Operation options\n\t * @returns {Record} Created/updated record\n\t * @throws {ValidationError} If data validation fails\n\t */\n\tset (key, data = {}, options = {}) {\n\t\ttry {\n\t\t\tconst {\n\t\t\t\toverride = false,\n\t\t\t\tvalidate = true\n\t\t\t} = options;\n\n\t\t\t// Generate key if not provided\n\t\t\tif (key === null) {\n\t\t\t\tkey = data[this.config.key] ?? uuid();\n\t\t\t}\n\n\t\t\t// OPTIMIZATION: Only create new object when key needs to be added\n\t\t\tlet recordData;\n\t\t\tif (data[this.config.key] === key) {\n\t\t\t\trecordData = data;\n\t\t\t} else {\n\t\t\t\t// Create new object only when necessary, but don't mutate original\n\t\t\t\trecordData = { ...data, [this.config.key]: key };\n\t\t\t}\n\n\t\t\t// Validate against schema if configured\n\t\t\tif (validate && this.config.schema) {\n\t\t\t\tthis.config.schema.validate(recordData);\n\t\t\t}\n\n\t\t\t// OPTIMIZATION: Single storage lookup instead of has() + get()\n\t\t\tconst existingRecord = this.storageManager.get(key);\n\t\t\tlet finalData = recordData;\n\n\t\t\t// Handle merging vs override\n\t\t\tif (existingRecord && !override) {\n\t\t\t\tfinalData = this._mergeRecords(existingRecord, recordData);\n\t\t\t}\n\n\t\t\t// Store version if versioning enabled\n\t\t\tif (this.versionManager && existingRecord) {\n\t\t\t\tthis.versionManager.addVersion(key, existingRecord);\n\t\t\t}\n\n\t\t\t// Update indexes\n\t\t\tif (existingRecord) {\n\t\t\t\tthis.indexManager.removeRecord(key, existingRecord);\n\t\t\t}\n\t\t\tthis.indexManager.addRecord(key, finalData);\n\n\t\t\t// Store record\n\t\t\tthis.storageManager.set(key, finalData);\n\n\t\t\t// OPTIMIZATION: Create record wrapper without expensive metadata by default\n\t\t\tconst record = RecordFactory.create(key, finalData, {}, false);\n\n\t\t\treturn record;\n\n\t\t} catch (error) {\n\t\t\tif (error instanceof HaroError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new ValidationError(`Failed to set record: ${error.message}`, \"record\", data);\n\t\t}\n\t}\n\n\t/**\n\t * Get a record by key with consistent return format\n\t * @param {string} key - Record key\n\t * @param {Object} [options={}] - Get options\n\t * @returns {Record|null} Record instance or null if not found\n\t */\n\tget (key, options = {}) {\n\t\tconst { includeVersions = false } = options;\n\n\t\tconst recordData = this.storageManager.get(key);\n\n\t\tif (!recordData) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Optimized: only create full Record with metadata if versioning is requested\n\t\tif (includeVersions && this.versionManager) {\n\t\t\tconst history = this.versionManager.getHistory(key);\n\t\t\tif (history) {\n\t\t\t\tconst metadata = { versions: history.versions };\n\n\t\t\t\treturn RecordFactory.create(key, recordData, metadata);\n\t\t\t}\n\t\t}\n\n\t\t// Default: create Record without expensive metadata operations\n\t\treturn RecordFactory.create(key, recordData);\n\t}\n\n\t/**\n\t * Delete a record with proper cleanup\n\t * @param {string} key - Record key\n\t * @param {Object} [options={}] - Delete options\n\t * @returns {boolean} True if deleted successfully\n\t * @throws {RecordNotFoundError} If record not found\n\t */\n\tdelete (key) {\n\t\tif (!this.storageManager.has(key)) {\n\t\t\tthrow new RecordNotFoundError(key, this.config.id);\n\t\t}\n\n\t\tconst recordData = this.storageManager.get(key);\n\n\t\t// Remove from indexes\n\t\tthis.indexManager.removeRecord(key, recordData);\n\n\t\t// Remove from store\n\t\tthis.storageManager.delete(key);\n\n\t\t// Cleanup versions\n\t\tif (this.versionManager) {\n\t\t\tthis.versionManager.disableVersioning(key);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check if record exists\n\t * @param {string} key - Record key\n\t * @returns {boolean} True if record exists\n\t */\n\thas (key) {\n\t\treturn this.storageManager.has(key);\n\t}\n\n\t/**\n\t * Merge two records\n\t * @param {Object} existing - Existing record\n\t * @param {Object} updates - Updates to apply\n\t * @returns {Object} Merged record\n\t * @private\n\t */\n\t_mergeRecords (existing, updates) {\n\t\tif (Array.isArray(existing) && Array.isArray(updates)) {\n\t\t\treturn [...existing, ...updates];\n\t\t}\n\n\t\tif (typeof existing === \"object\" && typeof updates === \"object\") {\n\t\t\tconst merged = { ...existing };\n\t\t\tfor (const [key, value] of Object.entries(updates)) {\n\t\t\t\tif (typeof value === \"object\" && value !== null && !Array.isArray(value) &&\n\t\t\t\t\ttypeof existing[key] === \"object\" && existing[key] !== null && !Array.isArray(existing[key])) {\n\t\t\t\t\tmerged[key] = this._mergeRecords(existing[key], value);\n\t\t\t\t} else {\n\t\t\t\t\tmerged[key] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn merged;\n\t\t}\n\n\t\treturn updates;\n\t}\n}\n","import { QueryError } from \"./errors.js\";\nimport { RecordCollection, RecordFactory } from \"./record.js\";\n\n/**\n * Manages complex querying operations and criteria matching\n */\nexport class QueryManager {\n\t/**\n\t * @param {Object} dependencies - Required dependencies\n\t * @param {StorageManager} dependencies.storageManager - Storage manager\n\t * @param {IndexManager} dependencies.indexManager - Index manager\n\t * @param {QueryOptimizer} [dependencies.queryOptimizer] - Query optimizer\n\t */\n\tconstructor ({ storageManager, indexManager, queryOptimizer = null }) {\n\t\tthis.storageManager = storageManager;\n\t\tthis.indexManager = indexManager;\n\t\tthis.queryOptimizer = queryOptimizer;\n\t}\n\n\t/**\n\t * Find records using optimized queries\n\t * @param {Object} [criteria={}] - Search criteria\n\t * @param {Object} [options={}] - Query options\n\t * @returns {RecordCollection} Collection of matching records\n\t */\n\tfind (criteria = {}, options = {}) {\n\t\tconst {\n\t\t\tlimit,\n\t\t\toffset = 0\n\t\t} = options;\n\n\t\ttry {\n\t\t\t// Create query plan if optimizer is available\n\t\t\tlet plan = null;\n\t\t\tif (this.queryOptimizer) {\n\t\t\t\tconst query = { find: criteria, limit, offset };\n\t\t\t\tconst context = { indexManager: this.indexManager };\n\t\t\t\tplan = this.queryOptimizer.createPlan(query, context);\n\t\t\t\tplan.startExecution();\n\t\t\t}\n\n\t\t\t// Use index if available\n\t\t\tconst fields = Object.keys(criteria);\n\t\t\tconst optimalIndex = this.indexManager.getOptimalIndex(fields);\n\n\t\t\tlet recordKeys;\n\t\t\tif (optimalIndex) {\n\t\t\t\trecordKeys = this.indexManager.findByCriteria(criteria);\n\t\t\t} else {\n\t\t\t\t// Fallback to full scan\n\t\t\t\trecordKeys = new Set(this.storageManager.keys());\n\t\t\t}\n\n\t\t\t// Optimized: cache data during filtering to avoid double storage access\n\t\t\tconst matchingRecords = [];\n\t\t\tfor (const key of recordKeys) {\n\t\t\t\tconst recordData = this.storageManager.get(key);\n\t\t\t\tif (this._matchesCriteria(recordData, criteria)) {\n\t\t\t\t\t// Store both key and data to avoid second lookup\n\t\t\t\t\tmatchingRecords.push({ key, data: recordData });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply pagination early to avoid creating unnecessary Records\n\t\t\tconst start = offset;\n\t\t\tconst end = limit ? start + limit : matchingRecords.length;\n\t\t\tconst paginatedRecords = matchingRecords.slice(start, end);\n\n\t\t\t// Create Records from cached data (no additional storage access needed)\n\t\t\tconst records = paginatedRecords.map(({ key, data }) => {\n\t\t\t\treturn RecordFactory.create(key, data);\n\t\t\t});\n\n\t\t\tif (plan) {\n\t\t\t\tplan.completeExecution(records.length);\n\t\t\t\tthis.queryOptimizer.recordExecution(plan);\n\t\t\t}\n\n\t\t\treturn new RecordCollection(records);\n\n\t\t} catch (error) {\n\t\t\tthrow new QueryError(`Find operation failed: ${error.message}`, criteria, \"find\");\n\t\t}\n\t}\n\n\t/**\n\t * Advanced filtering with predicate logic\n\t * @param {Function|Object} predicate - Filter predicate\n\t * @param {Object} [options={}] - Filter options\n\t * @returns {RecordCollection} Filtered records\n\t */\n\twhere (predicate, options = {}) {\n\t\ttry {\n\t\t\tif (typeof predicate === \"function\") {\n\t\t\t\treturn this._filterByFunction(predicate, options);\n\t\t\t}\n\n\t\t\tif (typeof predicate === \"object\" && predicate !== null) {\n\t\t\t\treturn this._filterByObject(predicate, options);\n\t\t\t}\n\n\t\t\tthrow new QueryError(\"Predicate must be a function or object\", predicate, \"where\");\n\n\t\t} catch (error) {\n\t\t\tthrow new QueryError(`Where operation failed: ${error.message}`, predicate, \"where\");\n\t\t}\n\t}\n\n\t/**\n\t * Check if record matches criteria\n\t * @param {Object} record - Record to check\n\t * @param {Object} criteria - Criteria object\n\t * @returns {boolean} True if matches\n\t * @private\n\t */\n\t_matchesCriteria (record, criteria) {\n\t\tfor (const [field, value] of Object.entries(criteria)) {\n\t\t\tconst recordValue = record[field];\n\n\t\t\tif (value instanceof RegExp) {\n\t\t\t\tif (!value.test(recordValue)) return false;\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\tif (Array.isArray(recordValue)) {\n\t\t\t\t\tif (!value.some(v => recordValue.includes(v))) return false;\n\t\t\t\t} else if (!value.includes(recordValue)) return false;\n\t\t\t} else if (recordValue !== value) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Filter by function predicate\n\t * @param {Function} predicate - Filter function\n\t * @param {Object} options - Filter options\n\t * @returns {RecordCollection} Filtered records\n\t * @private\n\t */\n\t_filterByFunction (predicate, options) {\n\t\tconst { limit, offset = 0 } = options;\n\t\tconst records = [];\n\n\t\tlet count = 0;\n\t\tfor (const [key, recordData] of this.storageManager.entries()) {\n\t\t\t// For backwards compatibility, pass plain objects to predicates\n\t\t\tif (predicate(recordData)) {\n\t\t\t\tif (count >= offset) {\n\t\t\t\t\trecords.push(RecordFactory.create(key, recordData));\n\t\t\t\t\tif (limit && records.length >= limit) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\treturn new RecordCollection(records);\n\t}\n\n\t/**\n\t * Filter by object predicate\n\t * @param {Object} predicate - Filter object\n\t * @param {Object} options - Filter options\n\t * @returns {RecordCollection} Filtered records\n\t * @private\n\t */\n\t_filterByObject (predicate, options) {\n\t\treturn this.find(predicate, options);\n\t}\n\n\t/**\n\t * Search records by value in specified fields\n\t * @param {*} value - Search value\n\t * @param {string|Array<string>} [fields] - Fields to search\n\t * @param {Object} [options={}] - Search options\n\t * @returns {RecordCollection} Matching records\n\t */\n\tsearch (value, fields, options = {}) {\n\t\t// Function-based search (delegate to where)\n\t\tif (typeof value === \"function\") {\n\t\t\treturn this.where(value, options);\n\t\t}\n\n\t\t// If no fields specified, search all available indexes\n\t\tif (!fields) {\n\t\t\tconst availableIndexes = this.indexManager.listIndexes();\n\t\t\tif (availableIndexes.length === 0) {\n\t\t\t\t// No indexes, full scan\n\t\t\t\treturn this._fullScanSearch(value, options);\n\t\t\t}\n\t\t\tfields = availableIndexes;\n\t\t}\n\n\t\tconst fieldArray = Array.isArray(fields) ? fields : [fields];\n\t\tconst matchingKeys = new Set();\n\n\t\t// Try to use indexes for each field\n\t\tfor (const field of fieldArray) {\n\t\t\tif (this.indexManager.hasIndex(field)) {\n\t\t\t\t// Use index-based search\n\t\t\t\tconst indexKeys = this._searchIndex(field, value);\n\t\t\t\tindexKeys.forEach(key => matchingKeys.add(key));\n\t\t\t} else {\n\t\t\t\t// Fallback to field-based search for non-indexed fields\n\t\t\t\tconst searchKeys = this._searchField(field, value);\n\t\t\t\tsearchKeys.forEach(key => matchingKeys.add(key));\n\t\t\t}\n\t\t}\n\n\t\t// Convert keys to RecordCollection\n\t\treturn this._keysToRecordCollection(matchingKeys);\n\t}\n\n\t/**\n\t * Filter records using a predicate function\n\t * @param {Function} predicate - Filter predicate\n\t * @param {Object} [options={}] - Filter options\n\t * @returns {RecordCollection} Filtered records\n\t */\n\tfilter (predicate, options = {}) {\n\t\treturn this._filterByFunction(predicate, options);\n\t}\n\n\t/**\n\t * Map over records and transform them\n\t * @param {Function} mapper - Mapping function\n\t * @param {Object} [options={}] - Map options\n\t * @returns {Array} Mapped results\n\t */\n\tmap (mapper, options = {}) {\n\t\tconst { limit, offset = 0 } = options;\n\t\tconst results = [];\n\t\tlet count = 0;\n\n\t\tfor (const [, recordData] of this.storageManager.entries()) {\n\t\t\tif (count >= offset) {\n\t\t\t\t// For backwards compatibility, pass plain objects to mapper\n\t\t\t\tresults.push(mapper(recordData));\n\t\t\t\tif (limit && results.length >= limit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Reduce records to a single value\n\t * @param {Function} reducer - Reducer function\n\t * @param {*} initialValue - Initial value\n\t * @param {Object} [options={}] - Reduce options\n\t * @returns {*} Reduced value\n\t */\n\treduce (reducer, initialValue, options = {}) {\n\t\tconst { limit, offset = 0 } = options;\n\t\tlet accumulator = initialValue;\n\t\tlet count = 0;\n\t\tlet processedCount = 0;\n\n\t\tfor (const [, recordData] of this.storageManager.entries()) {\n\t\t\tif (count >= offset) {\n\t\t\t\t// For backwards compatibility, pass plain objects to reducer\n\t\t\t\taccumulator = reducer(accumulator, recordData, processedCount);\n\t\t\t\tprocessedCount++;\n\t\t\t\tif (limit && processedCount >= limit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\n\t\treturn accumulator;\n\t}\n\n\t/**\n\t * Execute a function for each record\n\t * @param {Function} callback - Callback function\n\t * @param {Object} [thisArg] - Value to use as this when executing callback\n\t * @param {Object} [options={}] - Options\n\t */\n\tforEach (callback, thisArg, options = {}) {\n\t\t// Handle overloaded parameters (callback, options) vs (callback, thisArg, options)\n\t\tif (thisArg && !options && typeof thisArg === \"object\" && (thisArg.limit !== undefined || thisArg.offset !== undefined)) {\n\t\t\toptions = thisArg;\n\t\t\tthisArg = undefined;\n\t\t}\n\n\t\tconst { limit, offset = 0 } = options;\n\t\tlet count = 0;\n\t\tlet processedCount = 0;\n\n\t\tfor (const [, recordData] of this.storageManager.entries()) {\n\t\t\tif (count >= offset) {\n\t\t\t\t// For backwards compatibility, pass plain objects to callback\n\t\t\t\tif (thisArg !== undefined) {\n\t\t\t\t\tcallback.call(thisArg, recordData, processedCount);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(recordData, processedCount);\n\t\t\t\t}\n\t\t\t\tprocessedCount++;\n\t\t\t\tif (limit && processedCount >= limit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\t/**\n\t * Search within a specific index\n\t * @param {string} indexName - Index name\n\t * @param {*} value - Search value\n\t * @returns {Set<string>} Set of matching record keys\n\t * @private\n\t */\n\t_searchIndex (indexName, value) {\n\t\tconst matchingKeys = new Set();\n\n\t\ttry {\n\t\t\t// For exact matches, use IndexManager's findByIndex method\n\t\t\tif (typeof value === \"string\" && !value.includes(\"*\") && !value.includes(\"?\")) {\n\t\t\t\tconst exactKeys = this.indexManager.findByIndex(indexName, value);\n\t\t\t\texactKeys.forEach(key => matchingKeys.add(key));\n\t\t\t} else {\n\t\t\t\t// For partial matches, search through all index keys\n\t\t\t\tconst indexStorage = this.indexManager._indexes.get(indexName);\n\t\t\t\tif (indexStorage) {\n\t\t\t\t\tfor (const [indexKey, recordKeys] of indexStorage._storage.entries()) {\n\t\t\t\t\t\tif (this._matchesSearchValue(indexKey, value)) {\n\t\t\t\t\t\t\trecordKeys.forEach(key => matchingKeys.add(key));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {\n\t\t\t// Fallback to empty set on error\n\t\t}\n\n\t\treturn matchingKeys;\n\t}\n\n\t/**\n\t * Search within a specific field (non-indexed)\n\t * @param {string} field - Field name\n\t * @param {*} value - Search value\n\t * @returns {Set<string>} Set of matching record keys\n\t * @private\n\t */\n\t_searchField (field, value) {\n\t\tconst matchingKeys = new Set();\n\n\t\tfor (const [key, recordData] of this.storageManager.entries()) {\n\t\t\tconst fieldValue = this._getFieldValue(recordData, field);\n\t\t\tif (this._matchesSearchValue(fieldValue, value)) {\n\t\t\t\tmatchingKeys.add(key);\n\t\t\t}\n\t\t}\n\n\t\treturn matchingKeys;\n\t}\n\n\t/**\n\t * Perform full scan search when no indexes available\n\t * @param {*} value - Search value\n\t * @param {Object} options - Search options\n\t * @returns {RecordCollection} Matching records\n\t * @private\n\t */\n\t_fullScanSearch (value, options) {\n\t\tconst records = [];\n\t\tconst { limit, offset = 0 } = options;\n\t\tlet count = 0;\n\n\t\tfor (const [key, recordData] of this.storageManager.entries()) {\n\t\t\tif (this._searchInRecord(recordData, value)) {\n\t\t\t\tif (count >= offset) {\n\t\t\t\t\trecords.push(RecordFactory.create(key, recordData));\n\t\t\t\t\tif (limit && records.length >= limit) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\treturn new RecordCollection(records);\n\t}\n\n\t/**\n\t * Convert a set of keys to a RecordCollection\n\t * @param {Set<string>|Array<string>} keys - Record keys\n\t * @returns {RecordCollection} Collection of Record objects\n\t * @private\n\t */\n\t_keysToRecordCollection (keys) {\n\t\tconst results = [];\n\t\tfor (const key of keys) {\n\t\t\tconst recordData = this.storageManager.get(key);\n\t\t\tif (recordData) {\n\t\t\t\tresults.push(RecordFactory.create(key, recordData));\n\t\t\t}\n\t\t}\n\n\t\treturn new RecordCollection(results);\n\t}\n\n\t/**\n\t * Get field value from record (supports nested fields)\n\t * @param {Object} record - Record object\n\t * @param {string} field - Field path (e.g., \"user.name\")\n\t * @returns {*} Field value\n\t * @private\n\t */\n\t_getFieldValue (record, field) {\n\t\tconst parts = field.split(\".\");\n\t\tlet value = record;\n\n\t\tfor (const part of parts) {\n\t\t\tif (value && typeof value === \"object\") {\n\t\t\t\tvalue = value[part];\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * Check if a value matches the search criteria\n\t * @param {*} fieldValue - Field value to test\n\t * @param {*} searchValue - Search value\n\t * @returns {boolean} True if matches\n\t * @private\n\t */\n\t_matchesSearchValue (fieldValue, searchValue) {\n\t\tif (searchValue instanceof RegExp) {\n\t\t\treturn searchValue.test(String(fieldValue));\n\t\t}\n\n\t\tif (typeof searchValue === \"string\") {\n\t\t\treturn String(fieldValue).toLowerCase().includes(searchValue.toLowerCase());\n\t\t}\n\n\t\treturn fieldValue === searchValue;\n\t}\n\n\t/**\n\t * Search within a record for a value\n\t * @param {Object} record - Record to search\n\t * @param {*} value - Value to search for\n\t * @returns {boolean} True if found\n\t * @private\n\t */\n\t_searchInRecord (record, value) {\n\t\tconst searchString = String(value).toLowerCase();\n\n\t\tconst searchObject = obj => {\n\t\t\tfor (const val of Object.values(obj)) {\n\t\t\t\tif (val !== null && val !== undefined) {\n\t\t\t\t\tif (typeof val === \"object\") {\n\t\t\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\t\t\tif (val.some(item => String(item).toLowerCase().includes(searchString))) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (searchObject(val)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (String(val).toLowerCase().includes(searchString)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\n\t\treturn searchObject(record);\n\t}\n}\n","import { QueryError, TransactionError } from \"./errors.js\";\n\n/**\n * Manages batch operations with transaction support\n */\nexport class BatchManager {\n\t/**\n\t * @param {Object} dependencies - Required dependencies\n\t * @param {CRUDManager} dependencies.crudManager - CRUD manager\n\t * @param {TransactionManager} [dependencies.transactionManager] - Transaction manager\n\t * @param {LifecycleManager} dependencies.lifecycleManager - Lifecycle manager\n\t */\n\tconstructor ({ crudManager, transactionManager = null, lifecycleManager }) {\n\t\tthis.crudManager = crudManager;\n\t\tthis.transactionManager = transactionManager;\n\t\tthis.lifecycleManager = lifecycleManager;\n\t}\n\n\t/**\n\t * Batch operations with transaction support\n\t * @param {Array} operations - Array of operations or records\n\t * @param {string} [type='set'] - Operation type\n\t * @param {Object} [options={}] - Batch options\n\t * @returns {Promise<Array>|Array} Array of results (Promise when using transactions)\n\t */\n\tbatch (operations, type = \"set\", options = {}) {\n\t\tconst {\n\t\t\ttransaction = null,\n\t\t\tatomic = false\n\t\t} = options;\n\n\t\ttry {\n\t\t\t// Use transaction for atomic operations\n\t\t\tif (atomic || transaction) {\n\t\t\t\treturn this._executeBatchInTransaction(operations, type, transaction);\n\t\t\t}\n\n\t\t\t// Execute operations individually\n\t\t\tconst results = [];\n\t\t\tfor (const operation of operations) {\n\t\t\t\ttry {\n\t\t\t\t\tlet result;\n\t\t\t\t\tif (type === \"set\") {\n\t\t\t\t\t\tresult = this.crudManager.set(null, operation, { batch: true });\n\t\t\t\t\t} else if (type === \"del\") {\n\t\t\t\t\t\tthis.crudManager.delete(operation, { batch: true });\n\t\t\t\t\t\tresult = true;\n\t\t\t\t\t}\n\t\t\t\t\tresults.push(result);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tresults.push(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Trigger batch lifecycle hook\n\t\t\tthis.lifecycleManager.onbatch(results, type);\n\n\t\t\treturn results;\n\n\t\t} catch (error) {\n\t\t\tthrow new QueryError(`Batch operation failed: ${error.message}`, operations, \"batch\");\n\t\t}\n\t}\n\n\t/**\n\t * Execute batch in transaction\n\t * @param {Array} operations - Operations to execute\n\t * @param {string} type - Operation type\n\t * @param {Transaction} [transaction] - Existing transaction\n\t * @returns {Promise<Array>} Operation results\n\t * @private\n\t */\n\tasync _executeBatchInTransaction (operations, type, transaction) {\n\t\tif (!this.transactionManager) {\n\t\t\tthrow new TransactionError(\"Transaction manager not available for atomic batch operations\");\n\t\t}\n\n\t\tconst ownTransaction = !transaction;\n\t\tif (ownTransaction) {\n\t\t\ttransaction = this.transactionManager.begin();\n\t\t}\n\n\t\ttry {\n\t\t\tconst results = [];\n\t\t\tfor (const operation of operations) {\n\t\t\t\tif (type === \"set\") {\n\t\t\t\t\tconst result = this._executeSetInTransaction(null, operation, transaction);\n\t\t\t\t\tresults.push(result);\n\t\t\t\t} else if (type === \"del\") {\n\t\t\t\t\tthis._executeDeleteInTransaction(operation, transaction);\n\t\t\t\t\tresults.push(true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ownTransaction) {\n\t\t\t\tawait this.transactionManager.commit(transaction.id);\n\t\t\t}\n\n\t\t\treturn results;\n\t\t} catch (error) {\n\t\t\tif (ownTransaction) {\n\t\t\t\tthis.transactionManager.abort(transaction.id, error.message);\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Execute set operation in transaction\n\t * @param {string|null} key - Record key\n\t * @param {Object} data - Record data\n\t * @param {Transaction} transaction - Transaction instance\n\t * @returns {Record} Created record\n\t * @private\n\t */\n\t_executeSetInTransaction (key, data, transaction) {\n\t\t// Add operation to transaction log\n\t\tconst oldValue = key ? this.crudManager.storageManager.get(key) : null;\n\t\ttransaction.addOperation(\"set\", key, oldValue, data);\n\n\t\t// Execute operation\n\t\treturn this.crudManager.set(key, data, { batch: true });\n\t}\n\n\t/**\n\t * Execute delete operation in transaction\n\t * @param {string} key - Record key\n\t * @param {Transaction} transaction - Transaction instance\n\t * @private\n\t */\n\t_executeDeleteInTransaction (key, transaction) {\n\t\t// Add operation to transaction log\n\t\tconst oldValue = this.crudManager.storageManager.get(key);\n\t\ttransaction.addOperation(\"delete\", key, oldValue);\n\n\t\t// Execute operation\n\t\tthis.crudManager.delete(key, { batch: true });\n\t}\n}\n","import { DataStream } from \"./data-stream.js\";\n\n/**\n * Manages streaming operations for large datasets\n */\nexport class StreamManager {\n\t/**\n\t * @param {Object} dependencies - Required dependencies\n\t * @param {StorageManager} dependencies.storageManager - Storage manager\n\t */\n\tconstructor ({ storageManager }) {\n\t\tthis.storageManager = storageManager;\n\t}\n\n\t/**\n\t * Create a data stream for large datasets\n\t * @param {Object} [options={}] - Stream options\n\t * @returns {DataStream} Data stream instance\n\t */\n\tstream (options = {}) {\n\t\tconst entries = this.storageManager.entries();\n\t\tlet index = 0;\n\n\t\tconst iterator = {\n\t\t\tnext: () => {\n\t\t\t\tif (index < entries.length) {\n\t\t\t\t\treturn { value: entries[index++], done: false };\n\t\t\t\t}\n\n\t\t\t\treturn { done: true };\n\t\t\t}\n\t\t};\n\n\t\treturn new DataStream(iterator, options);\n\t}\n\n\t/**\n\t * Create a filtered stream\n\t * @param {Function|Object} predicate - Filter predicate\n\t * @param {Object} [options={}] - Stream options\n\t * @returns {DataStream} Filtered stream\n\t */\n\tstreamWhere (predicate, options = {}) {\n\t\tconst iterator = this._createFilteredIterator(predicate);\n\n\t\treturn new DataStream(iterator, options);\n\t}\n\n\t/**\n\t * Create a transformed stream\n\t * @param {Function} transform - Transform function\n\t * @param {Object} [options={}] - Stream options\n\t * @returns {DataStream} Transformed stream\n\t */\n\tstreamMap (transform, options = {}) {\n\t\tconst iterator = this._createTransformIterator(transform);\n\n\t\treturn new DataStream(iterator, options);\n\t}\n\n\t/**\n\t * Create a limited stream\n\t * @param {number} limit - Maximum number of records\n\t * @param {Object} [options={}] - Stream options\n\t * @returns {DataStream} Limited stream\n\t */\n\tstreamTake (limit, options = {}) {\n\t\tconst iterator = this._createLimitedIterator(limit);\n\n\t\treturn new DataStream(iterator, options);\n\t}\n\n\t/**\n\t * Create iterator for filtered data\n\t * @param {Function|Object} predicate - Filter predicate\n\t * @returns {Iterator} Filtered iterator\n\t * @private\n\t */\n\t_createFilteredIterator (predicate) {\n\t\tconst entries = this.storageManager.entries();\n\t\tlet index = 0;\n\n\t\treturn {\n\t\t\tnext: () => {\n\t\t\t\twhile (index < entries.length) {\n\t\t\t\t\tconst [key, value] = entries[index++];\n\n\t\t\t\t\tif (typeof predicate === \"function\") {\n\t\t\t\t\t\tif (predicate({ key, ...value })) {\n\t\t\t\t\t\t\treturn { value: [key, value], done: false };\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (typeof predicate === \"object\") {\n\t\t\t\t\t\tif (this._matchesCriteria(value, predicate)) {\n\t\t\t\t\t\t\treturn { value: [key, value], done: false };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn { done: true };\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Create iterator for transformed data\n\t * @param {Function} transform - Transform function\n\t * @returns {Iterator} Transform iterator\n\t * @private\n\t */\n\t_createTransformIterator (transform) {\n\t\tconst entries = this.storageManager.entries();\n\t\tlet index = 0;\n\n\t\treturn {\n\t\t\tnext: () => {\n\t\t\t\tif (index < entries.length) {\n\t\t\t\t\tconst [key, value] = entries[index++];\n\t\t\t\t\tconst transformed = transform({ key, ...value });\n\n\t\t\t\t\treturn { value: [key, transformed], done: false };\n\t\t\t\t}\n\n\t\t\t\treturn { done: true };\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Create iterator for limited data\n\t * @param {number} limit - Record limit\n\t * @returns {Iterator} Limited iterator\n\t * @private\n\t */\n\t_createLimitedIterator (limit) {\n\t\tconst entries = this.storageManager.entries();\n\t\tlet index = 0;\n\n\t\treturn {\n\t\t\tnext: () => {\n\t\t\t\tif (index < limit && index < entries.length) {\n\t\t\t\t\tconst entry = entries[index++];\n\n\t\t\t\t\treturn { value: entry, done: false };\n\t\t\t\t}\n\n\t\t\t\treturn { done: true };\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Check if record matches criteria\n\t * @param {Object} record - Record to check\n\t * @param {Object} criteria - Criteria object\n\t * @returns {boolean} True if matches\n\t * @private\n\t */\n\t_matchesCriteria (record, criteria) {\n\t\tfor (const [field, value] of Object.entries(criteria)) {\n\t\t\tconst recordValue = record[field];\n\n\t\t\tif (value instanceof RegExp) {\n\t\t\t\tif (!value.test(recordValue)) return false;\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\tif (Array.isArray(recordValue)) {\n\t\t\t\t\tif (!value.some(v => recordValue.includes(v))) return false;\n\t\t\t\t} else if (!value.includes(recordValue)) return false;\n\t\t\t} else if (recordValue !== value) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n}\n","/**\n * Manages statistics gathering and memory usage estimation\n */\nexport class StatisticsManager {\n\t/**\n\t * @param {Object} dependencies - Required dependencies\n\t * @param {StorageManager} dependencies.storageManager - Storage manager\n\t * @param {IndexManager} dependencies.indexManager - Index manager\n\t * @param {VersionManager} [dependencies.versionManager] - Version manager\n\t * @param {TransactionManager} [dependencies.transactionManager] - Transaction manager\n\t * @param {QueryOptimizer} [dependencies.queryOptimizer] - Query optimizer\n\t * @param {Object} dependencies.config - Configuration\n\t */\n\tconstructor ({\n\t\tstorageManager,\n\t\tindexManager,\n\t\tversionManager = null,\n\t\ttransactionManager = null,\n\t\tqueryOptimizer = null,\n\t\tconfig\n\t}) {\n\t\tthis.storageManager = storageManager;\n\t\tthis.indexManager = indexManager;\n\t\tthis.versionManager = versionManager;\n\t\tthis.transactionManager = transactionManager;\n\t\tthis.queryOptimizer = queryOptimizer;\n\t\tthis.config = config;\n\t}\n\n\t/**\n\t * Get comprehensive statistics\n\t * @returns {Object} Statistics object\n\t */\n\tgetStats () {\n\t\tconst stats = {\n\t\t\trecords: this.storageManager.size,\n\t\t\tconfiguration: this.config,\n\t\t\tindexes: this.indexManager.getStats(),\n\t\t\tmemory: this._estimateMemoryUsage()\n\t\t};\n\n\t\tif (this.versionManager) {\n\t\t\tstats.versions = this.versionManager.getStats();\n\t\t}\n\n\t\tif (this.transactionManager) {\n\t\t\tstats.transactions = this.transactionManager.getStats();\n\t\t}\n\n\t\tif (this.queryOptimizer) {\n\t\t\tstats.queries = this.queryOptimizer.getStats();\n\t\t}\n\n\t\treturn stats;\n\t}\n\n\t/**\n\t * Get storage statistics\n\t * @returns {Object} Storage statistics\n\t */\n\tgetStorageStats () {\n\t\treturn {\n\t\t\tsize: this.storageManager.size,\n\t\t\tmemoryUsage: this.storageManager.estimateMemoryUsage(),\n\t\t\ttype: this.config.immutable ? \"immutable\" : \"mutable\"\n\t\t};\n\t}\n\n\t/**\n\t * Get index statistics\n\t * @returns {Object} Index statistics\n\t */\n\tgetIndexStats () {\n\t\treturn this.indexManager.getStats();\n\t}\n\n\t/**\n\t * Get version statistics\n\t * @returns {Object|null} Version statistics\n\t */\n\tgetVersionStats () {\n\t\treturn this.versionManager ? this.versionManager.getStats() : null;\n\t}\n\n\t/**\n\t * Get transaction statistics\n\t * @returns {Object|null} Transaction statistics\n\t */\n\tgetTransactionStats () {\n\t\treturn this.transactionManager ? this.transactionManager.getStats() : null;\n\t}\n\n\t/**\n\t * Get query optimization statistics\n\t * @returns {Object|null} Query statistics\n\t */\n\tgetQueryStats () {\n\t\treturn this.queryOptimizer ? this.queryOptimizer.getStats() : null;\n\t}\n\n\t/**\n\t * Get performance metrics\n\t * @returns {Object} Performance metrics\n\t */\n\tgetPerformanceMetrics () {\n\t\tconst stats = this.getStats();\n\n\t\treturn {\n\t\t\trecordsPerIndex: stats.records / Math.max(1, Object.keys(stats.indexes).length),\n\t\t\tmemoryPerRecord: stats.memory.total / Math.max(1, stats.records),\n\t\t\tindexEfficiency: this._calculateIndexEfficiency(stats),\n\t\t\toverheadRatio: stats.memory.overhead / Math.max(1, stats.memory.data)\n\t\t};\n\t}\n\n\t/**\n\t * Estimate memory usage\n\t * @returns {Object} Memory usage statistics\n\t * @private\n\t */\n\t_estimateMemoryUsage () {\n\t\tconst dataSize = this.storageManager.estimateMemoryUsage();\n\t\tconst indexSize = this.indexManager.getStats().totalMemoryUsage || 0;\n\t\tconst versionSize = this.versionManager ? this.versionManager.getStats().totalSize : 0;\n\n\t\treturn {\n\t\t\ttotal: dataSize + indexSize + versionSize,\n\t\t\tdata: dataSize,\n\t\t\tindexes: indexSize,\n\t\t\tversions: versionSize,\n\t\t\toverhead: indexSize + versionSize\n\t\t};\n\t}\n\n\t/**\n\t * Calculate index efficiency\n\t * @param {Object} stats - Statistics object\n\t * @returns {number} Efficiency percentage\n\t * @private\n\t */\n\t_calculateIndexEfficiency (stats) {\n\t\tif (!stats.indexes || !stats.queries) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst totalQueries = stats.queries.totalExecutions || 1;\n\t\tconst indexedQueries = stats.queries.indexedExecutions || 0;\n\n\t\treturn indexedQueries / totalQueries * 100;\n\t}\n\n\t/**\n\t * Generate performance report\n\t * @returns {Object} Performance report\n\t */\n\tgenerateReport () {\n\t\tconst stats = this.getStats();\n\t\tconst performance = this.getPerformanceMetrics();\n\n\t\treturn {\n\t\t\tsummary: {\n\t\t\t\ttotalRecords: stats.records,\n\t\t\t\ttotalMemory: stats.memory.total,\n\t\t\t\tactiveIndexes: Object.keys(stats.indexes).length,\n\t\t\t\tversioning: !!this.versionManager,\n\t\t\t\ttransactions: !!this.transactionManager,\n\t\t\t\toptimization: !!this.queryOptimizer\n\t\t\t},\n\t\t\tperformance,\n\t\t\tbreakdown: {\n\t\t\t\tstorage: this.getStorageStats(),\n\t\t\t\tindexes: this.getIndexStats(),\n\t\t\t\tversions: this.getVersionStats(),\n\t\t\t\ttransactions: this.getTransactionStats(),\n\t\t\t\tqueries: this.getQueryStats()\n\t\t\t},\n\t\t\trecommendations: this._generateRecommendations(stats, performance)\n\t\t};\n\t}\n\n\t/**\n\t * Generate performance recommendations\n\t * @param {Object} stats - Statistics object\n\t * @param {Object} performance - Performance metrics\n\t * @returns {Array} Array of recommendations\n\t * @private\n\t */\n\t_generateRecommendations (stats, performance) {\n\t\tconst recommendations = [];\n\n\t\tif (performance.indexEfficiency < 50) {\n\t\t\trecommendations.push(\"Consider adding more indexes for frequently queried fields\");\n\t\t}\n\n\t\tif (performance.overheadRatio > 2) {\n\t\t\trecommendations.push(\"High memory overhead detected - consider optimizing indexes or version retention\");\n\t\t}\n\n\t\tif (stats.records > 10000 && !this.queryOptimizer) {\n\t\t\trecommendations.push(\"Enable query optimization for better performance with large datasets\");\n\t\t}\n\n\t\tif (stats.memory.versions > stats.memory.data) {\n\t\t\trecommendations.push(\"Version storage is larger than data - consider adjusting retention policy\");\n\t\t}\n\n\t\treturn recommendations;\n\t}\n}\n","import { ValidationError } from \"./errors.js\";\n\n/**\n * Manages lifecycle hooks and events\n */\nexport class LifecycleManager {\n\t/**\n\t * @param {Object} [hooks={}] - Custom lifecycle hooks\n\t */\n\tconstructor (hooks = {}) {\n\t\t// Only store actually registered hooks, no default no-ops\n\t\tthis.hooks = { ...hooks };\n\t}\n\n\t/**\n\t * Register a lifecycle hook\n\t * @param {string} event - Event name\n\t * @param {Function} handler - Event handler\n\t */\n\tregisterHook (event, handler) {\n\t\tif (typeof handler !== \"function\") {\n\t\t\tthrow new ValidationError(`Hook handler for '${event}' must be a function`, \"handler\", handler);\n\t\t}\n\t\tthis.hooks[event] = handler;\n\t}\n\n\t/**\n\t * Unregister a lifecycle hook\n\t * @param {string} event - Event name\n\t */\n\tunregisterHook (event) {\n\t\tdelete this.hooks[event];\n\t}\n\n\t/**\n\t * Check if a hook is registered\n\t * @param {string} event - Event name\n\t * @returns {boolean} True if hook exists\n\t */\n\thasActiveHook (event) {\n\t\treturn event in this.hooks;\n\t}\n\n\t/**\n\t * Execute a lifecycle hook\n\t * @param {string} event - Event name\n\t * @param {...*} args - Arguments to pass to hook\n\t * @returns {*} Hook result\n\t */\n\texecuteHook (event, ...args) {\n\t\tif (this.hasActiveHook(event)) {\n\t\t\treturn this.hooks[event](...args);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Before set hook\n\t * @param {string} key - Record key\n\t * @param {Object} data - Record data\n\t * @param {Object} options - Operation options\n\t */\n\tbeforeSet (key, data, options) {\n\t\treturn this.executeHook(\"beforeSet\", key, data, options);\n\t}\n\n\t/**\n\t * On set hook\n\t * @param {Record} record - Created/updated record\n\t * @param {Object} options - Operation options\n\t */\n\tonset (record, options) {\n\t\treturn this.executeHook(\"onset\", record, options);\n\t}\n\n\t/**\n\t * Before delete hook\n\t * @param {string} key - Record key\n\t * @param {boolean} batch - Is batch operation\n\t */\n\tbeforeDelete (key, batch) {\n\t\treturn this.executeHook(\"beforeDelete\", key, batch);\n\t}\n\n\t/**\n\t * On delete hook\n\t * @param {string} key - Deleted record key\n\t */\n\tondelete (key) {\n\t\treturn this.executeHook(\"ondelete\", key);\n\t}\n\n\t/**\n\t * Before clear hook\n\t */\n\tbeforeClear () {\n\t\treturn this.executeHook(\"beforeClear\");\n\t}\n\n\t/**\n\t * On clear hook\n\t */\n\tonclear () {\n\t\treturn this.executeHook(\"onclear\");\n\t}\n\n\t/**\n\t * On batch hook\n\t * @param {Array} results - Batch operation results\n\t * @param {string} type - Operation type\n\t */\n\tonbatch (results, type) {\n\t\treturn this.executeHook(\"onbatch\", results, type);\n\t}\n\n\t/**\n\t * Get all registered hooks\n\t * @returns {Object} Hooks object\n\t */\n\tgetHooks () {\n\t\treturn { ...this.hooks };\n\t}\n\n\t/**\n\t * Check if hook is registered\n\t * @param {string} event - Event name\n\t * @returns {boolean} True if hook exists\n\t */\n\thasHook (event) {\n\t\treturn event in this.hooks && typeof this.hooks[event] === \"function\";\n\t}\n\n\t/**\n\t * Clear all hooks (reset to no-ops)\n\t */\n\tclearHooks () {\n\t\tfor (const event in this.hooks) {\n\t\t\tthis.hooks[event] = () => {};\n\t\t}\n\t}\n}\n","import { randomUUID as uuid } from \"crypto\";\nimport {\n\tConfigurationError,\n\tTransactionError,\n\tErrorRecovery\n} from \"./errors.js\";\nimport { DataTypes } from \"./data-types.js\";\nimport { FieldConstraint } from \"./field-constraint.js\";\nimport { Schema } from \"./schema.js\";\nimport { ConfigValidator } from \"./config-validator.js\";\nimport { Constraints } from \"./constraints.js\";\nimport { IsolationLevels } from \"./constants.js\";\nimport { Record, RecordCollection, RecordFactory } from \"./record.js\";\nimport { IndexManager, IndexTypes } from \"./index-manager.js\";\nimport { VersionManager, RetentionPolicies } from \"./version-manager.js\";\nimport { TransactionManager } from \"./transaction-manager.js\";\nimport { QueryOptimizer, QueryTypes } from \"./query-optimizer.js\";\nimport { ImmutableStore } from \"./immutable-store.js\";\nimport { DataStream } from \"./data-stream.js\";\nimport { StorageManager } from \"./storage-manager.js\";\nimport { CRUDManager } from \"./crud-manager.js\";\nimport { QueryManager } from \"./query-manager.js\";\nimport { BatchManager } from \"./batch-manager.js\";\nimport { StreamManager } from \"./stream-manager.js\";\nimport { StatisticsManager } from \"./statistics-manager.js\";\nimport { LifecycleManager } from \"./lifecycle-manager.js\";\n\n\n/**\n * Haro class with all design flaws addressed and enterprise features added\n */\nexport class Haro {\n\t/**\n\t * @param {Array|Object} [data] - Initial data or configuration\n\t * @param {Object} [config={}] - Configuration options\n\t */\n\tconstructor (data = null, config = {}) {\n\t\t// Set defaults first\n\t\tconst defaults = {\n\t\t\tdelimiter: \"|\",\n\t\t\tid: uuid(),\n\t\t\timmutable: false,\n\t\t\tindex: [],\n\t\t\tkey: \"id\",\n\t\t\tversioning: false,\n\t\t\tschema: null,\n\t\t\tretentionPolicy: { type: RetentionPolicies.NONE },\n\t\t\tenableTransactions: false,\n\t\t\tenableOptimization: true\n\t\t};\n\n\t\t// Handle parameter overloading and merge with defaults\n\t\tlet userConfig;\n\t\tif (Array.isArray(data) || data === null) {\n\t\t\tuserConfig = ConfigValidator.validate(config);\n\t\t\tthis.initialData = data;\n\t\t} else {\n\t\t\tuserConfig = ConfigValidator.validate(data);\n\t\t\tthis.initialData = null;\n\t\t}\n\n\t\t// Merge defaults with user configuration (user config takes precedence)\n\t\tthis.config = { ...defaults, ...userConfig };\n\n\t\t// Initialize core managers\n\t\tthis.storageManager = new StorageManager({ immutable: this.config.immutable });\n\t\tthis.indexManager = new IndexManager(this.config.delimiter);\n\t\tthis.versionManager = this.config.versioning ?\n\t\t\tnew VersionManager(this.config.retentionPolicy) :\n\t\t\tnull;\n\t\tthis.transactionManager = this.config.enableTransactions ?\n\t\t\tnew TransactionManager() :\n\t\t\tnull;\n\t\tthis.queryOptimizer = this.config.enableOptimization ?\n\t\t\tnew QueryOptimizer() :\n\t\t\tnull;\n\n\t\t// Initialize lifecycle manager\n\t\tthis.lifecycleManager = new LifecycleManager();\n\n\t\t// Initialize specialized managers\n\t\tthis.crudManager = new CRUDManager({\n\t\t\tstorageManager: this.storageManager,\n\t\t\tindexManager: this.indexManager,\n\t\t\tversionManager: this.versionManager,\n\t\t\tconfig: this.config\n\t\t});\n\n\t\tthis.queryManager = new QueryManager({\n\t\t\tstorageManager: this.storageManager,\n\t\t\tindexManager: this.indexManager,\n\t\t\tqueryOptimizer: this.queryOptimizer\n\t\t});\n\n\t\tthis.batchManager = new BatchManager({\n\t\t\tcrudManager: this.crudManager,\n\t\t\ttransactionManager: this.transactionManager,\n\t\t\tlifecycleManager: this.lifecycleManager\n\t\t});\n\n\t\tthis.streamManager = new StreamManager({\n\t\t\tstorageManager: this.storageManager\n\t\t});\n\n\t\tthis.statisticsManager = new StatisticsManager({\n\t\t\tstorageManager: this.storageManager,\n\t\t\tindexManager: this.indexManager,\n\t\t\tversionManager: this.versionManager,\n\t\t\ttransactionManager: this.transactionManager,\n\t\t\tqueryOptimizer: this.queryOptimizer,\n\t\t\tconfig: this.config\n\t\t});\n\n\t\t// Create indexes\n\t\tfor (const indexField of this.config.index) {\n\t\t\tthis.indexManager.createIndex(indexField, indexField);\n\t\t}\n\n\t\t// Properties for backward compatibility\n\t\tObject.defineProperty(this, \"data\", {\n\t\t\tget: () => this.storageManager.getStore(),\n\t\t\tenumerable: true\n\t\t});\n\n\t\tObject.defineProperty(this, \"size\", {\n\t\t\tget: () => this.storageManager.size,\n\t\t\tenumerable: true\n\t\t});\n\n\t\tObject.defineProperty(this, \"registry\", {\n\t\t\tget: () => this.storageManager.keys(),\n\t\t\tenumerable: true\n\t\t});\n\n\t\t// Initialize with data if provided\n\t\tif (this.initialData && Array.isArray(this.initialData)) {\n\t\t\tthis.batch(this.initialData);\n\t\t}\n\t}\n\n\t/**\n\t * Set or update a record with comprehensive validation and error handling\n\t * @param {string|null} key - Record key or null for auto-generation\n\t * @param {Object} [data={}] - Record data\n\t * @param {Object} [options={}] - Operation options\n\t * @returns {Record} Created/updated record\n\t * @throws {ValidationError} If data validation fails\n\t */\n\tset (key, data = {}, options = {}) {\n\t\tconst {\n\t\t\tbatch = false,\n\t\t\ttransaction = null\n\t\t} = options;\n\n\t\t// Execute in transaction if provided\n\t\tif (transaction) {\n\t\t\treturn this._executeInTransaction(transaction, \"set\", key, data, options);\n\t\t}\n\n\t\t// OPTIMIZATION: Only trigger lifecycle hooks if they're actually registered\n\t\tif (this.lifecycleManager.hasActiveHook(\"beforeSet\")) {\n\t\t\tthis.lifecycleManager.beforeSet(key, data, options);\n\t\t}\n\n\t\t// Delegate to CRUD manager (now optimized)\n\t\tconst record = this.crudManager.set(key, data, options);\n\n\t\t// OPTIMIZATION: Only trigger lifecycle hooks if they're actually registered\n\t\tif (!batch && this.lifecycleManager.hasActiveHook(\"onset\")) {\n\t\t\tthis.lifecycleManager.onset(record, options);\n\t\t}\n\n\t\treturn record;\n\t}\n\n\t/**\n\t * Get a record by key with consistent return format\n\t * @param {string} key - Record key\n\t * @param {Object} [options={}] - Get options\n\t * @returns {Record|null} Record instance or null if not found\n\t */\n\tget (key, options = {}) {\n\t\tconst { transaction = null } = options;\n\n\t\t// Execute in transaction if provided\n\t\tif (transaction) {\n\t\t\treturn this._executeInTransaction(transaction, \"get\", key, options);\n\t\t}\n\n\t\t// Delegate to CRUD manager (now optimized)\n\t\treturn this.crudManager.get(key, options);\n\t}\n\n\t/**\n\t * Delete a record with proper cleanup\n\t * @param {string} key - Record key\n\t * @param {Object} [options={}] - Delete options\n\t * @returns {boolean} True if deleted successfully\n\t * @throws {RecordNotFoundError} If record not found\n\t */\n\tdelete (key, options = {}) {\n\t\tconst {\n\t\t\tbatch = false,\n\t\t\ttransaction = null\n\t\t} = options;\n\n\t\t// Execute in transaction if provided\n\t\tif (transaction) {\n\t\t\treturn this._executeInTransaction(transaction, \"delete\", key, options);\n\t\t}\n\n\t\t// Lifecycle hook\n\t\tthis.lifecycleManager.beforeDelete(key, batch);\n\n\t\t// Delegate to CRUD manager\n\t\tconst result = this.crudManager.delete(key, options);\n\n\t\t// Lifecycle hook\n\t\tif (!batch) {\n\t\t\tthis.lifecycleManager.ondelete(key);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Check if record exists\n\t * @param {string} key - Record key\n\t * @returns {boolean} True if record exists\n\t */\n\thas (key) {\n\t\treturn this.crudManager.has(key);\n\t}\n\n\t/**\n\t * Get all record keys (backwards compatibility)\n\t * @returns {Array<string>} Array of record keys\n\t */\n\tkeys () {\n\t\treturn this.storageManager.keys();\n\t}\n\n\t/**\n\t * Get all record values (backwards compatibility)\n\t * @returns {IterableIterator<Object>} Iterable of record values\n\t */\n\tvalues () {\n\t\treturn this.storageManager.values();\n\t}\n\n\t/**\n\t * Get all record entries as [key, value] pairs (backwards compatibility)\n\t * @returns {IterableIterator<[string, Object]>} Iterable of [key, value] pairs\n\t */\n\tentries () {\n\t\treturn this.storageManager.entries();\n\t}\n\n\t/**\n\t * Convert store to array (backwards compatibility)\n\t * @returns {Array<Object>} Array of all records\n\t */\n\ttoArray () {\n\t\treturn Array.from(this.values());\n\t}\n\n\t/**\n\t * Filter records using a predicate (backwards compatibility)\n\t * @param {Function} predicate - Filter predicate\n\t * @param {Object} [options={}] - Filter options\n\t * @returns {RecordCollection} Filtered records\n\t */\n\tfilter (predicate, options = {}) {\n\t\t// Delegate to QueryManager\n\t\treturn this.queryManager.filter(predicate, options);\n\t}\n\n\t/**\n\t * Search records (backwards compatibility)\n\t * @param {*} value - Search value\n\t * @param {string|Array<string>} [fields] - Fields to search\n\t * @param {Object} [options={}] - Search options\n\t * @returns {RecordCollection} Matching records\n\t */\n\tsearch (value, fields, options = {}) {\n\t\t// Delegate to QueryManager\n\t\treturn this.queryManager.search(value, fields, options);\n\t}\n\n\n\t/**\n\t * Map over records (backwards compatibility)\n\t * @param {Function} mapper - Mapping function\n\t * @param {Object} [options={}] - Map options\n\t * @returns {Array} Mapped results\n\t */\n\tmap (mapper, options = {}) {\n\t\t// Delegate to QueryManager\n\t\treturn this.queryManager.map(mapper, options);\n\t}\n\n\t/**\n\t * Reduce records (backwards compatibility)\n\t * @param {Function} reducer - Reducer function\n\t * @param {*} [initialValue] - Initial value\n\t * @param {Object} [options={}] - Reduce options\n\t * @returns {*} Reduced result\n\t */\n\treduce (reducer, initialValue, options = {}) {\n\t\t// Delegate to QueryManager\n\t\treturn this.queryManager.reduce(reducer, initialValue, options);\n\t}\n\n\t/**\n\t * Iterate over records (backwards compatibility)\n\t * @param {Function} callback - Callback function\n\t * @param {Object} [thisArg] - Value to use as this when executing callback\n\t * @param {Object} [options={}] - Options\n\t */\n\tforEach (callback, thisArg, options = {}) {\n\t\t// Delegate to QueryManager\n\t\tthis.queryManager.forEach(callback, thisArg, options);\n\t}\n\n\t/**\n\t * Sort records (backwards compatibility)\n\t * @param {Function} [compareFn] - Compare function\n\t * @returns {Array<Object>} Sorted records\n\t */\n\tsort (compareFn) {\n\t\treturn this.toArray().sort(compareFn);\n\t}\n\n\t/**\n\t * Sort records by field (backwards compatibility)\n\t * @param {string} field - Field to sort by\n\t * @param {boolean} [ascending=true] - Sort direction\n\t * @returns {Array<Object>} Sorted records\n\t */\n\tsortBy (field, ascending = true) {\n\t\treturn this.sort((a, b) => {\n\t\t\tconst aVal = a[field];\n\t\t\tconst bVal = b[field];\n\t\t\tif (aVal < bVal) return ascending ? -1 : 1;\n\t\t\tif (aVal > bVal) return ascending ? 1 : -1;\n\n\t\t\treturn 0;\n\t\t});\n\t}\n\n\t/**\n\t * Find records using optimized queries\n\t * @param {Object} [criteria={}] - Search criteria\n\t * @param {Object} [options={}] - Query options\n\t * @returns {RecordCollection} Collection of matching records\n\t */\n\tfind (criteria = {}, options = {}) {\n\t\tconst { transaction = null } = options;\n\n\t\t// Execute in transaction if provided\n\t\tif (transaction) {\n\t\t\treturn this._executeInTransaction(transaction, \"find\", criteria, options);\n\t\t}\n\n\t\t// Delegate to query manager\n\t\treturn this.queryManager.find(criteria, options);\n\t}\n\n\t/**\n\t * Advanced filtering with predicate logic\n\t * @param {Function|Object} predicate - Filter predicate\n\t * @param {Object} [options={}] - Filter options\n\t * @returns {RecordCollection} Filtered records\n\t */\n\twhere (predicate, options = {}) {\n\t\tconst { transaction = null } = options;\n\n\t\t// Execute in transaction if provided\n\t\tif (transaction) {\n\t\t\treturn this._executeInTransaction(transaction, \"where\", predicate, options);\n\t\t}\n\n\t\t// Delegate to query manager\n\t\treturn this.queryManager.where(predicate, options);\n\t}\n\n\t/**\n\t * Batch operations with transaction support\n\t * @param {Array} operations - Array of operations or records\n\t * @param {string} [type='set'] - Operation type\n\t * @param {Object} [options={}] - Batch options\n\t * @returns {Promise<Array>|Array} Array of results (Promise when using transactions)\n\t */\n\tbatch (operations, type = \"set\", options = {}) {\n\t\t// Delegate to batch manager\n\t\treturn this.batchManager.batch(operations, type, options);\n\t}\n\n\t/**\n\t * Begin a new transaction\n\t * @param {Object} [options={}] - Transaction options\n\t * @returns {Transaction} New transaction\n\t * @throws {ConfigurationError} If transactions not enabled\n\t */\n\tbeginTransaction (options = {}) {\n\t\tif (!this.transactionManager) {\n\t\t\tthrow new ConfigurationError(\"Transactions not enabled\", \"enableTransactions\", false);\n\t\t}\n\n\t\treturn this.transactionManager.begin(options);\n\t}\n\n\t/**\n\t * Commit a transaction\n\t * @param {string|Transaction} transaction - Transaction ID or instance\n\t * @returns {Transaction} Committed transaction\n\t */\n\tasync commitTransaction (transaction) {\n\t\tif (!this.transactionManager) {\n\t\t\tthrow new ConfigurationError(\"Transactions not enabled\", \"enableTransactions\", false);\n\t\t}\n\n\t\tconst transactionId = typeof transaction === \"string\" ? transaction : transaction.id;\n\n\t\treturn await this.transactionManager.commit(transactionId);\n\t}\n\n\t/**\n\t * Abort a transaction\n\t * @param {string|Transaction} transaction - Transaction ID or instance\n\t * @param {string} [reason] - Abort reason\n\t * @returns {Transaction} Aborted transaction\n\t */\n\tabortTransaction (transaction, reason) {\n\t\tif (!this.transactionManager) {\n\t\t\tthrow new ConfigurationError(\"Transactions not enabled\", \"enableTransactions\", false);\n\t\t}\n\n\t\tconst transactionId = typeof transaction === \"string\" ? transaction : transaction.id;\n\n\t\treturn this.transactionManager.abort(transactionId, reason);\n\t}\n\n\t/**\n\t * Create a data stream for large datasets\n\t * @param {Object} [options={}] - Stream options\n\t * @returns {DataStream} Data stream instance\n\t */\n\tstream (options = {}) {\n\t\t// Delegate to stream manager\n\t\treturn this.streamManager.stream(options);\n\t}\n\n\t/**\n\t * Get comprehensive statistics\n\t * @returns {Object} Statistics object\n\t */\n\tgetStats () {\n\t\t// Delegate to statistics manager\n\t\treturn this.statisticsManager.getStats();\n\t}\n\n\t/**\n\t * Clear all data and reset state\n\t * @param {Object} [options={}] - Clear options\n\t */\n\tclear (options = {}) {\n\t\tconst {\n\t\t\tpreserveIndexes = false,\n\t\t\tpreserveVersions = false\n\t\t} = options;\n\n\t\t// Lifecycle hook\n\t\tthis.lifecycleManager.beforeClear();\n\n\t\t// Clear storage\n\t\tthis.storageManager.clear();\n\n\t\t// Clear indexes\n\t\tif (!preserveIndexes) {\n\t\t\tthis.indexManager.clear();\n\t\t}\n\n\t\t// Clear versions\n\t\tif (!preserveVersions && this.versionManager) {\n\t\t\tthis.versionManager.clear();\n\t\t}\n\n\t\t// Clear query cache\n\t\tif (this.queryOptimizer) {\n\t\t\tthis.queryOptimizer.clear();\n\t\t}\n\n\t\t// Lifecycle hook\n\t\tthis.lifecycleManager.onclear();\n\t}\n\n\t// Lifecycle hooks (backward compatibility - delegate to lifecycle manager)\n\tbeforeSet (key, data, options) {\n\t\treturn this.lifecycleManager.beforeSet(key, data, options);\n\t}\n\tonset (record, options) {\n\t\treturn this.lifecycleManager.onset(record, options);\n\t}\n\tbeforeDelete (key, batch) {\n\t\treturn this.lifecycleManager.beforeDelete(key, batch);\n\t}\n\tondelete (key) {\n\t\treturn this.lifecycleManager.ondelete(key);\n\t}\n\tbeforeClear () {\n\t\treturn this.lifecycleManager.beforeClear();\n\t}\n\tonclear () {\n\t\treturn this.lifecycleManager.onclear();\n\t}\n\tonbatch (results, type) {\n\t\treturn this.lifecycleManager.onbatch(results, type);\n\t}\n\n\n\t/**\n\t * Execute operation in transaction\n\t * @param {Transaction} transaction - Transaction instance\n\t * @param {string} operation - Operation type\n\t * @param {...*} args - Operation arguments\n\t * @returns {*} Operation result\n\t * @private\n\t */\n\t_executeInTransaction (transaction, operation, ...args) {\n\t\t// Handle different operation parameter patterns\n\t\tswitch (operation) {\n\t\t\tcase \"set\": {\n\t\t\t\tconst [key, data, options = {}] = args;\n\t\t\t\tconst oldValue = this.storageManager.get(key);\n\n\t\t\t\ttransaction.addOperation(operation, key, oldValue, data);\n\n\t\t\t\treturn this.set(key, data, { ...options, transaction: null });\n\t\t\t}\n\t\t\tcase \"get\": {\n\t\t\t\tconst [key, options = {}] = args;\n\n\t\t\t\ttransaction.addOperation(\"read\", key);\n\n\t\t\t\treturn this.get(key, { ...options, transaction: null });\n\t\t\t}\n\t\t\tcase \"delete\": {\n\t\t\t\tconst [key, options = {}] = args;\n\t\t\t\tconst oldValue = this.storageManager.get(key);\n\n\t\t\t\ttransaction.addOperation(operation, key, oldValue);\n\n\t\t\t\treturn this.delete(key, { ...options, transaction: null });\n\t\t\t}\n\t\t\tcase \"find\": {\n\t\t\t\tconst [criteria, options = {}] = args;\n\n\t\t\t\ttransaction.addOperation(\"read\", \"find_operation\", null, criteria);\n\n\t\t\t\treturn this.find(criteria, { ...options, transaction: null });\n\t\t\t}\n\t\t\tcase \"where\": {\n\t\t\t\tconst [predicate, options = {}] = args;\n\n\t\t\t\ttransaction.addOperation(\"read\", \"where_operation\", null, predicate);\n\n\t\t\t\treturn this.where(predicate, { ...options, transaction: null });\n\t\t\t}\n\t\t\tcase \"limit\": {\n\t\t\t\tconst [offset, max, options = {}] = args;\n\n\t\t\t\ttransaction.addOperation(\"read\", \"limit_operation\", null, { offset, max });\n\n\t\t\t\treturn this.limit(offset, max, { ...options, transaction: null });\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new TransactionError(`Unknown operation: ${operation}`, transaction.id, operation);\n\t\t}\n\t}\n\n\t/**\n\t * Get a limited subset of records with pagination support\n\t * @param {number} [offset=0] - Number of records to skip\n\t * @param {number} [max=0] - Maximum number of records to return (0 = all)\n\t * @param {Object} [options={}] - Options including transaction support\n\t * @returns {Array<Object>} Array of records within the specified range\n\t */\n\tlimit (offset = 0, max = 0, options = {}) {\n\t\tconst { transaction = null } = options;\n\n\t\t// Execute in transaction if provided\n\t\tif (transaction) {\n\t\t\treturn this._executeInTransaction(transaction, \"limit\", offset, max, options);\n\t\t}\n\n\t\t// Get keys first (much more efficient than getting all values)\n\t\tconst keys = this.keys();\n\t\tconst start = Math.max(0, offset);\n\t\tconst end = max > 0 ? start + max : keys.length;\n\n\t\t// Get only the subset of keys we need\n\t\tconst limitedKeys = keys.slice(start, end);\n\n\t\t// Batch retrieve only the records we need\n\t\tconst results = [];\n\t\tfor (const key of limitedKeys) {\n\t\t\tresults.push(this.storageManager.get(key));\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Rebuild indexes for a specific field or all fields\n\t * @param {string} [field] - Specific field to reindex (optional)\n\t * @returns {Haro} Store instance for chaining\n\t */\n\treindex (field) {\n\t\t// Get all records in entries format: Iterable<[key, data]>\n\t\tconst recordEntries = this.entries();\n\n\t\tif (field) {\n\t\t\t// Rebuild indexes for specific field\n\t\t\tthis.indexManager.rebuildField(field, recordEntries);\n\t\t} else {\n\t\t\t// Rebuild all indexes\n\t\t\tthis.indexManager.rebuild(recordEntries);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Export store data or indexes for persistence\n\t * @param {string} [type='records'] - Type of data to export: 'records' or 'indexes'\n\t * @returns {Array|Object} Array of [key, value] pairs or complete index state\n\t */\n\tdump (type = \"records\") {\n\t\tif (type === \"indexes\") {\n\t\t\t// Export complete IndexManager state (definitions, data, and stats)\n\t\t\treturn this.indexManager.exportState();\n\t\t}\n\n\t\t// Default to records\n\t\treturn Array.from(this.entries());\n\t}\n\n\t/**\n\t * Import and restore data from a dump\n\t * @param {Array|Object} data - Data to import (from dump)\n\t * @param {string} [type='records'] - Type of data: 'records' or 'indexes'\n\t * @returns {boolean} True if operation succeeded\n\t */\n\toverride (data, type = \"records\") {\n\t\ttry {\n\t\t\tif (type === \"indexes\") {\n\t\t\t\t// Import complete IndexManager state (no reindexing needed)\n\t\t\t\tconst success = this.indexManager.importState(data);\n\t\t\t\tif (!success) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Clear existing data and indexes\n\t\t\t\tthis.clear();\n\n\t\t\t\t// Direct bulk storage override for maximum performance\n\t\t\t\t// Data should already be in correct 2D array format: [[key, value], ...]\n\t\t\t\tthis.storageManager.override(data);\n\n\t\t\t\t// Note: Indexes are not rebuilt - they should be loaded separately via override(indexData, \"indexes\")\n\t\t\t\t// This allows for maximum performance during bulk data restoration\n\n\t\t\t\t// Trigger lifecycle hooks for bulk operation\n\t\t\t\tthis.lifecycleManager.onbatch(data, \"override\");\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Generate a RFC4122 v4 UUID\n\t * @returns {string} UUID string\n\t */\n\tuuid () {\n\t\treturn uuid();\n\t}\n\n\t/**\n\t * Deep clone utility function\n\t * @param {*} obj - Object to clone\n\t * @returns {*} Cloned object\n\t */\n\tclone (obj) {\n\t\tif (obj === null || typeof obj !== \"object\") {\n\t\t\treturn obj;\n\t\t}\n\n\t\tif (obj instanceof Date) {\n\t\t\treturn new Date(obj.getTime());\n\t\t}\n\n\t\tif (obj instanceof RegExp) {\n\t\t\treturn new RegExp(obj);\n\t\t}\n\n\t\tif (Array.isArray(obj)) {\n\t\t\treturn obj.map(item => this.clone(item));\n\t\t}\n\n\t\tconst cloned = {};\n\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\tcloned[key] = this.clone(value);\n\t\t}\n\n\t\treturn cloned;\n\t}\n\n\t/**\n\t * Merge multiple objects into one\n\t * @param {Object} target - Target object\n\t * @param {...Object} sources - Source objects to merge\n\t * @param {boolean} [deep=true] - Whether to perform deep merge\n\t * @returns {Object} Merged object\n\t */\n\tmerge (target, ...sources) {\n\t\tif (!target || typeof target !== \"object\") {\n\t\t\treturn target;\n\t\t}\n\n\t\tconst result = this.clone(target);\n\n\t\tfor (const source of sources) {\n\t\t\tif (source && typeof source === \"object\") {\n\t\t\t\tfor (const [key, value] of Object.entries(source)) {\n\t\t\t\t\tif (typeof value === \"object\" && value !== null && !Array.isArray(value) &&\n\t\t\t\t\t\ttypeof result[key] === \"object\" && result[key] !== null && !Array.isArray(result[key])) {\n\t\t\t\t\t\tresult[key] = this.merge(result[key], value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult[key] = this.clone(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Freeze objects for immutability\n\t * @param {...Object} objects - Objects to freeze\n\t * @returns {Object|Array} Frozen object(s)\n\t */\n\tfreeze (...objects) {\n\t\tconst freeze = obj => {\n\t\t\tif (obj === null || typeof obj !== \"object\") {\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tobj.forEach(item => freeze(item));\n\t\t\t} else {\n\t\t\t\tObject.values(obj).forEach(value => freeze(value));\n\t\t\t}\n\n\t\t\treturn Object.freeze(obj);\n\t\t};\n\n\t\tif (objects.length === 1) {\n\t\t\treturn freeze(objects[0]);\n\t\t}\n\n\t\treturn objects.map(obj => freeze(obj));\n\t}\n\n}\n\n/**\n * Factory function for creating Haro instances\n * @param {Array|Object} [data] - Initial data or configuration\n * @param {Object} [config={}] - Configuration options\n * @returns {Haro} New Haro instance\n */\nexport function haro (data = null, config = {}) {\n\treturn new Haro(data, config);\n}\n\n// Export types and utilities\nexport {\n\tDataTypes,\n\tFieldConstraint,\n\tSchema,\n\tConstraints,\n\tRecord,\n\tRecordCollection,\n\tRecordFactory,\n\tIndexTypes,\n\tRetentionPolicies,\n\tIsolationLevels,\n\tQueryTypes,\n\tErrorRecovery,\n\tImmutableStore,\n\tDataStream\n};\n\n// Default export\nexport default Haro;\n\n"],"names":["g","f","exports","module","require","define","amd","globalThis","self","haro","crypto","this","HaroError","Error","constructor","message","code","context","super","name","timestamp","Date","toISOString","captureStackTrace","toJSON","stack","ValidationError","field","value","RecordNotFoundError","key","storeName","IndexError","indexName","operation","ConfigurationError","configKey","configValue","QueryError","query","TransactionError","transactionId","TypeConstraintError","expected","actual","ConcurrencyError","resource","DataTypes","STRING","NUMBER","BOOLEAN","OBJECT","ARRAY","DATE","UUID","EMAIL","URL","ANY","TypeDetector","getValueType","Array","isArray","basicType","isUUID","isEmail","isURL","isTypeMatch","actualType","expectedType","includes","test","url","Boolean","FieldConstraint","type","required","default","defaultValue","validator","min","max","enum","enumValues","pattern","validate","fieldName","undefined","length","join","customResult","Schema","fields","strict","stripUnknown","record","validated","fieldNames","Object","keys","recordKeys","unknownFields","filter","addField","constraint","removeField","ConfigValidator","config","delimiter","id","immutable","index","indexField","versioning","schema","Constraints","requiredString","options","optionalString","requiredNumber","optionalNumber","uuid","email","values","date","TransactionStates","OperationTypes","IsolationLevels","READ_UNCOMMITTED","READ_COMMITTED","REPEATABLE_READ","SERIALIZABLE","LockTypes","Record","data","metadata","freeze","_key","_data","_metadata","_frozen","get","has","getFields","update","updates","metadataUpdates","newData","newMetadata","updatedAt","version","shouldFreeze","isFrozen","toObject","includeMetadata","result","JSON","stringify","equals","other","clone","clonedData","structuredClone","clonedMetadata","cloned","create","prototype","getSize","matches","predicate","entries","every","recordValue","RegExp","some","v","toString","Symbol","iterator","RecordCollection","records","_records","at","first","last","map","mapper","find","sort","comparator","slice","start","end","reduce","reducer","initialValue","toArray","toObjects","groupBy","keySelector","groups","Map","getKey","set","push","unique","seen","Set","add","forEach","callback","RecordFactory","fromObject","keyField","createCollection","items","item","emptyCollection","IndexTypes","SINGLE","COMPOSITE","PARTIAL","IndexDefinition","transform","_determineType","createdAt","stats","totalKeys","totalEntries","memoryUsage","lastUpdated","suggestedType","generateKeys","_extractKeys","_getFieldValue","parts","split","part","_generateCompositeKeys","String","newKeys","existingKey","val","newKey","updateStats","keyCount","entryCount","memoryDelta","IndexStorage","_storage","_refCounts","indexKey","recordKey","recordSet","remove","removed","delete","newCount","from","getStats","size","_estimateMemoryUsage","clear","IndexManager","_definitions","_indexes","_stats","totalOperations","totalTime","lastOptimized","createIndex","definition","dropIndex","hasIndex","getIndexDefinition","listIndexes","addRecord","recordData","startTime","now","storage","indexKeys","existingRecords","_updatePerformanceStats","removeRecord","updateRecord","oldData","findByIndex","findByCriteria","criteria","indexNames","getOptimalIndex","sortedFields","indexFields","candidates","coverage","a","b","rebuild","rebuildField","indexesToRebuild","indexDef","indexDefinitions","indexStats","totalMemory","indexes","totalIndexes","totalMemoryUsage","performance","averageOperationTime","exportState","definitions","storageData","importState","state","defData","recordKeysArray","operationTime","RetentionPolicies","COUNT","TIME","SIZE","NONE","VersionEntry","_calculateSize","isOlderThan","maxAge","getTime","getAge","VersionHistory","policy","versions","totalSize","lastAccessed","addVersion","_applyRetentionPolicy","getVersion","getLatest","getOldest","getVersionsInRange","getCount","getTotalSize","count","removeOlderThan","oldCount","cutoffTime","keep","_applyCountPolicy","_applyTimePolicy","_applySizePolicy","maxCount","splice","maxSize","shift","versionCount","averageSize","oldestVersion","newestVersion","VersionManager","globalPolicy","_validatePolicy","histories","totalHistories","totalVersions","lastCleanup","cleanupCount","enableVersioning","history","disableVersioning","oldSize","getHistory","versionIndex","getLatestVersion","isVersioningEnabled","cleanup","results","historiesProcessed","versionsRemoved","sizeFreed","keysToProcess","newSize","endTime","duration","setGlobalPolicy","historyStats","averageVersionsPerRecord","averageSizePerRecord","keysToExport","exportData","exportedAt","import","merge","historiesImported","versionsImported","errors","historyData","versionData","defineProperty","writable","error","_updateStats","historiesCleared","versionsCleared","validTypes","TransactionOperation","oldValue","newValue","createRollback","Transaction","isolationLevel","timeout","readOnly","operations","readSet","writeSet","snapshot","validationCallback","abortReason","seal","begin","addOperation","_checkActive","_isTimedOut","setValidation","commit","abort","reason","getRollbackOperations","reverse","op","isActive","isCommitted","isAborted","getDuration","operationCount","readSetSize","writeSetSize","snapshotSize","timedOut","LockManager","locks","lockTimeout","acquireLock","lockType","_tryAcquireLock","Promise","resolve","setTimeout","existingLock","holders","waiters","releaseLock","lock","releaseAllLocks","released","holdsLocks","totalLocks","sharedLocks","exclusiveLocks","lockHolders","recordsLocked","holder","uniqueHolders","TransactionStatistics","totalTransactions","committedTransactions","abortedTransactions","activeTransactions","averageDuration","totalDuration","incrementTotal","incrementCommitted","incrementAborted","incrementActive","decrementActive","updateDurationStats","transaction","lockStats","activeCount","transactionCounter","reset","getRawStats","KeyRelationshipAnalyzer","patternCache","semanticCache","areKeysRelated","key1","key2","_hasHierarchicalKeyRelationship","_hasSemanticKeyRelationship","_hasPatternBasedKeyRelationship","_hasCompositeKeyRelationship","_hasTemporalKeyRelationship","_hasIndexKeyRelationship","_hasCollectionKeyRelationship","_hasFunctionalDependency","isKeyInSnapshotRange","operationKey","snapshotKey","expectedValue","_hasExplicitRangeMetadata","_checkExplicitRange","_isPatternBasedSnapshot","_checkPatternBasedRange","_hasHierarchicalRelationship","_checkHierarchicalRange","_isIndexBasedSnapshot","_checkIndexBasedRange","_hasSemanticRelationship","_checkSemanticRange","_isTemporalSnapshot","_checkTemporalRange","_isCompositeKeySnapshot","_checkCompositeKeyRange","keyMatchesRange","range","prefix","startsWith","keyMatchesQuery","queryInfo","keyMatchesIndexRange","indexRange","separators","sep","parts1","parts2","_isParentChildRelationship","_isSiblingRelationship","_isAncestorDescendantRelationship","opParts","snapParts","_isCollectionMembership","i","shorter","longer","semantics1","_extractSemanticIdentifiers","semantics2","sem1","sem2","_areSemanticallySimilar","_hasEntityRelationship","semanticPrefixes","toLowerCase","opSemantics","snapSemantics","opSemantic","snapSemantic","cacheKey","identifiers","patterns","match","exec","id1","id2","singularPlural","singular","plural","entityRelations","entity1","entity2","hasEntity1InBoth","hasEntity2InBoth","_haveSimilarPatterns","endsWith","replace","beforeBrace","substring","indexOf","afterBrace","choices","choice","fullPattern","trim","baseKey","pattern1","_extractKeyPattern","pattern2","_patternsAreSimilar","_calculatePatternSimilarity","maxLen","Math","_levenshteinDistance","str1","str2","matrix","j","charAt","temporal1","_extractTemporalComponents","temporal2","_haveTemporalOverlap","keyword","opTemporal","snapTemporal","components","hasDate","hasTime","hasTimestamp","hasEpoch","_hasCompositeKeyOverlap","minLength","allMatch","isIndex1","_isIndexKey","isIndex2","base1","_extractBaseKeyFromIndex","base2","isCollection1","_isCollectionKey","isCollection2","_extractCollectionBase","indicator","collectionKey","indicators","dependencies","norm1","_normalizeKeyForDependency","norm2","dep1","dep2","rangeInfo","predicateInfo","clearCaches","DeadlockDetector","lockManager","keyAnalyzer","detectDeadlocks","opts","useLockGraph","useResourceGraph","useTimeoutDetection","timeoutThreshold","deadlocks","suspectedDeadlocks","timeoutVictims","waitForGraph","resourceGraph","lockDeadlocks","_detectLockBasedDeadlocks","cycles","graph","resourceDeadlocks","_detectResourceDeadlocks","isolationDeadlocks","_detectIsolationDeadlocks","_detectTimeoutVictims","_deduplicateDeadlocks","_buildLockWaitForGraph","_detectCyclesInGraph","cycle","transactions","resources","_getResourcesInvolvedInCycle","tx","lockInfo","waitingTransactions","_findTransactionsWaitingForLock","waitingTx","holderId","waiting","hasOperationOnKey","holdsLock","_buildResourceAllocationGraph","_detectCyclesInResourceGraph","txId","visited","recursionStack","dfs","node","path","cycleStart","neighbors","neighbor","wantedResources","holdingTx","graphCycles","t","tx1","tx2","_hasIsolationConflict","conflict","_getIsolationConflictType","tx1ReadsWhatTx2Writes","_readsOtherWrites","tx2ReadsWhatTx1Writes","reader","writer","readKey","victims","deadlock","signature","_createDeadlockSignature","sortedTransactions","sortedResources","IsolationValidator","validateIsolation","allTransactions","_validateReadCommitted","_validateRepeatableRead","_validateSerializable","writeKey","conflictingTransactions","_findConflictingWrites","_hasReadSetConflict","snapshotValue","_hasSnapshotConflict","conflictingWrites","_findConflictingWritesToRead","conflictingReads","_findConflictingReadsToWrite","excludeTransactionId","conflicting","otherTx","_transactionsOverlap","_hasPhantomConflict","_hasSerializationAnomalyInSnapshot","otherTransaction","_hasWriteSkewAnomaly","_hasDependencyCycle","tx1ReadsRelated","_hasRelatedReads","tx2ReadsRelated","tx1Writes","tx2Writes","k","tx1ReadsTx2Writes","tx2ReadsTx1Writes","tx1Start","tx1End","tx2Start","TransactionManager","statistics","deadlockDetector","isolationValidator","getTransaction","cleaned","getActiveTransactions","resetStats","getComponents","validateTransactionIsolation","checkForDeadlocks","getTransactionDetails","getSystemHealth","deadlockResults","commitRate","hasDeadlocks","lockUtilization","CostFactors","INDEX_LOOKUP","FULL_SCAN","FILTER_EVALUATION","SORT_OPERATION","MEMORY_ACCESS","COMPARISON","REGEX_MATCH","QueryPlanStep","estimatedCost","estimatedRows","actualCost","actualRows","startExecution","endExecution","costAccuracy","abs","rowAccuracy","QueryPlan","queryId","originalQuery","steps","totalEstimatedCost","totalEstimatedRows","totalActualCost","totalActualRows","executedAt","completedAt","addStep","step","completeExecution","stepCount","efficiency","explanation","_generateExplanation","DataStatistics","totalRecords","indexStatistics","fieldStatistics","_updateFieldStatistics","_updateIndexStatistics","getSelectivity","fieldStats","uniqueValues","getIndexCardinality","cardinality","fieldData","nullCount","totalLength","dataType","_inferDataType","avgLength","indexStorage","selectivity","avgEntriesPerKey","sample","types","next","QueryOptimizer","collectStatistics","statisticsUpdateInterval","queryCounter","planCache","executionHistory","maxHistorySize","cacheHits","totalCacheRequests","costAdjustments","lastCostModelUpdate","createPlan","plan","_generateCacheKey","cachedPlan","_isCacheValid","_copyPlan","_buildOptimizedPlan","updateStatistics","recordExecution","_updateCostModel","getOptimalStrategy","costedStrategies","_generateStrategies","strategy","_estimateStrategyCost","_getAdjustedCostFactor","planCacheSize","executionHistorySize","dataStatistics","indexCount","fieldCount","averageQueryCost","_calculateAverageQueryCost","cacheHitRate","_calculateCacheHitRate","cacheStatistics","totalRequests","hits","misses","hitRate","costModel","adjustments","fromEntries","_addIndexLookupSteps","_addFilteredScanSteps","_addFullScanSteps","_addPostProcessingSteps","lookupKey","_estimateIndexLookupRows","filterStep","where","scanType","sortBy","sortStep","sortField","sortFunction","limit","limitStep","offset","strategies","indexManager","optimalIndex","_generateLookupKey","availableIndexes","partialFilter","Number","MAX_SAFE_INTEGER","factorName","originalPlan","newQueryId","newPlan","newStep","operationStats","_analyzeOperationPerformance","sampleSize","currentAdjustment","newAdjustment","consistency","avgActualCost","avgEstimatedCost","floor","execution","_mapOperationToCostFactor","costs","estimatedCosts","variance","_calculateVariance","stdDev","sqrt","accuracyScores","estimated","accuracy","sum","score","index_lookup","full_scan","regex","mean","pow","diff","ImmutableStore","_deepFreeze","obj","WeakSet","current","pop","DataStream","batchSize","bufferSize","buffer","ended","position","read","batch","done","readAll","take","StorageManager","_store","override","getStore","estimateMemoryUsage","dataSize","CRUDManager","storageManager","versionManager","existingRecord","finalData","_mergeRecords","includeVersions","existing","merged","QueryManager","queryOptimizer","matchingRecords","_matchesCriteria","_filterByFunction","_filterByObject","search","_fullScanSearch","fieldArray","matchingKeys","_searchIndex","_searchField","_keysToRecordCollection","accumulator","processedCount","thisArg","call","_matchesSearchValue","fieldValue","_searchInRecord","searchValue","searchString","searchObject","BatchManager","crudManager","transactionManager","lifecycleManager","atomic","_executeBatchInTransaction","onbatch","ownTransaction","_executeSetInTransaction","_executeDeleteInTransaction","StreamManager","stream","streamWhere","_createFilteredIterator","streamMap","_createTransformIterator","streamTake","_createLimitedIterator","StatisticsManager","configuration","memory","queries","getStorageStats","getIndexStats","getVersionStats","getTransactionStats","getQueryStats","getPerformanceMetrics","recordsPerIndex","memoryPerRecord","total","indexEfficiency","_calculateIndexEfficiency","overheadRatio","overhead","indexSize","versionSize","indexedExecutions","totalExecutions","generateReport","summary","activeIndexes","optimization","breakdown","recommendations","_generateRecommendations","LifecycleManager","hooks","registerHook","event","handler","unregisterHook","hasActiveHook","executeHook","args","beforeSet","onset","beforeDelete","ondelete","beforeClear","onclear","getHooks","hasHook","clearHooks","Haro","defaults","retentionPolicy","enableTransactions","enableOptimization","userConfig","initialData","queryManager","batchManager","streamManager","statisticsManager","enumerable","_executeInTransaction","compareFn","ascending","aVal","bVal","beginTransaction","commitTransaction","abortTransaction","preserveIndexes","preserveVersions","limitedKeys","reindex","recordEntries","dump","target","sources","source","objects","ErrorRecovery","isRecoverable","getRecoveryActions","createRecoveryStrategy","actions","retryable","backoffMs","QueryTypes","FIND","FILTER","SEARCH","WHERE","SORT","LIMIT","AGGREGATE"],"mappings":"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"}