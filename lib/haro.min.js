/**
 * Har≈ç is a modern immutable DataStore
 *
 * @author Jason Mulligan <jason.mulligan@avoidwork.com>
 * @copyright 2020
 * @license BSD-3-Clause
 * @version 7.0.0
 */
"use strict";!function(e){const t=e.Promise,i=e.Map,r=e.Set,n=[8,9,"a","b"],a={};function clone(e){return JSON.parse(JSON.stringify(e,null,0))}function each(e,t){for(const i of e.entries())t(i[1],i[0]);return e}function keyIndex(e,t,i,r){let n;return n=e.includes(i)?e.split(i).sort((e,t)=>e.localeCompare(t)).map(e=>(void 0!==t[e]?t[e]:"").toString().replace(new RegExp(r,"g"),"").toLowerCase()).join(i):t[e],n}function delIndex(e,t,i,r,n,a){e.forEach(e=>{const o=t.get(e),h=keyIndex(e,n,i,a);if(o.has(h)){const e=o.get(h);e.delete(r),0===e.size&&o.delete(h)}})}function s(){return(65536*(Math.random()+1)|0).toString(16).substring(1)}function setIndex(e,t,i,n,a,o,h){each(o?[o]:e,e=>{const o=t.get(e);if(Array.isArray(a[e])&&!e.includes(i))each(a[e],e=>{o.has(e)||o.set(e,new r),o.get(e).add(n)});else{const t=keyIndex(e,a,i,h);null!=t&&(o.has(t)||o.set(t,new r),o.get(t).add(n))}})}function uuid(){return s()+s()+"-"+s()+"-4"+s().substr(0,3)+"-"+n[Math.floor(4*Math.random())]+s().substr(0,3)+"-"+s()+s()+s()}class Haro{constructor({adapters:e={},debounce:t=0,delimiter:r="|",id:n=uuid(),index:a=[],key:o="",logging:h=!0,pattern:c="\\s*|\\t*",versioning:d=!1}={}){return this.adapters=e,this.data=new i,this.debounce=t,this.debounced=new i,this.delimiter=r,this.id=n,this.index=a,this.indexes=new i,this.key=o,this.logging=h,this.pattern=c,this.size=0,this.worker=null,this.versions=new i,this.versioning=d,Object.defineProperty(this,"registry",{enumerable:!0,get:()=>Array.from(this.data.keys())}),this.reindex()}async batch(e,i="set",r=!1){let n;try{const a="del"===i?e=>this.del(e,!0,r):e=>this.set(null,e,!0,!0,r);n=await t.all(this.beforeBatch(e,i).map(a)),this.onbatch(i,n)}catch(e){throw this.onerror("batch",e),e}return n}beforeBatch(e){return e}beforeClear(){}beforeDelete(){}beforeSet(){}clear(){return this.beforeClear(),this.size=0,this.data.clear(),this.indexes.clear(),this.versions.clear(),this.reindex().onclear(),this}async cmd(e,...t){if(void 0===this.adapters[e]||void 0===a[e])throw new Error(e+" not configured for persistent storage");return await a[e].apply(this,[this,...t])}del(e,t=!1,i=!1,r=!1){if(!1===this.has(e))throw new Error("Record not found");const n=this.get(e,!0);return this.exec(async()=>{this.beforeDelete(e,t,i,r),delIndex(this.index,this.indexes,this.delimiter,e,n,this.pattern),this.data.delete(e),--this.size},async()=>{this.ondelete(e,t,r,i),this.versioning&&this.versions.delete(e)},e=>{throw this.onerror("delete",e),e})}dump(e="records"){const t="records"===e?Array.from(this.entries()):Object.fromEntries(this.indexes);if("indexes"===e)for(const e of Object.keys(t)){t[e]=Object.fromEntries(t[e]);for(const i of Object.keys(t[e]))t[e][i]=Array.from(t[e][i])}return t}entries(){return this.data.entries()}async exec(e,t,i){let r;try{r=await t(await e())}catch(e){i(e)}return r}find(e,t=!1){const n=Object.keys(e).sort((e,t)=>e.localeCompare(t)).join(this.delimiter),a=keyIndex(n,e,this.delimiter,this.pattern),o=Array.from((this.indexes.get(n)||new i).get(a)||new r).map(e=>this.get(e,t));return t?o:this.list(...o)}filter(e,t=!1){const i=this.reduce((i,r,n,a)=>(e.call(a,r)&&i.push(this.get(n,t)),i),[]);return t?i:this.list(...i)}forEach(e,t){return this.data.forEach((t,i)=>e(clone(t),clone(i)),t||this.data),this}get(e,t=!1){const i=clone(this.data.get(e)||null);return i&&!t?this.list(e,i):i}has(e,t=this.data){return t.has(e)}keys(){return this.data.keys()}limit(e=0,t=0,i=!1){const r=this.registry.slice(e,e+t).map(e=>this.get(e,i));return i?r:this.list(...r)}list(...e){return Object.freeze(e.map(e=>Object.freeze(e)))}map(e,t=!1){const i=[];return this.forEach((t,r)=>i.push(e(t,r))),t?i:this.list(...i)}onbatch(e){return e}onclear(){}ondelete(){}onerror(){}onset(){}async override(e,t="records"){if("indexes"===t)this.indexes=new i(Object.keys(e).map(t=>[t,new i(Object.keys(e[t]).map(i=>[i,new r(e[t][i])]))]));else{if("records"!==t)throw new Error("Invalid type");this.indexes.clear(),this.data=new i(e),this.size=this.data.size}return!0}reduce(e,t,i=!1){let r=t||this.data.keys().next().value;return this.forEach((t,n)=>{r=e(r,t,n,this,i)},this),r}reindex(e){const t=e?[e]:this.index;return e&&!1===this.index.includes(e)&&this.index.push(e),each(t,e=>this.indexes.set(e,new i)),this.forEach((e,i)=>each(t,t=>setIndex(this.index,this.indexes,this.delimiter,i,e,t,this.pattern))),this}search(e,t,r=!1){const n=new i,a="function"==typeof e,o=e&&"function"==typeof e.test;return e&&each(t?Array.isArray(t)?t:[t]:this.index,t=>{let i=this.indexes.get(t);i&&i.forEach((i,h)=>{switch(!0){case a&&e(h,t):case o&&e.test(Array.isArray(h)?h.join(", "):h):case h===e:i.forEach(e=>{!n.has(e)&&this.has(e)&&n.set(e,this.get(e,r))})}})}),r?Array.from(n.values()):this.list(...Array.from(n.values()))}async set(e,t,i=!1,n=!1,a=!1,o=!1){let h,c=clone(t);return this.exec(async()=>(null==e&&(e=this.key&&void 0!==c[this.key]?c[this.key]:uuid()),this.beforeSet(e,t,i,n,a,o),this.data.has(e)?(h=this.get(e,!0),delIndex(this.index,this.indexes,this.delimiter,e,h,this.pattern),this.versioning&&this.versions.get(e).add(Object.freeze(clone(h))),!1===n&&(c=function merge(e,t){return e instanceof Object&&t instanceof Object?each(Object.keys(t),i=>{e[i]instanceof Object&&t[i]instanceof Object?e[i]=merge(e[i],t[i]):Array.isArray(e[i])&&Array.isArray(t[i])?e[i]=e[i].concat(t[i]):e[i]=t[i]}):e=Array.isArray(e)&&Array.isArray(t)?e.concat(t):t,e}(clone(h),c))):(++this.size,this.versioning&&this.versions.set(e,new r)),this.data.set(e,c),setIndex(this.index,this.indexes,this.delimiter,e,c,null,this.pattern),this.get(e)),async e=>(this.onset(e,i,o,a),e),e=>{throw this.onerror("set",e),e})}sort(e,t=!0){return t?Object.freeze(this.limit(0,this.size,!0).sort(e).map(e=>Object.freeze(e))):this.limit(0,this.size,!0).sort(e)}sortBy(e,t=!1){const i=[],r=[];let n;return this.indexes.has(e)||this.reindex(e),n=this.indexes.get(e),n.forEach((e,t)=>r.push(t)),each(r.sort(),e=>n.get(e).forEach(e=>i.push(this.get(e,t)))),t?i:this.list(...i)}toArray(e=!1){return this.limit(0,this.data.size,e)}values(){return this.data.values()}where(e,t=!1,i="||"){const r=this.index.filter(t=>t in e);return r.length>0?this.filter(new Function("a",`return (${r.map(t=>{let r;if(Array.isArray(e[t]))r=`Array.isArray(a['${t}']) ? ${e[t].map(e=>`a['${t}'].includes(${"string"==typeof e?`'${e}'`:e})`).join(` ${i} `)} : a['${t}'] === '${e[t].join(",")}'`;else if(e[t]instanceof RegExp)r=`Array.isArray(a['${t}']) ? a['${t}'].filter(i => ${e[t]}.test(a['${t}'])).length > 0 : ${e[t]}.test(a['${t}'])`;else{const i="string"==typeof e[t]?`'${e[t]}'`:e[t];r=`Array.isArray(a['${t}']) ? a['${t}'].includes(${i}) : a['${t}'] === ${i}`}return r}).join(") && (")});`),t):[]}}function factory(e=null,t={}){const i=new Haro(t);return Array.isArray(e)&&i.batch(e,"set"),i}factory.version="7.0.0","undefined"!=typeof exports?module.exports=factory:"function"==typeof define&&void 0!==define.amd?define(()=>factory):e.haro=factory}("undefined"!=typeof window?window:global);